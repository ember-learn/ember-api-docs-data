{
  "project": {
    "name": "EmberData Documentation",
    "description": "Documentation for EmberData: a lightweight reactive data library for JavaScript applications.",
    "url": "https://github.com/emberjs/data",
    "version": "5.4.1+172eb0b6"
  },
  "files": {
    "../-ember-data/src/index.ts": {
      "name": "../-ember-data/src/index.ts",
      "modules": {
        "ember-data-overview": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../active-record/src/-private/builders/find-record.ts": {
      "name": "../active-record/src/-private/builders/find-record.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/active-record/request": 1
      },
      "namespaces": {}
    },
    "../active-record/src/-private/builders/query.ts": {
      "name": "../active-record/src/-private/builders/query.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/active-record/request": 1
      },
      "namespaces": {}
    },
    "../active-record/src/-private/builders/save-record.ts": {
      "name": "../active-record/src/-private/builders/save-record.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/active-record/request": 1
      },
      "namespaces": {}
    },
    "../active-record/src/request.ts": {
      "name": "../active-record/src/request.ts",
      "modules": {
        "@ember-data/active-record/request": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../adapter/src/-private/utils/continue-on-reject.ts": {
      "name": "../adapter/src/-private/utils/continue-on-reject.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../adapter/src/-private/build-url-mixin.ts": {
      "name": "../adapter/src/-private/build-url-mixin.ts",
      "modules": {},
      "classes": {
        "BuildURLMixin": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../adapter/src/-private.ts": {
      "name": "../adapter/src/-private.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../adapter/src/error.js": {
      "name": "../adapter/src/error.js",
      "modules": {
        "@ember-data/adapter/error": 1
      },
      "classes": {
        "AdapterError": 1,
        "InvalidError": 1,
        "TimeoutError": 1,
        "AbortError": 1,
        "UnauthorizedError": 1,
        "ForbiddenError": 1,
        "NotFoundError": 1,
        "ConflictError": 1,
        "ServerError": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../adapter/src/index.ts": {
      "name": "../adapter/src/index.ts",
      "modules": {
        "@ember-data/adapter": 1
      },
      "classes": {
        "Adapter": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../adapter/src/json-api.ts": {
      "name": "../adapter/src/json-api.ts",
      "modules": {
        "@ember-data/adapter/json-api": 1
      },
      "classes": {
        "JSONAPIAdapter": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../adapter/src/rest.ts": {
      "name": "../adapter/src/rest.ts",
      "modules": {
        "@ember-data/adapter/rest": 1
      },
      "classes": {
        "RESTAdapter": 1
      },
      "fors": {
        "@ember-data/adapter/rest": 1
      },
      "namespaces": {}
    },
    "../build-config/src/canary-features.ts": {
      "name": "../build-config/src/canary-features.ts",
      "modules": {},
      "classes": {
        "CanaryFeatures": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../build-config/src/debugging.ts": {
      "name": "../build-config/src/debugging.ts",
      "modules": {},
      "classes": {
        "DebugLogging": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../build-config/src/deprecation-versions.ts": {
      "name": "../build-config/src/deprecation-versions.ts",
      "modules": {},
      "classes": {
        "CurrentDeprecations": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../build-config/src/index.ts": {
      "name": "../build-config/src/index.ts",
      "modules": {
        "@warp-drive/build-config": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../core-types/src/schema/fields.ts": {
      "name": "../core-types/src/schema/fields.ts",
      "modules": {},
      "classes": {
        "<Type> GenericField": 1,
        "<Type> LegacyAliasField": 1,
        "<Type> PolarisAliasField": 1,
        "<Type> ObjectAliasField": 1,
        "<Type> IdentityField": 1,
        "<Type> HashField": 1,
        "<Type> LocalField": 1,
        "<Type> ObjectField": 1,
        "<Type> SchemaObjectField": 1,
        "<Type> ArrayField": 1,
        "<Type> SchemaArrayField": 1,
        "<Type> DerivedField": 1,
        "<Type> ResourceField": 1,
        "<Type> CollectionField": 1,
        "<Type> LegacyAttributeField": 1,
        "<Type> LegacyBelongsToField": 1,
        "<Type> LinksModeBelongsToField": 1,
        "<Type> LegacyHasManyField": 1,
        "<Type> LinksModeHasManyField": 1,
        "<Type> LegacyModeFieldSchema": 1,
        "<Type> PolarisModeFieldSchema": 1,
        "<Type> FieldSchema": 1,
        "<Type> ObjectFieldSchema": 1,
        "<Type> PolarisResourceSchema": 1,
        "<Type> LegacyResourceSchema": 1,
        "<Type> ObjectSchema": 1
      },
      "fors": {
        "@warp-drive/core-types": 1
      },
      "namespaces": {}
    },
    "../core-types/src/spec/json-api-raw.ts": {
      "name": "../core-types/src/spec/json-api-raw.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../core-types/src/cache.ts": {
      "name": "../core-types/src/cache.ts",
      "modules": {},
      "classes": {
        "<Interface> Cache": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../core-types/src/identifier.ts": {
      "name": "../core-types/src/identifier.ts",
      "modules": {},
      "classes": {
        "StableRecordIdentifier": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../core-types/src/index.ts": {
      "name": "../core-types/src/index.ts",
      "modules": {
        "@warp-drive/core-types": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../core-types/src/record.ts": {
      "name": "../core-types/src/record.ts",
      "modules": {},
      "classes": {
        "TypedRecordInstance": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../core-types/src/request.ts": {
      "name": "../core-types/src/request.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../core-types/src/runtime.ts": {
      "name": "../core-types/src/runtime.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../core-types/src/symbols.ts": {
      "name": "../core-types/src/symbols.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../debug/src/data-adapter.ts": {
      "name": "../debug/src/data-adapter.ts",
      "modules": {
        "@ember-data/debug": 1
      },
      "classes": {
        "InspectorDataAdapter": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../ember/src/-private/await.gts": {
      "name": "../ember/src/-private/await.gts",
      "modules": {},
      "classes": {
        "<Throw />": 1,
        "<Await />": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../ember/src/-private/promise-state.ts": {
      "name": "../ember/src/-private/promise-state.ts",
      "modules": {},
      "classes": {
        "PromiseState": 1
      },
      "fors": {
        "@warp-drive/ember": 1
      },
      "namespaces": {}
    },
    "../ember/src/-private/request-state.ts": {
      "name": "../ember/src/-private/request-state.ts",
      "modules": {},
      "classes": {
        "RequestLoadingState": 1,
        "RequestState": 1
      },
      "fors": {
        "@warp-drive/ember": 1
      },
      "namespaces": {}
    },
    "../ember/src/-private/request.gts": {
      "name": "../ember/src/-private/request.gts",
      "modules": {},
      "classes": {
        "<Request />": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../ember/src/index.ts": {
      "name": "../ember/src/index.ts",
      "modules": {
        "@warp-drive/ember": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../graph/src/-private/edges/collection.ts": {
      "name": "../graph/src/-private/edges/collection.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../graph/src/-private/-diff.ts": {
      "name": "../graph/src/-private/-diff.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../graph/src/-private/-edge-definition.ts": {
      "name": "../graph/src/-private/-edge-definition.ts",
      "modules": {},
      "classes": {
        "UpgradedMeta": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../graph/src/-private.ts": {
      "name": "../graph/src/-private.ts",
      "modules": {
        "@ember-data/graph": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../json-api/src/-private/builders/-utils.ts": {
      "name": "../json-api/src/-private/builders/-utils.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/json-api/request": 1
      },
      "namespaces": {}
    },
    "../json-api/src/-private/builders/find-record.ts": {
      "name": "../json-api/src/-private/builders/find-record.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/json-api/request": 1
      },
      "namespaces": {}
    },
    "../json-api/src/-private/builders/query.ts": {
      "name": "../json-api/src/-private/builders/query.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/json-api/request": 1
      },
      "namespaces": {}
    },
    "../json-api/src/-private/builders/save-record.ts": {
      "name": "../json-api/src/-private/builders/save-record.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/json-api/request": 1
      },
      "namespaces": {}
    },
    "../json-api/src/-private/validator/1.1/7.1_top-level-document-members.ts": {
      "name": "../json-api/src/-private/validator/1.1/7.1_top-level-document-members.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../json-api/src/-private/validator/1.1/7.2_resource-objects.ts": {
      "name": "../json-api/src/-private/validator/1.1/7.2_resource-objects.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../json-api/src/-private/validator/1.1/links.ts": {
      "name": "../json-api/src/-private/validator/1.1/links.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../json-api/src/-private/cache.ts": {
      "name": "../json-api/src/-private/cache.ts",
      "modules": {},
      "classes": {
        "Cache": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../json-api/src/-private/serialize.ts": {
      "name": "../json-api/src/-private/serialize.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/json-api/request": 1
      },
      "namespaces": {}
    },
    "../json-api/src/index.ts": {
      "name": "../json-api/src/index.ts",
      "modules": {
        "@ember-data/json-api": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../json-api/src/request.ts": {
      "name": "../json-api/src/request.ts",
      "modules": {
        "@ember-data/json-api/request": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/builders/find-all.ts": {
      "name": "../legacy-compat/src/builders/find-all.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/legacy-compat/builders": 1
      },
      "namespaces": {}
    },
    "../legacy-compat/src/builders/find-record.ts": {
      "name": "../legacy-compat/src/builders/find-record.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/legacy-compat/builders": 1
      },
      "namespaces": {}
    },
    "../legacy-compat/src/builders/query.ts": {
      "name": "../legacy-compat/src/builders/query.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/legacy-compat/builders": 1
      },
      "namespaces": {}
    },
    "../legacy-compat/src/builders/save-record.ts": {
      "name": "../legacy-compat/src/builders/save-record.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/legacy-compat/builders": 1
      },
      "namespaces": {}
    },
    "../legacy-compat/src/legacy-network-handler/fetch-manager.ts": {
      "name": "../legacy-compat/src/legacy-network-handler/fetch-manager.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts": {
      "name": "../legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "modules": {},
      "classes": {
        "<Interface> Adapter": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts": {
      "name": "../legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts",
      "modules": {},
      "classes": {
        "<Interface> Serializer": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/legacy-network-handler/serializer-response.ts": {
      "name": "../legacy-compat/src/legacy-network-handler/serializer-response.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/legacy-network-handler/snapshot-record-array.ts": {
      "name": "../legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "modules": {},
      "classes": {
        "SnapshotRecordArray": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/legacy-network-handler/snapshot.ts": {
      "name": "../legacy-compat/src/legacy-network-handler/snapshot.ts",
      "modules": {},
      "classes": {
        "Snapshot": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/-private.ts": {
      "name": "../legacy-compat/src/-private.ts",
      "modules": {
        "@ember-data/legacy-compat": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/builders.ts": {
      "name": "../legacy-compat/src/builders.ts",
      "modules": {
        "@ember-data/legacy-compat/builders": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/index.ts": {
      "name": "../legacy-compat/src/index.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../legacy-compat/src/utils.ts": {
      "name": "../legacy-compat/src/utils.ts",
      "modules": {
        "@ember-data/legacy-compat/utils": 1
      },
      "classes": {},
      "fors": {
        "@ember-data/legacy-compat/utils": 1
      },
      "namespaces": {}
    },
    "../model/src/-private/references/belongs-to.ts": {
      "name": "../model/src/-private/references/belongs-to.ts",
      "modules": {},
      "classes": {
        "BelongsToReference": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../model/src/-private/references/has-many.ts": {
      "name": "../model/src/-private/references/has-many.ts",
      "modules": {},
      "classes": {
        "HasManyReference": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../model/src/-private/attr.ts": {
      "name": "../model/src/-private/attr.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/model": 1
      },
      "namespaces": {}
    },
    "../model/src/-private/belongs-to.ts": {
      "name": "../model/src/-private/belongs-to.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/model": 1
      },
      "namespaces": {}
    },
    "../model/src/-private/errors.ts": {
      "name": "../model/src/-private/errors.ts",
      "modules": {},
      "classes": {
        "Errors": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../model/src/-private/has-many.ts": {
      "name": "../model/src/-private/has-many.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/model": 1
      },
      "namespaces": {}
    },
    "../model/src/-private/model.ts": {
      "name": "../model/src/-private/model.ts",
      "modules": {},
      "classes": {
        "Model": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../model/src/-private/promise-belongs-to.ts": {
      "name": "../model/src/-private/promise-belongs-to.ts",
      "modules": {},
      "classes": {
        "PromiseBelongsTo": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../model/src/-private/promise-many-array.ts": {
      "name": "../model/src/-private/promise-many-array.ts",
      "modules": {},
      "classes": {
        "PromiseManyArray": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../model/src/-private/record-state.ts": {
      "name": "../model/src/-private/record-state.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../model/src/-private/type-utils.ts": {
      "name": "../model/src/-private/type-utils.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../model/src/index.ts": {
      "name": "../model/src/index.ts",
      "modules": {
        "@ember-data/model": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../request-utils/src/-private/string/transform.ts": {
      "name": "../request-utils/src/-private/string/transform.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../request-utils/src/index.ts": {
      "name": "../request-utils/src/index.ts",
      "modules": {
        "@ember-data/request-utils": 1
      },
      "classes": {
        "CachePolicy": 1
      },
      "fors": {
        "@ember-data/request-utils": 1
      },
      "namespaces": {}
    },
    "../request/src/-private/manager.ts": {
      "name": "../request/src/-private/manager.ts",
      "modules": {
        "@ember-data/request": 1
      },
      "classes": {
        "RequestManager": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../request/src/-private/types.ts": {
      "name": "../request/src/-private/types.ts",
      "modules": {},
      "classes": {
        "Future": 1,
        "<Interface> Handler": 1,
        "<Interface> CacheHandler": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../request/src/fetch.ts": {
      "name": "../request/src/fetch.ts",
      "modules": {
        "@ember-data/request/fetch": 1
      },
      "classes": {
        "Fetch": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../rest/src/-private/builders/find-record.ts": {
      "name": "../rest/src/-private/builders/find-record.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/rest/request": 1
      },
      "namespaces": {}
    },
    "../rest/src/-private/builders/query.ts": {
      "name": "../rest/src/-private/builders/query.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/rest/request": 1
      },
      "namespaces": {}
    },
    "../rest/src/-private/builders/save-record.ts": {
      "name": "../rest/src/-private/builders/save-record.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/rest/request": 1
      },
      "namespaces": {}
    },
    "../rest/src/request.ts": {
      "name": "../rest/src/request.ts",
      "modules": {
        "@ember-data/rest/request": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../schema-record/src/-private/schema.ts": {
      "name": "../schema-record/src/-private/schema.ts",
      "modules": {},
      "classes": {
        "SchemaService": 1
      },
      "fors": {
        "@warp-drive/schema-record": 1
      },
      "namespaces": {}
    },
    "../schema-record/src/index.ts": {
      "name": "../schema-record/src/index.ts",
      "modules": {
        "@warp-drive/schema-record": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/-private/transforms/boolean.ts": {
      "name": "../serializer/src/-private/transforms/boolean.ts",
      "modules": {},
      "classes": {
        "BooleanTransform": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/-private/transforms/date.ts": {
      "name": "../serializer/src/-private/transforms/date.ts",
      "modules": {},
      "classes": {
        "DateTransform": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/-private/transforms/number.ts": {
      "name": "../serializer/src/-private/transforms/number.ts",
      "modules": {},
      "classes": {
        "NumberTransform": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/-private/transforms/string.ts": {
      "name": "../serializer/src/-private/transforms/string.ts",
      "modules": {},
      "classes": {
        "StringTransform": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/-private/transforms/transform.ts": {
      "name": "../serializer/src/-private/transforms/transform.ts",
      "modules": {},
      "classes": {
        "Transform": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/-private/embedded-records-mixin.js": {
      "name": "../serializer/src/-private/embedded-records-mixin.js",
      "modules": {},
      "classes": {
        "EmbeddedRecordsMixin": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/index.ts": {
      "name": "../serializer/src/index.ts",
      "modules": {
        "@ember-data/serializer": 1
      },
      "classes": {
        "Serializer": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/json-api.js": {
      "name": "../serializer/src/json-api.js",
      "modules": {
        "@ember-data/serializer/json-api": 1
      },
      "classes": {
        "JSONAPISerializer": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/json.js": {
      "name": "../serializer/src/json.js",
      "modules": {
        "@ember-data/serializer/json": 1
      },
      "classes": {
        "JSONSerializer": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/rest.js": {
      "name": "../serializer/src/rest.js",
      "modules": {
        "@ember-data/serializer/rest": 1
      },
      "classes": {
        "RESTSerializer": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../serializer/src/transform.ts": {
      "name": "../serializer/src/transform.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/cache-handler/handler.ts": {
      "name": "../store/src/-private/cache-handler/handler.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/cache-handler/types.ts": {
      "name": "../store/src/-private/cache-handler/types.ts",
      "modules": {},
      "classes": {
        "<Interface> CachePolicy": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/caches/identifier-cache.ts": {
      "name": "../store/src/-private/caches/identifier-cache.ts",
      "modules": {},
      "classes": {
        "IdentifierCache": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/caches/instance-cache.ts": {
      "name": "../store/src/-private/caches/instance-cache.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/store": 1
      },
      "namespaces": {}
    },
    "../store/src/-private/legacy-model-support/record-reference.ts": {
      "name": "../store/src/-private/legacy-model-support/record-reference.ts",
      "modules": {},
      "classes": {
        "RecordReference": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/managers/cache-capabilities-manager.ts": {
      "name": "../store/src/-private/managers/cache-capabilities-manager.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/managers/cache-manager.ts": {
      "name": "../store/src/-private/managers/cache-manager.ts",
      "modules": {},
      "classes": {
        "CacheManager": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/managers/notification-manager.ts": {
      "name": "../store/src/-private/managers/notification-manager.ts",
      "modules": {},
      "classes": {
        "NotificationManager": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/managers/record-array-manager.ts": {
      "name": "../store/src/-private/managers/record-array-manager.ts",
      "modules": {},
      "classes": {
        "RecordArrayManager": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/network/request-cache.ts": {
      "name": "../store/src/-private/network/request-cache.ts",
      "modules": {},
      "classes": {
        "RequestStateService": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/record-arrays/identifier-array.ts": {
      "name": "../store/src/-private/record-arrays/identifier-array.ts",
      "modules": {},
      "classes": {
        "RecordArray": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/record-arrays/many-array.ts": {
      "name": "../store/src/-private/record-arrays/many-array.ts",
      "modules": {},
      "classes": {
        "ManyArray": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/record-arrays/native-proxy-type-fix.ts": {
      "name": "../store/src/-private/record-arrays/native-proxy-type-fix.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/utils/coerce-id.ts": {
      "name": "../store/src/-private/utils/coerce-id.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/utils/uuid-polyfill.ts": {
      "name": "../store/src/-private/utils/uuid-polyfill.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/document.ts": {
      "name": "../store/src/-private/document.ts",
      "modules": {},
      "classes": {
        "ReactiveDocument": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private/store-service.ts": {
      "name": "../store/src/-private/store-service.ts",
      "modules": {},
      "classes": {
        "Store": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-types/q/cache-capabilities-manager.ts": {
      "name": "../store/src/-types/q/cache-capabilities-manager.ts",
      "modules": {},
      "classes": {
        "CacheCapabilitiesManager": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-types/q/ds-model.ts": {
      "name": "../store/src/-types/q/ds-model.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-types/q/identifier.ts": {
      "name": "../store/src/-types/q/identifier.ts",
      "modules": {},
      "classes": {},
      "fors": {
        "@ember-data/store": 1
      },
      "namespaces": {}
    },
    "../store/src/-types/q/record-data-json-api.ts": {
      "name": "../store/src/-types/q/record-data-json-api.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-types/q/record-instance.ts": {
      "name": "../store/src/-types/q/record-instance.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-types/q/schema-service.ts": {
      "name": "../store/src/-types/q/schema-service.ts",
      "modules": {},
      "classes": {
        "<Interface> SchemaService": 1
      },
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-types/q/store.ts": {
      "name": "../store/src/-types/q/store.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-types/overview.ts": {
      "name": "../store/src/-types/overview.ts",
      "modules": {
        "@ember-data/experimental-preview-types": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/-private.ts": {
      "name": "../store/src/-private.ts",
      "modules": {},
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../store/src/index.ts": {
      "name": "../store/src/index.ts",
      "modules": {
        "@ember-data/store": 1
      },
      "classes": {},
      "fors": {},
      "namespaces": {}
    },
    "../tracking/src/-private.ts": {
      "name": "../tracking/src/-private.ts",
      "modules": {
        "@ember-data/tracking": 1
      },
      "classes": {},
      "fors": {
        "@ember-data/tracking": 1
      },
      "namespaces": {}
    }
  },
  "modules": {
    "ember-data-overview": {
      "name": "ember-data-overview",
      "submodules": {},
      "elements": {},
      "classes": {},
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../-ember-data/src/index.ts",
      "line": 1,
      "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n   />\n</p>\n\n<p align=\"center\">\n <br>\n <a href=\"https://warp-drive.io\">EmberData</a> is a lightweight data library for web apps &mdash;\n <br>\n universal, typed, reactive, and ready to scale.\n <br/><br/>\n<p>\n\n---\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em rgb(35, 134, 54); background: #e0e0e0;\">\n <h4 style=\"color: rgb(35, 134, 54)\">üí° TIP</h4>\n <p>\n   EmberData is going universal and rebranding as WarpDrive\n   with support for any signals based reactive framework!\n </p>\n <p>\n   This means you may already see some references to WarpDrive.\n </p>\n</blockquote>\n\nEmberData provides features that make it easy to build scalable, fast, feature\nrich application &mdash; letting you ship better experiences more quickly without re-architecting your app or API. EmberData is:\n\n- ‚ö°Ô∏è Committed to Best-In-Class Performance\n- üíö Typed\n- ‚öõÔ∏è Works with any API\n- üå≤ Focused on being as tiny as possible\n- üöÄ SSR Ready\n- üîú Seamless reactivity in any framework\n- üêπ Built with ‚ô•Ô∏è by [Ember](https://emberjs.com)\n\n\n## Basic Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add ember-data\n```\n\n`ember-data` is installed by default for new applications generated with `ember-cli`. You can check what version is installed by looking in the `devDependencies` hash of your project's [package.json](https://docs.npmjs.com/cli/v8/configuring-npm/package-json) file.\n\nIf you have generated a new `Ember` application using `ember-cli` but do\nnot wish to use `ember-data`, remove `ember-data` from your project's `package.json` file and run your package manager's install command to update your lockfile.\n\n## Advanced Installation\n\nEmberData is organized into primitives that compose together via public APIs. These primitives are organized into\nsmall packages encapsulating these boundaries. These packages\ndeclare peer-dependencies (sometimes optional peer dependencies)\non the other EmberData\\/WarpDrive packages they require use of.\n\n- [@ember-data/request](../modules/@ember-data%2Frequest) provides managed `fetch`\n- [@ember-data/request-utils](../modules/@ember-data%2Frequest-utils) provides optional utilities for managing requests and string manipulation\n- [@ember-data/store](../modules/@ember-data%2Fstore) provides core functionality around coordinating caching and reactivity\n- [@ember-data/tracking](../modules/@ember-data%2Ftracking) enables integration with Ember's reactivity system\n- [@ember-data/json-api](../modules/@ember-data%2Fjson-api) provides a cache for data in the [{JSON:API}](https://jsonapi.org) format.\n- [@ember-data/debug](../modules/@ember-data%2Fdebug) provides (optional) debugging support for the `ember-inspector`.\n- [@warp-drive/build-config](../modules/@warp-drive%2Fbuild-config) provides a build plugin which ensures proper settings configuration for deprecations, optional features, development/testing support and debug logging.\n- [@warp-drive/core-types](../modules/@warp-drive%2Fcore-types) provides core types and symbols used by all other packages\n- [@warp-drive/schema-record](../modules/@warp-drive%2Fschema-record) provides a flexible, schema-based approach to reactive data.\n- [@warp-drive/ember](../modules/@warp-drive%2Fember) provides Ember specific components and utilities for reactive control-flow and declarative state management.\n\nSome EmberData APIs are older than others, and these still interop via well-defined\npublic API boundaries but are no longer the ideal approach.\n\n- [@ember-data/model](../modules/@ember-data%2Fmodel) provides a class-based approach to declaring schemas for reactive data.\n- [@ember-data/legacy-compat](../modules/@ember-data%2Flegacy-compat) provides support for the older adapter/serializer request paradigm that is being phased out\n- [@ember-data/adapter](../modules/@ember-data%2Fadapter) provides various network API integrations for APIs built over specific REST or [{JSON:API}](https://jsonapi.org) conventions.\n- [@ember-data/serializer](../modules/@ember-data%2Fserializer) provides an approach to normalizing and serializing data to and from an API format into the [{JSON:API}](https://jsonapi.org) format.\n\nAnd finally:\n\n- `ember-data` is a \"meta\" package which bundles many of these together for convenience in a \"legacy\" configuration.\n\n## Configuration Settings\n\n- [Configuration Settings](../modules/@warp-drive%2Fbuild-config)",
      "itemtype": "main"
    },
    "@ember-data/active-record/request": {
      "name": "@ember-data/active-record/request",
      "submodules": {},
      "elements": {},
      "classes": {
        "@ember-data/active-record/request": 1
      },
      "fors": {
        "@ember-data/active-record/request": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../active-record/src/request.ts",
      "line": 1,
      "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n />\n</p>\n\nThis package provides utilities for working with [ActiveRecord](https://guides.rubyonrails.org/active_record_basics.html#convention-over-configuration-in-active-record) APIs with [*Ember***Data**](https://github.com/emberjs/data/).\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/active-record\n```\n\n## Usage\n\nRequest builders are functions that produce [Fetch Options](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\nThey take a few contextual inputs about the request you want to make, abstracting away the gnarlier details.\n\nFor instance, to fetch a resource from your API\n\n```ts\nimport { findRecord } from '@ember-data/active-record/request';\n\nconst options = findRecord('ember-developer', '1', { include: ['pets', 'friends'] });\n\n/\\*\n => {\n   url: 'https://api.example.com/v1/ember_developers/1?include=friends,pets',\n   method: 'GET',\n   headers: <Headers>, // 'Content-Type': 'application/json;charset=utf-8'\n   op: 'findRecord';\n   records: [{ type: 'ember-developer', id: '1' }]\n }\n\\/\n```\n\nRequest builder output may be used with either `requestManager.request` or `store.request`.\n\nURLs are stable. The same query will produce the same URL every time, even if the order of keys in\nthe query or values in an array changes.\n\nURLs follow the most common ActiveRecord format (underscored pluralized resource types).\n\n### Available Builders\n\n- [createRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/createRecord)\n- [deleteRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/deleteRecord)\n- [findRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/findRecord)\n- [query](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/query)\n- [updateRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/updateRecord)",
      "itemtype": "main"
    },
    "@ember-data/adapter": {
      "name": "@ember-data/adapter",
      "submodules": {},
      "elements": {},
      "classes": {
        "BuildURLMixin": 1,
        "Adapter": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../adapter/src/index.ts",
      "line": 201,
      "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new adapter, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nIn order to properly fetch and update data, EmberData\nneeds to understand how to connect to your API.\n\n`Adapters` accept various kinds of requests from the store\nand manage fulfillment of the request from your API.\n\n### Request Flow\n\nWhen the store decides it needs to issue a request it uses the\nfollowing flow to manage the request and process the data.\n\n- find the appropriate adapter\n- issue the request to the adapter\n- await the adapter's response\n  - if an error occurs reject with the error\n  - if no error\n    - if there is response data\n      - pass the response data to the appropriate serializer\n      - update the cache using the JSON:API formatted data from the serializer's response\n    - return the primary record(s) associated with the request\n\n### Request Errors\n\nWhen a request errors and your adapter does not have the ability to recover from the error,\nyou may either reject the promise returned by your adapter method with the error or simply\nthrow the error.\n\nIf the request was for a `createRecord` `updateRecord` or `deleteRecord` special rules\napply to how this error will affect the state of the store and additional properties on\nthe `Error` class may be used. See the documentation for these methods in\n[<Interface> Adapter](/ember-data/release/classes/%3CInterface%3E%20Adapter) for more information.\n\n### Implementing an Adapter\n\nThere are seven required adapter methods, one for each of\nthe primary request types that EmberData issues.\n\nThey are:\n\n- findRecord\n- findAll\n- queryRecord\n- query\n- createRecord\n- updateRecord\n- deleteRecord\n\nEach of these request types has a matching store method that triggers it\nand matching `requestType` that is passed to the serializer's\n`normalizeResponse` method.\n\nIf your app only reads data but never writes data, it is not necessary\nto implement the methods for create, update, and delete. This extends to\nall of the store's find methods with the exception of `findRecord` (`findAll`,\n`query`, `queryRecord`): if you do not use the store method in your app then\nyour Adapter does not need the method.\n\n```ts\nasync function fetchData(url, options = {}) {\n  let response = await fetch(url, options);\n  return response.toJSON();\n}\n\nexport default class ApplicationAdapter {\n  findRecord(_, { modelName }, id) {\n    return fetchData(`./${modelName}s/${id}`);\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```\n\n### Adapter Resolution\n\n`store.adapterFor(name)` will lookup adapters defined in `app/adapters/` and\nreturn an instance.\n\n`adapterFor` first attempts to find an adapter with an exact match on `name`,\nthen falls back to checking for the presence of an adapter named `application`.\n\nIf no adapter is found, an error will be thrown.\n\n```ts\nstore.adapterFor('author');\n\n// lookup paths (in order) =>\n//   app/adapters/author.js\n//   app/adapters/application.js\n```\n\nMost requests in EmberData are made with respect to a particular `type` (or `modelName`)\n(e.g., \"get me the full collection of **books**\" or \"get me the **employee** whose id is 37\"). We\nrefer to this as the **primary** resource `type`.\n\n`adapterFor` is used by the store to find an adapter with a name matching that of the primary\nresource `type` for the request, which then falls back to the `application` adapter.\n\nIt is recommended that applications define only a single `application` adapter and serializer\nwhere possible, only implementing an adapter specific to the `type` when absolutely necessary.\n\nIf you need to support multiple API versions for the same type, the per-type strategy for\ndefining adapters might not be adequate.\n\nIf you have multiple APIs or multiple API versions and the single application adapter and per-type\nstrategy does not suite your needs, one strategy is to write an `application` adapter and serializer\nthat make use of `options` to specify the desired format when making a request, then forwards to the\nrequest to the desired adapter or serializer as needed.\n\n```app/adapters/application.js\nexport default class Adapter extends EmberObject {\n  findRecord(store, schema, id, snapshot) {\n    let { apiVersion } = snapshot.adapterOptions;\n    return this.adapterFor(`-api-${apiVersion}`).findRecord(store, schema, id, snapshot);\n  }\n}\n```\n\n### Overriding `Store.adapterFor`\n\n```js\nimport Store from '@ember-data/store';\nimport Adapter from '@ember-data/adapter/json-api';\n\nclass extends Store {\n  #adapter = new Adapter();\n\n  adapterFor() {\n    return this.#adapter;\n  }\n}\n```\n\n\nNote: If you are using Ember and would like to make use of `service` injections in your adapter, you will want to additionally `setOwner` for the Adapter.\n\n```js\nimport Store from '@ember-data/store';\nimport Adapter from '@ember-data/adapter/json-api';\nimport { getOwner, setOwner } from '@ember/owner';\n\nclass extends Store {\n  #adapter = null;\n\n  adapterFor() {\n    let adapter = this.#adapter;\n    if (!adapter) {\n      const owner = getOwner(this);\n      adapter = new Adapter();\n      setOwner(adapter, owner);\n      this.#adapter = adapter;\n    }\n\n    return adapter;\n  }\n}\n```\n\nBy default when using with Ember you only need to implement this hook if you want your adapter usage to be statically analyzeable. *Ember***Data** will attempt to resolve adapters using Ember's resolver. To provide a single Adapter for your application like the above you would provide it as the default export of the file `app/adapters/application.{js/ts}`\n\n### Using an Adapter\n\nAny adapter in `app/adapters/` can be looked up by `name` using `store.adapterFor(name)`.\n\n### Default Adapters\n\nApplications whose API's structure endpoint URLs *very close to* or *exactly* the **REST**\nor **JSON:API** convention, the `@ember-data/adapter` package contains implementations\nthese applications can extend.\n\nMany applications will find writing their own adapter to be allow greater flexibility,\ncustomization, and maintenance than attempting to override methods in these adapters.",
      "itemtype": "main"
    },
    "@ember-data/adapter/error": {
      "name": "@ember-data/adapter/error",
      "submodules": {},
      "elements": {},
      "classes": {
        "AdapterError": 1,
        "InvalidError": 1,
        "TimeoutError": 1,
        "AbortError": 1,
        "UnauthorizedError": 1,
        "ForbiddenError": 1,
        "NotFoundError": 1,
        "ConflictError": 1,
        "ServerError": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../adapter/src/error.js",
      "line": 342,
      "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new adapter, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nAn `AdapterError` is used by an adapter to signal that an error occurred\nduring a request to an external API. It indicates a generic error, and\nsubclasses are used to indicate specific error states.\n\nTo create a custom error to signal a specific error state in communicating\nwith an external API, extend the `AdapterError`. For example, if the\nexternal API exclusively used HTTP `503 Service Unavailable` to indicate\nit was closed for maintenance:\n\n```app/adapters/maintenance-error.js\nimport AdapterError from '@ember-data/adapter/error';\n\nexport default AdapterError.extend({ message: \"Down for maintenance.\" });\n```\n\nThis error would then be returned by an adapter's `handleResponse` method:\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\nimport MaintenanceError from './maintenance-error';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  handleResponse(status) {\n    if (503 === status) {\n      return new MaintenanceError();\n    }\n\n    return super.handleResponse(...arguments);\n  }\n}\n```\n\nAnd can then be detected in an application and used to send the user to an\n`under-maintenance` route:\n\n```app/routes/application.js\nimport MaintenanceError from '../adapters/maintenance-error';\n\nexport default class ApplicationRoute extends Route {\n  actions: {\n    error(error, transition) {\n      if (error instanceof MaintenanceError) {\n        this.transitionTo('under-maintenance');\n        return;\n      }\n\n      // ...other error handling logic\n    }\n  }\n}\n```",
      "itemtype": "main"
    },
    "@ember-data/adapter/json-api": {
      "name": "@ember-data/adapter/json-api",
      "submodules": {},
      "elements": {},
      "classes": {
        "JSONAPIAdapter": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../adapter/src/json-api.ts",
      "line": 16,
      "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new adapter, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nThe `JSONAPIAdapter` is an adapter whichtransforms the store's\nrequests into HTTP requests that follow the [JSON API format](http://jsonapi.org/format/).\n\n## JSON API Conventions\n\nThe JSONAPIAdapter uses JSON API conventions for building the URL\nfor a record and selecting the HTTP verb to use with a request. The\nactions you can take on a record map onto the following URLs in the\nJSON API adapter:\n\n<table>\n<tr>\n  <th>\n    Action\n  </th>\n  <th>\n    HTTP Verb\n  </th>\n  <th>\n    URL\n  </th>\n</tr>\n<tr>\n  <th>\n    `store.findRecord('post', 123)`\n  </th>\n  <td>\n    GET\n  </td>\n  <td>\n    /posts/123\n  </td>\n</tr>\n<tr>\n  <th>\n    `store.findAll('post')`\n  </th>\n  <td>\n    GET\n  </td>\n  <td>\n    /posts\n  </td>\n</tr>\n<tr>\n  <th>\n    Update `postRecord.save()`\n  </th>\n  <td>\n    PATCH\n  </td>\n  <td>\n    /posts/123\n  </td>\n</tr>\n<tr>\n  <th>\n    Create `store.createRecord('post').save()`\n  </th>\n  <td>\n    POST\n  </td>\n  <td>\n    /posts\n  </td>\n</tr>\n<tr>\n  <th>\n    Delete `postRecord.destroyRecord()`\n  </th>\n  <td>\n    DELETE\n  </td>\n  <td>\n    /posts/123\n  </td>\n</tr>\n</table>\n\n## Success and failure\n\nThe JSONAPIAdapter will consider a success any response with a\nstatus code of the 2xx family (\"Success\"), as well as 304 (\"Not\nModified\"). Any other status code will be considered a failure.\n\nOn success, the request promise will be resolved with the full\nresponse payload.\n\nFailed responses with status code 422 (\"Unprocessable Entity\") will\nbe considered \"invalid\". The response will be discarded, except for\nthe `errors` key. The request promise will be rejected with a\n`InvalidError`. This error object will encapsulate the saved\n`errors` value.\n\nAny other status codes will be treated as an adapter error. The\nrequest promise will be rejected, similarly to the invalid case,\nbut with an instance of `AdapterError` instead.\n\n### Endpoint path customization\n\nEndpoint paths can be prefixed with a `namespace` by setting the\nnamespace property on the adapter:\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  namespace = 'api/1';\n}\n```\nRequests for the `person` model would now target `/api/1/people/1`.\n\n### Host customization\n\nAn adapter can target other hosts by setting the `host` property.\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  host = 'https://api.example.com';\n}\n```\n\nRequests for the `person` model would now target\n`https://api.example.com/people/1`.",
      "since": "1.13.0",
      "itemtype": "main"
    },
    "@ember-data/adapter/rest": {
      "name": "@ember-data/adapter/rest",
      "submodules": {},
      "elements": {},
      "classes": {
        "RESTAdapter": 1,
        "@ember-data/adapter/rest": 1
      },
      "fors": {
        "@ember-data/adapter/rest": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../adapter/src/rest.ts",
      "line": 68,
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n The REST adapter allows your store to communicate with an HTTP server by\n transmitting JSON via XHR.\n\n This adapter is designed around the idea that the JSON exchanged with\n the server should be conventional. It builds URLs in a manner that follows\n the structure of most common REST-style web services.\n\n ## Success and failure\n\n The REST adapter will consider a success any response with a status code\n of the 2xx family (\"Success\"), as well as 304 (\"Not Modified\"). Any other\n status code will be considered a failure.\n\n On success, the request promise will be resolved with the full response\n payload.\n\n Failed responses with status code 422 (\"Unprocessable Entity\") will be\n considered \"invalid\". The response will be discarded, except for the\n `errors` key. The request promise will be rejected with a `InvalidError`.\n This error object will encapsulate the saved `errors` value.\n\n Any other status codes will be treated as an \"adapter error\". The request\n promise will be rejected, similarly to the \"invalid\" case, but with\n an instance of `AdapterError` instead.\n\n ## JSON Structure\n\n The REST adapter expects the JSON returned from your server to follow\n these conventions.\n\n ### Object Root\n\n The JSON payload should be an object that contains the record inside a\n root property. For example, in response to a `GET` request for\n `/posts/1`, the JSON should look like this:\n\n ```js\n {\n   \"posts\": {\n     \"id\": 1,\n     \"title\": \"I'm Running to Reform the W3C\",\n     \"author\": \"Yehuda Katz\"\n   }\n }\n ```\n\n Similarly, in response to a `GET` request for `/posts`, the JSON should\n look like this:\n\n ```js\n {\n   \"posts\": [\n     {\n       \"id\": 1,\n       \"title\": \"I'm Running to Reform the W3C\",\n       \"author\": \"Yehuda Katz\"\n     },\n     {\n       \"id\": 2,\n       \"title\": \"Rails is omakase\",\n       \"author\": \"D2H\"\n     }\n   ]\n }\n ```\n\n Note that the object root can be pluralized for both a single-object response\n and an array response: the REST adapter is not strict on this. Further, if the\n HTTP server responds to a `GET` request to `/posts/1` (e.g. the response to a\n `findRecord` query) with more than one object in the array, Ember Data will\n only display the object with the matching ID.\n\n ### Conventional Names\n\n Attribute names in your JSON payload should be the camelCased versions of\n the attributes in your Ember.js models.\n\n For example, if you have a `Person` model:\n\n ```app/models/person.js\n import Model, { attr } from '@ember-data/model';\n\n export default Model.extend({\n   firstName: attr('string'),\n   lastName: attr('string'),\n   occupation: attr('string')\n });\n ```\n\n The JSON returned should look like this:\n\n ```js\n {\n   \"people\": {\n     \"id\": 5,\n     \"firstName\": \"Zaphod\",\n     \"lastName\": \"Beeblebrox\",\n     \"occupation\": \"President\"\n   }\n }\n ```\n\n #### Relationships\n\n Relationships are usually represented by ids to the record in the\n relationship. The related records can then be sideloaded in the\n response under a key for the type.\n\n ```js\n {\n   \"posts\": {\n     \"id\": 5,\n     \"title\": \"I'm Running to Reform the W3C\",\n     \"author\": \"Yehuda Katz\",\n     \"comments\": [1, 2]\n   },\n   \"comments\": [{\n     \"id\": 1,\n     \"author\": \"User 1\",\n     \"message\": \"First!\",\n   }, {\n     \"id\": 2,\n     \"author\": \"User 2\",\n     \"message\": \"Good Luck!\",\n   }]\n }\n ```\n\n If the records in the relationship are not known when the response\n is serialized it's also possible to represent the relationship as a\n URL using the `links` key in the response. Ember Data will fetch\n this URL to resolve the relationship when it is accessed for the\n first time.\n\n ```js\n {\n   \"posts\": {\n     \"id\": 5,\n     \"title\": \"I'm Running to Reform the W3C\",\n     \"author\": \"Yehuda Katz\",\n     \"links\": {\n       \"comments\": \"/posts/5/comments\"\n     }\n   }\n }\n ```\n\n ### Errors\n\n If a response is considered a failure, the JSON payload is expected to include\n a top-level key `errors`, detailing any specific issues. For example:\n\n ```js\n {\n   \"errors\": {\n     \"msg\": \"Something went wrong\"\n   }\n }\n ```\n\n This adapter does not make any assumptions as to the format of the `errors`\n object. It will simply be passed along as is, wrapped in an instance\n of `InvalidError` or `AdapterError`. The serializer can interpret it\n afterwards.\n\n ## Customization\n\n ### Endpoint path customization\n\n Endpoint paths can be prefixed with a `namespace` by setting the namespace\n property on the adapter:\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   namespace = 'api/1';\n }\n ```\n Requests for the `Person` model would now target `/api/1/people/1`.\n\n ### Host customization\n\n An adapter can target other hosts by setting the `host` property.\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   host = 'https://api.example.com';\n }\n ```\n\n ### Headers customization\n\n Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary\n headers can be set as key/value pairs on the `RESTAdapter`'s `headers`\n object and EmberData will send them along with each ajax request.\n\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   get headers() {\n     return {\n       'API_KEY': 'secret key',\n       'ANOTHER_HEADER': 'Some header value'\n     };\n   }\n }\n ```",
      "itemtype": "main"
    },
    "@warp-drive/build-config": {
      "name": "@warp-drive/build-config",
      "submodules": {},
      "elements": {},
      "classes": {
        "CanaryFeatures": 1,
        "DebugLogging": 1,
        "CurrentDeprecations": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../build-config/src/deprecation-versions.ts",
      "line": 22,
      "description": "Settings configuration for deprecations, optional features, development/testing\nsupport and debug logging is done using `setConfig` in `ember-cli-build`.\n\n```ts\n'use strict';\n\nconst EmberApp = require('ember-cli/lib/broccoli/ember-app');\n\nmodule.exports = async function (defaults) {\n  const { setConfig } = await import('@warp-drive/build-config');\n\n  const app = new EmberApp(defaults, {});\n\n  setConfig(app, __dirname, {\n    // settings here\n  });\n\n  const { Webpack } = require('@embroider/webpack');\n  return require('@embroider/compat').compatBuild(app, Webpack, {});\n};\n\n```\n\nAvailable settings include:\n\n- [Debug Logging](../classes/DebugLogging)\n- [Deprecated Code Removal](../classes/CurrentDeprecations)\n- [Canary Feature Activation](../classes/CanaryFeatures)\n\nAs well as:\n\n### polyfillUUID\n\nIf you are using the library in an environment that does not support `window.crypto.randomUUID`\nyou can enable a polyfill for it.\n\n```ts\nsetConfig(app, __dirname, {\n polyfillUUID: true\n});\n```\n\n### includeDataAdapterInProduction\n\nBy default, the integration required to support the ember inspector browser extension\nis included in production builds only when using the `ember-data` package. Otherwise\nthe default is to exclude it. This setting allows to explicitly enable/disable it in\nproduction builds.\n\n```ts\nsetConfig(app, __dirname, {\n  includeDataAdapterInProduction: true\n});\n```",
      "itemtype": "main"
    },
    "@warp-drive/core-types": {
      "name": "@warp-drive/core-types",
      "submodules": {},
      "elements": {},
      "classes": {
        "<Type> GenericField": 1,
        "<Type> LegacyAliasField": 1,
        "<Type> PolarisAliasField": 1,
        "<Type> ObjectAliasField": 1,
        "<Type> IdentityField": 1,
        "<Type> HashField": 1,
        "<Type> LocalField": 1,
        "<Type> ObjectField": 1,
        "<Type> SchemaObjectField": 1,
        "<Type> ArrayField": 1,
        "<Type> SchemaArrayField": 1,
        "<Type> DerivedField": 1,
        "<Type> ResourceField": 1,
        "<Type> CollectionField": 1,
        "<Type> LegacyAttributeField": 1,
        "<Type> LegacyBelongsToField": 1,
        "<Type> LinksModeBelongsToField": 1,
        "<Type> LegacyHasManyField": 1,
        "<Type> LinksModeHasManyField": 1,
        "<Type> LegacyModeFieldSchema": 1,
        "<Type> PolarisModeFieldSchema": 1,
        "<Type> FieldSchema": 1,
        "<Type> ObjectFieldSchema": 1,
        "<Type> PolarisResourceSchema": 1,
        "<Type> LegacyResourceSchema": 1,
        "<Type> ObjectSchema": 1,
        "@warp-drive/core-types": 1
      },
      "fors": {
        "@warp-drive/core-types": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../core-types/src/record.ts",
      "line": 6,
      "description": "This package provides core types, type-utilities, symbols\nand constants used across the WarpDrive ecosystem.",
      "itemtype": "main"
    },
    "@ember-data/experimental-preview-types": {
      "name": "@ember-data/experimental-preview-types",
      "submodules": {},
      "elements": {},
      "classes": {
        "<Interface> Cache": 1,
        "<Interface> Adapter": 1,
        "<Interface> Serializer": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts",
      "line": 25,
      "description": "Many parts of EmberData are interface-driven,\nmeaning that no specific base-class is necessary\nto implement an interopable module of your own\nutilizing only public APIs.\n\nExamples of primitives in EmberData that are interface-driven\ninclude Adapters, Serializers, Request Handlers, and the Cache.\n\nThese **Not Yet Installable** Typescript Types\nDocument key interfaces that libraries and\napplications interfacing with EmberData would need\nto conform to.",
      "itemtype": "main"
    },
    "@ember-data/store": {
      "name": "@ember-data/store",
      "submodules": {},
      "elements": {},
      "classes": {
        "StableRecordIdentifier": 1,
        "Snapshot": 1,
        "Store": 1,
        "<Interface> CachePolicy": 1,
        "IdentifierCache": 1,
        "@ember-data/store": 1,
        "RecordReference": 1,
        "CacheManager": 1,
        "NotificationManager": 1,
        "RequestStateService": 1,
        "RecordArray": 1,
        "ManyArray": 1,
        "ReactiveDocument": 1,
        "CacheCapabilitiesManager": 1,
        "<Interface> SchemaService": 1
      },
      "fors": {
        "@ember-data/store": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../store/src/-types/q/schema-service.ts",
      "line": 24,
      "description": "<p align=\"center\">\n  <img\n    class=\"project-logo\"\n    src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n    alt=\"EmberData Store\"\n    width=\"240px\"\n    title=\"EmberData Store\"\n    />\n</p>\n\nThis package provides [*Ember***Data**](https://github.com/emberjs/data/)'s `Store` class.\n\nA [Store](https://api.emberjs.com/ember-data/release/classes/Store) coordinates interaction between your application, a [Cache](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache),\nand sources of data (such as your API or a local persistence layer) accessed via a [RequestManager](https://github.com/emberjs/data/tree/main/packages/request).\n\nOptionally, a Store can be configured to hydrate the response data into rich presentation classes.\n\n## Installation\n\nIf you have installed `ember-data` then you already have this package installed.\nOtherwise you can install it using your javascript package manager of choice.\nFor instance with [pnpm](https://pnpm.io/)\n\n```\npnpm add @ember-data/store\n```\n\nAfter installing you will want to configure your first `Store`. Read more below\nfor how to create and configure stores for your application.\n\n\n## üî® Creating A Store\n\nTo use a `Store` we will need to do few things: add a [Cache](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache)\nto store data **in-memory**, add a [Handler](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache) to fetch data from a source,\nand implement `instantiateRecord` to tell the store how to display the data for individual resources.\n\n> **Note**\n> If you are using the package `ember-data` then a JSON:API cache, RequestManager, LegacyNetworkHandler,\n> and `instantiateRecord` are configured for you by default.\n\n### Configuring A Cache\n\nTo start, let's install a [JSON:API](https://jsonapi.org/) cache. If your app uses `GraphQL` or `REST` other\ncaches may better fit your data. You can author your own cache by creating one that\nconforms to the [spec](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache).\n\nThe package `@ember-data/json-api` provides a [JSON:API](https://jsonapi.org/) cache we can use.\nAfter installing it, we can configure the store to use this cache.\n\n```js\nimport Store from '@ember-data/store';\nimport Cache from '@ember-data/json-api';\n\nclass extends Store {\n  createCache(storeWrapper) {\n    return new Cache(storeWrapper);\n  }\n}\n```\n\nNow that we have a `cache` let's setup something to handle fetching\nand saving data via our API.\n\n> **Note**\n> The `ember-data` package automatically includes and configures\n> the `@ember-data/json-api` cache for you.\n\n### Handling Requests\n\nWhen *Ember***Data** needs to fetch or save data it will pass that request to your application's `RequestManager` for fulfillment. How this fulfillment occurs (in-memory, device storage, via single or multiple API requests, etc.) is then up to the registered request handlers.\n\nTo start, let's install the `RequestManager` from `@ember-data/request` and the basic `Fetch` handler from ``@ember-data/request/fetch`.\n\n> **Note**\n> If your app uses `GraphQL`, `REST` or different conventions for `JSON:API` than your cache expects, other handlers may better fit your data. You can author your own handler by creating one that conforms to the [handler interface](https://github.com/emberjs/data/tree/main/packages/request#handling-requests).\n\n```ts\nimport Store from '@ember-data/store';\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\n\nexport default class extends Store {\n  requestManager = new RequestManager()\n   .use([Fetch]);\n}\n```\n\n**Using RequestManager as a Service**\n\nAlternatively if you have configured the `RequestManager` to be a service you may re-use it.\n\n*app/services/request.js*\n```ts\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\n\nexport default class extends RequestManager {\n  constructor(createArgs) {\n    super(createArgs);\n    this.use([Fetch]);\n  }\n}\n```\n\n*app/services/store.js*\n```ts\nimport Store from '@ember-data/store';\nimport { service } from '@ember/service';\n\nexport default class extends Store {\n  @service('request') requestManager\n}\n```\n\n\n### Presenting Data from the Cache\n\nNow that we have a source and a cache for our data, we need to configure how\nthe Store delivers that data back to our application. We do this via the hook\n[instantiateRecord](https://api.emberjs.com/ember-data/release/classes/Store/methods/instantiateRecord%20(hook)?anchor=instantiateRecord%20(hook)),\nwhich allows us to transform the data for a resource before handing it to the application.\n\nA naive way to present the data would be to return it as JSON. Typically instead\nthis hook will be used to add reactivity and make each unique resource a singleton,\nensuring that if the cache updates our presented data will reflect the new state.\n\nBelow is an example of using the hooks `instantiateRecord` and a `teardownRecord`\nto provide minimal read-only reactive state for simple resources.\n\n```ts\nimport Store, { recordIdentifierFor } from '@ember-data/store';\nimport { TrackedObject } from 'tracked-built-ins';\n\nclass extends Store {\n  instantiateRecord(identifier) {\n    const { cache, notifications } = this;\n\n    // create a TrackedObject with our attributes, id and type\n    const record = new TrackedObject(Object.assign({}, cache.peek(identifier)));\n    record.type = identifier.type;\n    record.id = identifier.id;\n\n    notifications.subscribe(identifier, (_, change) => {\n      if (change === 'attributes') {\n        Object.assign(record, cache.peek(identifier));\n      }\n    });\n\n    return record;\n  }\n}\n```\n\nBecause `instantiateRecord` is opaque to the nature of the record, an implementation\ncan be anything from a fairly simple object to a robust proxy that intelligently links\ntogether associated records through relationships.\n\nThis also enables creating a record that separates `edit` flows from `create` flows\nentirely. A record class might choose to implement a `checkout`method that gives access\nto an editable instance while the primary record continues to be read-only and reflect\nonly persisted (non-mutated) state.\n\nTypically you will choose an existing record implementation such as `@ember-data/model`\nfor your application.\n\nBecause of the boundaries around instantiation and the cache, record implementations\nshould be capable of interop both with each other and with any `Cache`. Due to this,\nif needed an application can utilize multiple record implementations and multiple cache\nimplementations either to support enhanced features for only a subset of records or to\nbe able to incrementally migrate from one record/cache to another record or cache.\n\n> **Note**\n> The `ember-data` package automatically includes the `@ember-data/model`\n> package and configures it for you.",
      "itemtype": "main"
    },
    "@ember-data/debug": {
      "name": "@ember-data/debug",
      "submodules": {},
      "elements": {},
      "classes": {
        "InspectorDataAdapter": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../debug/src/data-adapter.ts",
      "line": 149,
      "description": "# Overview\n\nThis package provides the `DataAdapter` which the [Ember Inspector](https://github.com/emberjs/ember-inspector)\nuses to subscribe and retrieve information for the `data` tab in the inspector.\n\nThis package adds roughly .6 KB when minified and compressed to your application in production; however,\nyou can opt out of shipping this addon in production via options in `ember-cli-build.js`\n\n```js\nlet app = new EmberApp(defaults, {\n  emberData: {\n    includeDataAdapterInProduction: false\n  }\n});\n```\n\nWhen using `ember-data` as a dependency of your app, the default is to ship the inspector support to production.\n\nWhen not using `ember-data` as a dependency but instead using EmberData via declaring specific `@ember-data/<package>`\ndependencies the default is to not ship to production.",
      "itemtype": "main"
    },
    "@warp-drive/ember": {
      "name": "@warp-drive/ember",
      "submodules": {},
      "elements": {},
      "classes": {
        "<Throw />": 1,
        "<Await />": 1,
        "PromiseState": 1,
        "@warp-drive/ember": 1,
        "RequestLoadingState": 1,
        "RequestState": 1,
        "<Request />": 1
      },
      "fors": {
        "@warp-drive/ember": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../graph/src/-private/-edge-definition.ts",
      "line": 44,
      "description": "<h3 align=\"center\">‚öõÔ∏è Data utilities for using <em style=\"color: lightgreen\">Warp</em><strong style=\"color: magenta\">Drive</strong> with üêπ <em style=\"color: orange\">Ember</em><em style=\"color: lightblue\">.js</em></h3>\n\n## Installation\n\n```cli\npnpm install @warp-drive/ember\n```\n\n## About\n\nThis library provides reactive utilities for working with promises\nand requests, building over these primitives to provide functions\nand components that enable you to build robust performant apps with\nelegant control flow.",
      "itemtype": "main"
    },
    "@ember-data/graph": {
      "name": "@ember-data/graph",
      "submodules": {},
      "elements": {},
      "classes": {},
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../graph/src/-private.ts",
      "line": 1,
      "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n   />\n</p>\n\n<p align=\"center\">Provides a performance tuned normalized graph for intelligently managing relationships between resources based on identity</p>\n\nWhile this Graph is abstract, it currently is a private implementation required as a peer-dependency by the [JSON:API Cache Implementation](https://github.com/emberjs/data/tree/main/packages/json-api).\n\nWe intend to make this Graph public API after some additional iteration during the 5.x timeframe, until then all APIs should be considered experimental and unstable, not fit for direct application or 3rd party library usage.\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/graph\n```",
      "itemtype": "main"
    },
    "@ember-data/json-api/request": {
      "name": "@ember-data/json-api/request",
      "submodules": {},
      "elements": {},
      "classes": {
        "@ember-data/json-api/request": 1
      },
      "fors": {
        "@ember-data/json-api/request": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../json-api/src/request.ts",
      "line": 1,
      "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n />\n</p>\n\nThis package provides utilities for working with [JSON:API](https://json-api.org) APIs with [*Ember***Data**](https://github.com/emberjs/data/).\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/json-api\n```\n\n## Usage\n\nRequest builders are functions that produce [Fetch Options](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\nThey take a few contextual inputs about the request you want to make, abstracting away the gnarlier details.\n\nFor instance, to fetch a resource from your API\n\n```ts\nimport { findRecord } from '@ember-data/json-api/request';\n\nconst options = findRecord('ember-developer', '1', { include: ['pets', 'friends'] });\n\n/*\n {\n   url: 'https://api.example.com/v1/ember-developers/1?include=friends,pets',\n   method: 'GET',\n   headers: <Headers>,\n     // => 'Accept': 'application/vnd.api+json'\n     // => 'Content-Type': 'application/vnd.api+json'\n   op: 'findRecord';\n   records: [{ type: 'ember-developer', id: '1' }]\n }\n\\\n```\n\nRequest builder output may be used with either `requestManager.request` or `store.request`.\n\nURLs are stable. The same query will produce the same URL every time, even if the order of keys in\nthe query or values in an array changes.\n\nURLs follow the most common JSON:API format (dasherized pluralized resource types).",
      "itemtype": "main"
    },
    "@ember-data/json-api": {
      "name": "@ember-data/json-api",
      "submodules": {},
      "elements": {},
      "classes": {
        "Cache": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../json-api/src/-private/cache.ts",
      "line": 125,
      "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n   />\n</p>\n\nThis package provides an in-memory [JSON:API](https://jsonapi.org/) document and resource [*Ember***Data** Cache](https://github.com/emberjs/data/blob/main/ember-data-types/cache/cache.ts) implementation.\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/json-api\n```\n\n## üöÄ Setup\n\n> **Note**\n> When using [ember-data](https://github.com/emberjs/data/blob/main/packages/-ember-data) the below\n> configuration is handled for you automatically.\n\n```ts\nimport Store from '@ember-data/store';\nimport Cache from '@ember-data/json-api';\n\nexport default class extends Store {\n createCache(wrapper) {\n   return new Cache(wrapper);\n }\n}\n```\n\n\n## Usage\n\nUsually you will directly interact with the cache only if implementing a presentation class. Below we\ngive an example of a read-only record (mutations never written back to the cache). More typically cache\ninteractions are something that the `Store` coordinates as part of the `request/response` lifecycle.\n\n```ts\nimport Store, { recordIdentifierFor } from '@ember-data/store';\nimport Cache from '@ember-data/json-api';\nimport { TrackedObject } from 'tracked-built-ins';\n\nclass extends Store {\n createCache(wrapper) {\n   return new Cache(wrapper);\n }\n\n instantiateRecord(identifier) {\n   const { cache, notifications } = this;\n   const { type, id } = identifier;\n\n   // create a TrackedObject with our attributes, id and type\n   const attrs = cache.peek(identifier).attributes;\n   const data = Object.assign({}, attrs, { type, id });\n   const record = new TrackedObject(data);\n\n   // update the TrackedObject whenever attributes change\n   const token = notifications.subscribe(identifier, (_, change) => {\n     if (change === 'attributes') {\n       Object.assign(record, cache.peek(identifier).attributes);\n     }\n   });\n\n   // setup the ability to teardown the subscription when the\n   // record is no longer needed\n   record.destroy = () => {\n     this.notifications.unsubscribe(token);\n   };\n\n   return record;\n }\n\n teardownRecord(record: FakeRecord) {\n   record.destroy();\n }\n}\n```\n\nFor the full list of APIs see the docs for [Cache Interface](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache)",
      "itemtype": "main"
    },
    "@ember-data/legacy-compat/builders": {
      "name": "@ember-data/legacy-compat/builders",
      "submodules": {},
      "elements": {},
      "classes": {
        "@ember-data/legacy-compat/builders": 1
      },
      "fors": {
        "@ember-data/legacy-compat/builders": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../legacy-compat/src/builders.ts",
      "line": 1,
      "description": "Builders for migrating from `store` methods to `store.request`.\n\nThese builders enable you to migrate your codebase to using the correct syntax for `store.request` while temporarily preserving legacy behaviors.\nThis is useful for quickly upgrading an entire app to a unified syntax while a longer incremental migration is made to shift off of adapters and serializers.\nTo that end, these builders are deprecated and will be removed in a future version of Ember Data.",
      "itemtype": "main"
    },
    "@ember-data/legacy-compat": {
      "name": "@ember-data/legacy-compat",
      "submodules": {},
      "elements": {},
      "classes": {
        "SnapshotRecordArray": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 12,
      "description": "Utilities - often temporary - for maintaining backwards compatibility with\nolder parts of EmberData.",
      "itemtype": "main"
    },
    "@ember-data/legacy-compat/utils": {
      "name": "@ember-data/legacy-compat/utils",
      "submodules": {},
      "elements": {},
      "classes": {
        "@ember-data/legacy-compat/utils": 1
      },
      "fors": {
        "@ember-data/legacy-compat/utils": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../legacy-compat/src/utils.ts",
      "line": 1,
      "description": "Utilities for helping to migrate to stricter\nand more consistent use of IDs and types.",
      "itemtype": "main"
    },
    "@ember-data/model": {
      "name": "@ember-data/model",
      "submodules": {},
      "elements": {},
      "classes": {
        "BelongsToReference": 1,
        "HasManyReference": 1,
        "@ember-data/model": 1,
        "Errors": 1,
        "Model": 1,
        "PromiseBelongsTo": 1,
        "PromiseManyArray": 1
      },
      "fors": {
        "@ember-data/model": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../model/src/-private/promise-many-array.ts",
      "line": 18,
      "description": "This package provides a Presentation Model for resource data in an EmberData Cache.\n\nModels are defined as classes extending from `import Model from '@ember-data/model';` and the\nattributes and relationships on these classes are parsed at runtime to supply static \"schema\"\nto EmberData's SchemaService.\n\nResource data for individual resources fetched from your API is presented to the UI via instances\nof the `Model`s you define. An instantiated `Model` is referred to as a `record`.\n\n When we refer to the `ModelClass` as opposed to a `Model` or `Record` we are referring\n specifically to the class definition and the static schema methods present on it.\n\n When we refer to a `record` we refer to a specific class instance presenting\n the resource data for a given `type` and `id`.\n\n ### Defining a Model\n\n ```app/models/person.js\n import Model, { attr, belongsTo, hasMany } from '@ember-data/model';\n\n export default class PersonModel extends Model {\n   @attr name;\n\n   @belongsTo('pet', { inverse: 'owners', async: false }) dog;\n\n   @hasMany('person', { inverse: 'friends', async: true }) friends;\n }\n ```\n\n ### modelName convention\n\n By convention, the name of a given model (its `type`) matches the name\n of the file in the `app/models` folder and should be lowercase, singular\n and dasherized.",
      "itemtype": "main"
    },
    "@ember-data/request-utils": {
      "name": "@ember-data/request-utils",
      "submodules": {},
      "elements": {},
      "classes": {
        "@ember-data/request-utils": 1,
        "CachePolicy": 1
      },
      "fors": {
        "@ember-data/request-utils": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../request-utils/src/index.ts",
      "line": 683,
      "description": "Simple utility function to assist in url building,\nquery params, and other common request operations.\n\nThese primitives may be used directly or composed\nby request builders to provide a consistent interface\nfor building requests.\n\nFor instance:\n\n```ts\nimport { buildBaseURL, buildQueryParams } from '@ember-data/request-utils';\n\nconst baseURL = buildBaseURL({\n  host: 'https://api.example.com',\n  namespace: 'api/v1',\n  resourcePath: 'emberDevelopers',\n  op: 'query',\n  identifier: { type: 'ember-developer' }\n});\nconst url = `${baseURL}?${buildQueryParams({ name: 'Chris', include:['pets'] })}`;\n// => 'https://api.example.com/api/v1/emberDevelopers?include=pets&name=Chris'\n```\n\nThis is useful, but not as useful as the REST request builder for query which is sugar\nover this (and more!):\n\n```ts\nimport { query } from '@ember-data/rest/request';\n\nconst options = query('ember-developer', { name: 'Chris', include:['pets'] });\n// => { url: 'https://api.example.com/api/v1/emberDevelopers?include=pets&name=Chris' }\n// Note: options will also include other request options like headers, method, etc.\n```",
      "itemtype": "main"
    },
    "@ember-data/request": {
      "name": "@ember-data/request",
      "submodules": {},
      "elements": {},
      "classes": {
        "RequestManager": 1,
        "Future": 1,
        "<Interface> Handler": 1,
        "<Interface> CacheHandler": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../request/src/-private/types.ts",
      "line": 232,
      "description": "<p align=\"center\">\n  <img\n    class=\"project-logo\"\n    src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n    alt=\"EmberData RequestManager\"\n    width=\"240px\"\n    title=\"EmberData RequestManager\"\n    />\n</p>\n\n<p align=\"center\">‚ö°Ô∏è a simple abstraction over fetch to enable easy management of request/response flows</p>\n\nThis package provides [*Ember*‚Äç**Data**](https://github.com/emberjs/data/)'s `RequestManager`, a framework agnostic library that can be integrated with any Javascript application to make [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) happen.\n\n- [Installation](#installation)\n- [Basic Usage](#üöÄ-basic-usage)\n- [Architecture](#ü™ú-architecture)\n- [Usage](#usage)\n  - [Making Requests](#making-requests)\n    - [Using The Response](#using-the-response)\n  - [Request Handlers](#handling-requests)\n    - [Handling Errors](#handling-errors)\n    - [Handling Abort](#handling-abort)\n    - [Stream Currying](#stream-currying)\n    - [Automatic Currying](#automatic-currying-of-stream-and-response)\n  - [Using as a Service](#using-as-a-service)\n    - [Using with `@ember-data/store`](#using-with-ember-datastore)\n    - [Using with `ember-data`](#using-with-ember-data)\n\n---\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/request\n```\n\n---\n\n## üöÄ Basic Usage\n\nA `RequestManager` provides a request/response flow in which configured handlers are successively given the opportunity to handle, modify, or pass-along a request.\n\nThe RequestManager on its own does not know how to fulfill requests. For this we must register at least one handler. A basic `Fetch` handler is provided that will take the request options provided and execute `fetch`.\n\n```ts\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport { apiUrl } from './config';\n\n// ... create manager and add our Fetch handler\nconst manager = new RequestManager()\n  .use([Fetch]);\n\n// ... execute a request\nconst response = await manager.request({\n  url: `${apiUrl}/users`\n});\n```\n\n---\n\n## ü™ú Architecture\n\nA `RequestManager` receives a request and manages fulfillment via configured handlers. It may be used standalone from the rest of *Ember*‚Äç**Data** and is not specific to any library or framework.\n\nEach handler may choose to fulfill the request using some source of data or to pass the request along to other handlers.\n\nThe same or a separate instance of a `RequestManager` may also be used to fulfill requests issued by [*Ember*‚Äç**Data**{Store}](https://github.com/emberjs/data/tree/main/packages/store)\n\nWhen the same instance is used by both this allows for simple coordination throughout the application. Requests issued by the Store will use the in-memory cache\nand return hydrated responses, requests issued directly to the RequestManager\nwill skip the in-memory cache and return raw responses.\n\n---\n\n## Usage\n\n```ts\nconst userList = await manager.request({\n  url: `/api/v1/users.list`\n});\n\nconst users = userList.content;\n```\n\n---\n\n### Making Requests\n\n`RequestManager` has a single asyncronous method as it's API: `request`\n\n```ts\nclass RequestManager {\n  request<T>(req: RequestInfo): Future<T>;\n}\n```\n\n`manager.request(<RequestInfo>)` accepts an object containing the information\nnecessary for the request to be handled successfully.\n\nThese options extend the [options](https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters) provided to `fetch`, and can accept a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request). All properties accepted by Request options and fetch options are valid.\n\n```ts\ninterface RequestInfo extends FetchOptions {\n  op?: string;\n  store?: Store;\nurl: string;\n   // data that a handler should convert into\n   // the query (GET) or body (POST)\n  data?: Record<string, unknown>;\n// options specifically intended for handlers\n  // to utilize to process the request\n  options?: Record<string, unknown>;\n}\n```\n\n> **note**\n> providing a `signal` is unnecessary as an `AbortController` is automatically provided if none is present.\n\n---\n\n#### Using the Response\n\n`manager.request` returns a `Future`, which allows access to limited information about the request while it is still pending and fulfills with the final state when the request completes and the response has been read.\n\n```ts\nconst usersFuture = manager.request({\n  url: `/api/v1/users.list`\n});\n```\n\nA `Future` is cancellable via `abort`.\n\n```ts\nusersFuture.abort();\n```\n\nHandlers may *optionally* expose a ReadableStream to the `Future` for streaming data; however, when doing so the handler should not resolve until it has fully read the response stream itself.\n\n```ts\ninterface Future<T> extends Promise<StructuredDocument<T>> {\n  abort(): void;\nasync getStream(): ReadableStream | null;\n}\n```\n\nA Future resolves or rejects with a `StructuredDocument`.\n\n```ts\ninterface StructuredDocument<T> {\n  request: RequestInfo;\n  response: ResponseInfo | null;\n  content?: T;\n  error?: Error;\n}\n```\n\nThe `RequestInfo` specified by `document.request` is the same as originally provided to `manager.request`. If any handler fulfilled this request using different request info it is not represented here. This contract helps to ensure that `retry` and `caching` are possible since the original arguments are correctly preserved. This also allows handlers to \"fork\" the request or fulfill from multiple sources without the details of fulfillment muddying the original request.\n\nThe `ResponseInfo` is a serializable fulfilled subset of a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) if set via `setResponse`. If no response was ever set this will be `null`.\n\n```ts\ninterface ResponseInfo {\n  headers?: Record<string, string>;\n  ok?: boolean;\n  redirected?: boolean;\n  status?: HTTPStatusCode;\n  statusText?: string;\n  type?: 'basic' | 'cors';\n  url?: string;\n}\n```\n\n---\n\n### Request Handlers\n\nRequests are fulfilled by handlers. A handler receives the request context\nas well as a `next` function with which to pass along a request to the next\nhandler if it so chooses.\n\nA handler may be any object with a `request` method. This allows both stateful and non-stateful\nhandlers to be utilized.\n\nIf a handler calls `next`, it receives a `Future` which resolves to a `StructuredDocument`\nthat it can then compose how it sees fit with its own response.\n\n```ts\n\ntype NextFn<P> = (req: RequestInfo) => Future<P>;\n\ninterface Handler {\n  async request<T>(context: RequestContext, next: NextFn<P>): T;\n}\n```\n\n`RequestContext` contains a readonly version of the RequestInfo as well as a few methods for building up the `StructuredDocument` and `Future` that will be part of the response.\n\n```ts\ninterface RequestContext<T> {\n  readonly request: RequestInfo;\nsetStream(stream: ReadableStream | Promise<ReadableStream>): void;\n  setResponse(response: Response | ResponseInfo): void;\n}\n```\n\nA basic `fetch` handler with support for streaming content updates while\nthe download is still underway might look like the following, where we use\n[`response.clone()`](https://developer.mozilla.org/en-US/docs/Web/API/Response/clone) to `tee` the `ReadableStream` into two streams.\n\nA more efficient handler might read from the response stream, building up the\nresponse content before passing along the chunk downstream.\n\n```ts\nconst FetchHandler = {\n  async request(context) {\n    const response = await fetch(context.request);\n    context.setResponse(reponse);\n    context.setStream(response.clone().body);\n  return response.json();\n  }\n}\n```\n\nRequest handlers are registered by configuring the manager via `use`\n\n```ts\nmanager.use([Handler1, Handler2])\n```\n\nHandlers will be invoked in the order they are registered (\"fifo\", first-in first-out), and may only be registered up until the first request is made. It is recommended but not required to register all handlers at one time in order to ensure explicitly visible handler ordering.\n\n---\n\n#### Handling Errors\n\nEach handler in the chain can catch errors from upstream and choose to\neither handle the error, re-throw the error, or throw a new error.\n\n```ts\nconst MAX_RETRIES = 5;\n\nconst Handler = {\n  async request(context, next) {\n    let attempts = 0;\n  while (attempts < MAX_RETRIES) {\n      attempts++;\n      try {\n        const response = await next(context.request);\n        return response;\n      } catch (e) {\n        if (isTimeoutError(e) && attempts < MAX_RETRIES) {\n          // retry request\n          continue;\n        }\n        // rethrow if it is not a timeout error\n        throw e;\n      }\n    }\n  }\n}\n```\n\n---\n\n#### Handling Abort\n\nAborting a request will reject the current handler in the chain. However,\nevery handler can potentially catch this error. If your handler needs to\nseparate AbortError from other Error types, it is recommended to check\n`context.request.signal.aborted` (or if a custom controller was supplied `controller.signal.aborted`).\n\nIn this manner it is possible for a request to recover from an abort and\nstill proceed; however, as a best practice this should be used for necessary\ncleanup only and the original AbortError rethrown if the abort signal comes\nfrom the root controller.\n\n*AbortControllers are Always Present and Always Entangled**\n\nIf the initial request does not supply an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController), one will be generated.\n\nThe [signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for this controller is automatically added to the request passed into the first handler.\n\nEach handler has the option to supply a new controller to the request when calling `next`. If a new controller is provided it will be automatically\nentangled with the root controller. If the root controller aborts, so will\nany entangled controllers.\n\nIf an entangled controller aborts, the root controller will not abort. This\nallows for advanced request-flow scenarios to abort subsections of the request tree without aborting the entire request.\n\n---\n\n#### Stream Currying\n\n`RequestManager.request` and `next` differ from `fetch` in one **crucial detail** in that the outer Promise resolves only once the response stream has been processed.\n\nFor context, it helps to understand a few of the use-cases that RequestManager\nis intended to allow.\n\n- to manage and return streaming content (such as video files)\n- to fulfill a request from multiple sources or by splitting one request into multiple requests\n  - for instance one API call for a user and another for the user's friends\n  - or e.g. fulfilling part of the request from one source (one API, in-memory, localStorage, IndexedDB\n   etc.) and the rest from another source (a different API, a WebWorker, etc.)\n- to coalesce multiple requests\n- to decorate a request with additional info\n  - e.g. an Auth handler that ensures the correct tokens or headers or cookies are attached.\n\n\n`await fetch(<req>)` resolves at the moment headers are received. This allows for the body of the request to be processed as a stream by application\ncode *while chunks are still being received by the browser*.\n\nWhen an app chooses to `await response.json()` what occurs is the browser reads the stream to completion and then returns the result. Additionally, this stream may only be read **once**.\n\nThe `RequestManager` preserves this ability to subscribe to and utilize the stream by either the application or the handler ‚Äì¬†thereby delivering the full power and flexibility of native APIs ‚Äì without restricting developers in ways that lead to complicated workarounds.\n\nEach handler may call `setStream` only once, but may do so *at any time* until the promise that the handler returns has resolved. The associated promise returned by calling `future.getStream` will resolve with the stream set by `setStream` if that method is called, or `null` if that method\nhas not been called by the time that the handler's request method has resolved.\n\nHandlers that do not create a stream of their own, but which call `next`, should defensively pipe the stream forward. While this is not required (see automatic currying below) it is better to do so in most cases as otherwise the stream may not become available to downstream handlers or the application until the upstream handler has fully read it.\n\n```ts\ncontext.setStream(future.getStream());\n```\n\nHandlers that either call `next` multiple times or otherwise have reason to create multiple  fetch requests should either choose to return no stream, meaningfully combine the streams, or select a single prioritized stream.\n\nOf course, any handler may choose to read and handle the stream, and return either no stream or a different stream in the process.\n\n---\n\n#### Automatic Currying of Stream and Response\n\nIn order to simplify the common case for handlers which decorate a request, if `next` is called only a single time and `setResponse` was never called by the handler, the response set by the next handler in the chain will be applied to that handler's outcome. For instance, this makes the following pattern possible `return (await next(<req>)).content;`.\n\nSimilarly, if `next` is called only a single time and neither `setStream` nor `getStream` was called, we automatically curry the stream from the future returned by `next` onto the future returned by the handler.\n\nFinally, if the return value of a handler is a `Future`, we curry `content` and `errors` as well, thus enabling the simplest form `return next(<req>)`.\n\nIn the case of the `Future` being returned, `Stream` proxying is automatic and immediate and does not wait for the `Future` to resolve.\n\n---\n\n### Using as a Service\n\nMost applications will desire to have a single `RequestManager` instance, which can be achieved using module-state patterns for singletons, or for [Ember](https://emberjs.com) applications by exporting the manager as a [service](https://guides.emberjs.com/release/services/).\n\nservices/request.ts*\n```ts\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport Auth from 'ember-simple-auth/ember-data-handler';\n\nexport default class extends RequestManager {\n  constructor(createArgs) {\n    super(createArgs);\n    this.use([Auth, Fetch]);\n  }\n}\n```\n\n---\n\n#### Using with `@ember-data/store`\n\nTo have a request service unique to a Store:\n\n```ts\nimport Store, { CacheHandler } from '@ember-data/store';\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\n\nclass extends Store {\n  requestManager = new RequestManager()\n    .use([Fetch])\n    .useCache(CacheHandler);\n}\n```\n\n---\n\n#### Using with `ember-data`\n\nIf using the package [ember-data](https://github.com/emberjs/data/tree/main/packages/-ember-data),\nthe following configuration will automatically be done in order to preserve the\nlegacy [Adapter](https://github.com/emberjs/data/tree/main/packages/adapter) and\n[Serializer](https://github.com/emberjs/data/tree/main/packages/serializer) behavior.\nAdditional handlers or a service injection like the above would need to be done by the\nconsuming application in order to make broader use of `RequestManager`.\n\n```ts\nimport Store from 'ember-data/store';\nimport { CacheHandler } from '@ember-data/store';\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport { LegacyNetworkHandler } from '@ember-data/legacy-compat';\n\nexport default class extends Store {\n  requestManager = new RequestManager()\n    .use([LegacyNetworkHandler, Fetch])\n    .useCache(CacheHandler);\n}\n```\n\nTo provide a different configuration, import and extend `ember-data/store`. The\ndefault configuration will be ignored if the `requestManager` property is set,\nthough the store will still register the CacheHandler.\n\nFor usage of the store's `requestManager` via `store.request(<req>)` see the\n[Store](https://api.emberjs.com/ember-data/release/modules/@ember-data%2Fstore) documentation.",
      "itemtype": "main"
    },
    "@ember-data/request/fetch": {
      "name": "@ember-data/request/fetch",
      "submodules": {},
      "elements": {},
      "classes": {
        "Fetch": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../request/src/fetch.ts",
      "line": 108,
      "description": "A basic Fetch Handler which converts a request into a\n`fetch` call presuming the response to be `json`.\n\n```ts\nimport Fetch from '@ember-data/request/fetch';\n\nmanager.use([Fetch]);\n```",
      "itemtype": "main"
    },
    "@ember-data/rest/request": {
      "name": "@ember-data/rest/request",
      "submodules": {},
      "elements": {},
      "classes": {
        "@ember-data/rest/request": 1
      },
      "fors": {
        "@ember-data/rest/request": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../rest/src/request.ts",
      "line": 1,
      "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n />\n</p>\n\nThis package provides utilities for working with **REST**ful APIs with [*Ember***Data**](https://github.com/emberjs/data/).\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/json-api\n```\n\n## Usage\n\nRequest builders are functions that produce [Fetch Options](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\nThey take a few contextual inputs about the request you want to make, abstracting away the gnarlier details.\n\nFor instance, to fetch a resource from your API\n\n```ts\nimport { findRecord } from '@ember-data/rest/request';\n\nconst options = findRecord('ember-developer', '1', { include: ['pets', 'friends'] });\n\n/*\n => {\n   url: 'https://api.example.com/v1/emberDevelopers/1?include=friends,pets',\n   method: 'GET',\n   headers: <Headers>, // 'Content-Type': 'application/json;charset=utf-8'\n   op: 'findRecord';\n   records: [{ type: 'ember-developer', id: '1' }]\n }\n/\n```\n\nRequest builder output is ready to go for use with [store.request](https://api.emberjs.com/ember-data/release/classes/Store/methods/request?anchor=request),\n[manager.request](https://api.emberjs.com/ember-data/release/classes/RequestManager/methods/request?anchor=request) and most conventional REST APIs.\n\nResource types are pluralized and camelized for the url.\n\nURLs are stable. The same query will produce the same URL every time, even if the order of keys in\nthe query or values in an array changes.\n\nURLs follow the most common REST format (camelCase pluralized resource types).\n\n### Available Builders\n\n- [createRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/createRecord)\n- [deleteRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/deleteRecord)\n- [findRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/findRecord)\n- [query](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/query)\n- [updateRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/updateRecord)",
      "itemtype": "main"
    },
    "@warp-drive/schema-record": {
      "name": "@warp-drive/schema-record",
      "submodules": {},
      "elements": {},
      "classes": {
        "@warp-drive/schema-record": 1,
        "SchemaService": 1
      },
      "fors": {
        "@warp-drive/schema-record": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../schema-record/src/-private/schema.ts",
      "line": 195,
      "description": "<h3 align=\"center\">Your Data, Managed.</h3>\n<p align=\"center\">üå≤ Get back to Nature üêøÔ∏è Or shipping üíö</p>\n\nSchemaRecord is a reactive object that transforms raw data from an [associated cache](../classes/<Interface>%20Cache)\ninto reactive data backed by Signals. The shape of the object and the transformation of raw cache data into its\nreactive form is controlled by a resource schema. Resource schemas are simple JSON, allowing them to be defined\nand delivered from anywhere.\n\nThe capabilities that SchemaRecord brings to [*Warp***Drive**](https://github.com/emberjs/data/)\nwill simplify even the most complex parts of your app's state management.\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance\nwith [pnpm](https://pnpm.io/)\n\n```cli\npnpm add @warp-drive/schema-record\n```\n\n\n---\n\n\n## Getting Started\n\nIf this package is how you are first learning about WarpDrive/EmberData, we\nrecommend starting with learning about [Requests](../modules/@ember-data%2Frequest)\nand the [Store](../modules/@ember-data%2Fstore).\n\n\n---\n\n\n## üöÄ Setup\n\nSchemaRecord integrates with WarpDrive via the Store's resource lifecycle hooks.\nWhen WarpDrive needs to create a new record instance to give reactive access to\na resource in the cache, it calls `instantiateRecord`. When it no longer needs\nthat instance, it will call `teardownRecord`.\n\n```diff\nimport Store from '@ember-data/store';\n+import { instantiateRecord, teardownRecord, registerDerivations, SchemaService } from '@warp-drive/schema-record';\n\nclass AppStore extends Store {\n\n+  createSchemaService() {\n+    const schema = new SchemaService();\n+    registerDerivations(schema);\n+    return schema;\n+  }\n\n+  instantiateRecord(identifier, createArgs) {\n+    return instantiateRecord(this, identifier, createArgs);\n+  }\n\n+  teardownRecord(record) {\n+    return teardownRecord(record);\n+  }\n}\n```\n\nAny Store API that returns a record instance will use the `instantiateRecord`\nhook configured above to instantiate a SchemaRecord once this is in place.\nAfter that, its up to you what SchemaRecord can do.\n\n\n---\n\n\n## Start Using\n\n### Modes\n\nSchemaRecord has two modes: `legacy` and `polaris`.\n\n**LegacyMode** can be used to emulate the behaviors and capabilities of EmberData's `Model` class,\nand because there is little distinction between Model and SchemaRecord in LegacyMode we refer\nto both of these approaches as LegacyMode. This mode is the default experience in V5.\n\nIn LegacyMode:\n\n- records are mutable\n- local changes immediately reflect app wide\n- records have all the APIs of Model (references, state props, currentState, methods etc)\n- the continued use of `@ember-data/model` and `@ember-data/legacy-compat` packages is required (though most imports from them can be removed)\n- `async: true` relationships are supported (but not recommended outside of [LinksMode](https://github.com/emberjs/data/blob/main/guides/relationships/features/links-mode.md))\n\n---\n\n**PolarisMode** is an upcoming suite of features that will become the default experience in V6.\n\nIn PolarisMode:\n\n- records are immutable, unless creating a new resource or explicitly checking out a record for editing\n- local changes are isolated until committed, displaying only via the editable version of the record\n- records have a more limited API, focused on only what is in their schema.\n- some common operations may have more friction to perform because intended utilities are not yet available\n- `async: true` relationships are not supported (see [LinksMode](https://github.com/emberjs/data/blob/main/guides/relationships/features/links-mode.md))\n- `@ember-data/model` and `@ember-data/legacy-compat` packages are not required\n\nThese modes are interopable. The reactive object (record) for a resource in PolarisMode can relate to\na record in LegacyMode and vice-versa. This interopability is true whether the record in LegacyMode is\na SchemaRecord or a Model.\n\n---\n\n### About\n\nSchemaRecord is a reactive object that transforms raw data from an associated\ncache into reactive data backed by Signals.\n\nThe shape of the object and the transformation of raw cache data into its\nreactive form is controlled by a resource schema.\n\nFor instance, lets say your API is a [{JSON:API}](https://jsonapi.org) and your store is using\nthe Cache provided by [@ember-data/json-api](../modules/@ember-data%2Fjson-api), and a request\nreturns the following raw data:\n\n```ts\n{\n  data: {\n    type: 'user',\n    id: '1',\n    attributes: { firstName: 'Chris', lastName: 'Thoburn' },\n    relationships: { pets: { data: [{ type: 'dog', id: '1' }] }}\n  },\n  included: [\n    {\n      type: 'dog',\n      id: '1',\n      attributes: { name: 'Rey' },\n      relationships: { owner: { data: { type: 'user', id: '1' }}}\n    }\n  ]\n}\n```\n\nWe could describe the `'user'` and `'dog'` resources in the above payload\nwith the following schemas:\n\n```ts\nstore.schema.registerResources([\n  {\n    type: 'user',\n    identity: { type: '@id', name: 'id' },\n    fields: [\n      {\n        type: '@identity',\n        name: '$type',\n        kind: 'derived',\n        options: { key: 'type' },\n      },\n      { kind: 'field', name: 'firstName' },\n      { kind: 'field', name: 'lastName' },\n      {\n        kind: 'derived',\n        name: 'name',\n        type: 'concat',\n        options: { fields: ['firstName', 'lastName'], separator: ' ' }\n      },\n      {\n        kind: 'hasMany',\n        name: 'pets',\n        type: 'pet',\n        options: {\n          async: false,\n          inverse: 'owner',\n          polymorphic: true,\n          linksMode: true,\n        }\n      }\n    ]\n  },\n  {\n    type: 'dog',\n    identity: { type: '@id', name: 'id' },\n    fields: [\n      {\n        type: '@identity',\n        name: '$type',\n        kind: 'derived',\n        options: { key: 'type' },\n      },\n      { kind: 'field', name: 'name' },\n      {\n        kind: 'belongsTo',\n        name: 'owner',\n        type: 'user',\n        options: {\n          async: false,\n          inverse: 'pets',\n          as: 'pet',\n          linksMode: true,\n        }\n      }\n    ]\n  }\n]);\n```\n\nWith these schemas in place, the reactive objects that the store would\nprovide us whenever we encountered a `'user'` or a `'dog'` would be:\n\n```ts\n\ninterface Pet {\n  readonly id: string;\n  readonly owner: User;\n}\n\ninterface Dog extends Pet {\n  readonly $type: 'dog';\n  readonly name: string;\n}\n\ninterface EditableUser {\n  readonly $type: 'user';\n  readonly id: string;\n  firstName: string;\n  lastName: string;\n  readonly name: string;\n  pets: Array<Dog | Pet>;\n}\n\ninterface User {\n  readonly $type: 'user';\n  readonly id: string;\n  readonly firstName: string;\n  readonly lastName: string;\n  readonly name: string;\n  readonly pets: Readonly<Array<Dog | Pet>>;\n  [Checkout]: Promise<EditableUser>\n}>\n```\n\nNote how based on the schema the reactive object we receive is able to produce\n`name` on user (despite no name field being in the cache), provide `$type`\npulled from the identity of the resource, and flatten the individual attributes\nand relationships onto the record for easier use.\n\nNotice also how we typed this object with `readonly`. This is because while\nSchemaRecord instances are ***deeply reactive***, they are also ***immutable***.\n\nWe can mutate a SchemaRecord only be explicitly asking permission to do so, and\nin the process gaining access to an editable copy. The immutable version will\nnot show any in-process edits made to this editable copy.\n\n```ts\nimport { Checkout } from '@warp-drive/schema-record';\n\nconst editable = await user[Checkout]();\n```\n\n---\n\n### Utilities\n\nSchemaRecord provides a schema builder that simplifies setting up a couple of\nconventional fields like identity and `$type`. We can rewrite the schema\ndefinition above using this utility like so:\n\n```ts\nimport { withDefaults } from '@warp-drive/schema-record';\n\nstore.schema.registerResources([\n  withDefaults({\n    type: 'user',\n    fields: [\n      { kind: 'field', name: 'firstName' },\n      { kind: 'field', name: 'lastName' },\n      {\n        kind: 'derived',\n        name: 'name',\n        type: 'concat',\n        options: { fields: ['firstName', 'lastName'], separator: ' ' }\n      },\n      {\n        kind: 'hasMany',\n        name: 'pets',\n        type: 'pet',\n        options: {\n          async: false,\n          inverse: 'owner',\n          polymorphic: true,\n          linksMode: true,\n        }\n      }\n    ]\n  }),\n  withDefaults({\n    type: 'dog',\n    fields: [\n      { kind: 'field', name: 'name' },\n      {\n        kind: 'belongsTo',\n        name: 'owner',\n        type: 'user',\n        options: {\n          async: false,\n          inverse: 'pets',\n          as: 'pet',\n          linksMode: true,\n        }\n      }\n    ]\n  })\n]);\n```\n\nAdditionally, `@warp-drive/core-types` provides several utilities for type-checking and narrowing schemas.\n\n- (type) [PolarisResourceSchema](../classes/<Type>%20PolarisResourceSchema)\n- (type) [LegacyResourceSchema](../classes/<Type>%20LegacyResourceSchema)\n- (type) [ObjectSchema](../classes/<Type>%20ObjectSchema)\n- [resourceSchema](../functions/@warp-drive%2Fcore-types/resourceSchema)\n- [objectSchema](../functions/@warp-drive%2Fcore-types/objectSchema)\n- [isResourceSchema](../functions/@warp-drive%2Fcore-types/isResourceSchema)\n- [isLegacyResourceSchema](../functions/@warp-drive%2Fcore-types/isLegacyResourceSchema)\n\n---\n\n### Field Schemas\n\nLegacyMode\n\n- (type) [LegacyModeFieldSchema](../classes/<Type>%20LegacyModeFieldSchema)\n\nPolarisMode\n\n- (type) [PolarisModeFieldSchema](../classes/<Type>%20PolarisModeFieldSchema)",
      "itemtype": "main"
    },
    "@ember-data/serializer": {
      "name": "@ember-data/serializer",
      "submodules": {},
      "elements": {},
      "classes": {
        "BooleanTransform": 1,
        "DateTransform": 1,
        "NumberTransform": 1,
        "StringTransform": 1,
        "Transform": 1,
        "Serializer": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../serializer/src/index.ts",
      "line": 119,
      "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new serializer, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nIn order to properly manage and present your data, EmberData\nneeds to understand the structure of data it receives.\n\n`Serializers` convert data between the server's API format and\nthe format EmberData understands.\n\nData received from an API response is **normalized** into\n[JSON:API](https://jsonapi.org/) (the format used internally\nby EmberData), while data sent to an API is **serialized**\ninto the format the API expects.\n\n### Implementing a Serializer\n\nThere are only two required serializer methods, one for\nnormalizing data from the server API format into JSON:API, and\nanother for serializing records via `Snapshots` into the expected\nserver API format.\n\nTo implement a serializer, export a class that conforms to the structure\ndescribed by [<Interface> Serializer](/ember-data/release/classes/%3CInterface%3E%20Serializer)\nfrom the `app/serializers/` directory. An example is below.\n\n```ts\nimport EmberObject from '@ember/object';\n\nexport default class ApplicationSerializer extends EmberObject {\n  normalizeResponse(store, schema, rawPayload) {\n    return rawPayload;\n  }\n\n  serialize(snapshot, options) {\n    const serializedResource = {\n      id: snapshot.id,\n      type: snapshot.modelName,\n      attributes: snapshot.attributes()\n    };\n\n    return serializedResource;\n  }\n}\n ```\n\n\n### Serializer Resolution\n\n`store.serializerFor(name)` will lookup serializers defined in\n`app/serializers/` and return an instance. If no serializer is found, an\nerror will be thrown.\n\n`serializerFor` first attempts to find a serializer with an exact match on `name`,\nthen falls back to checking for the presence of a serializer named `application`.\n\n```ts\nstore.serializerFor('author');\n\n// lookup paths (in order) =>\n//   app/serializers/author.js\n//   app/serializers/application.js\n```\n\nMost requests in EmberData are made with respect to a particular `type` (or `modelName`)\n(e.g., \"get me the full collection of **books**\" or \"get me the **employee** whose id is 37\"). We\nrefer to this as the **primary** resource `type`.\n\nTypically `serializerFor` will be used to find a serializer with a name matching that of the primary\nresource `type` for the request, falling back to the `application` serializer for those types that\ndo not have a defined serializer. This is often described as a `per-model` or `per-type` strategy\nfor defining serializers. However, because APIs rarely format payloads per-type but rather\nper-API-version, this may not be a desired strategy.\n\nIt is recommended that applications define only a single `application` adapter and serializer\nwhere possible.\n\nIf you have multiple API formats and the per-type strategy is not viable, one strategy is to\nwrite an `application` adapter and serializer that make use of `options` to specify the desired\nformat when making a request.\n\n### Using a Serializer\n\nAny serializer in `app/serializers/` can be looked up by `name` using `store.serializerFor(name)`.\n\n### Default Serializers\n\nFor applications whose APIs are *very close to* or *exactly* the **REST** format or **JSON:API**\nformat the `@ember-data/serializer` package contains implementations these applications can\nextend. It also contains a simple `JSONSerializer` for serializing to/from very basic JSON objects.\n\nMany applications will find writing their own serializer to be more performant and less\ncomplex than extending these classes even when their API format is very close to that expected\nby these serializers.\n\nIt is recommended that apps write their own serializer to best suit the needs of their API and\napplication.",
      "itemtype": "main"
    },
    "@ember-data/serializer/rest": {
      "name": "@ember-data/serializer/rest",
      "submodules": {},
      "elements": {},
      "classes": {
        "EmbeddedRecordsMixin": 1,
        "RESTSerializer": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../serializer/src/rest.js",
      "line": 17,
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n Normally, applications will use the `RESTSerializer` by implementing\n the `normalize` method.\n\n This allows you to do whatever kind of munging you need and is\n especially useful if your server is inconsistent and you need to\n do munging differently for many different kinds of responses.\n\n See the `normalize` documentation for more information.\n\n ## Across the Board Normalization\n\n There are also a number of hooks that you might find useful to define\n across-the-board rules for your payload. These rules will be useful\n if your server is consistent, or if you're building an adapter for\n an infrastructure service, like Firebase, and want to encode service\n conventions.\n\n For example, if all of your keys are underscored and all-caps, but\n otherwise consistent with the names you use in your models, you\n can implement across-the-board rules for how to convert an attribute\n name in your model to a key in your JSON.\n\n ```app/serializers/application.js\n import RESTSerializer from '@ember-data/serializer/rest';\n import { underscore } from '<app-name>/utils/string-utils';\n\n export default class ApplicationSerializer extends RESTSerializer {\n   keyForAttribute(attr, method) {\n     return underscore(attr).toUpperCase();\n   }\n }\n ```\n\n You can also implement `keyForRelationship`, which takes the name\n of the relationship as the first parameter, the kind of\n relationship (`hasMany` or `belongsTo`) as the second parameter, and\n the method (`serialize` or `deserialize`) as the third parameter.",
      "itemtype": "main"
    },
    "@ember-data/serializer/json-api": {
      "name": "@ember-data/serializer/json-api",
      "submodules": {},
      "elements": {},
      "classes": {
        "JSONAPISerializer": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../serializer/src/json-api.js",
      "line": 12,
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n In EmberData a Serializer is used to serialize and deserialize\n records when they are transferred in and out of an external source.\n This process involves normalizing property names, transforming\n attribute values and serializing relationships.\n\n `JSONAPISerializer` supports the http://jsonapi.org/ spec and is the\n serializer recommended by Ember Data.\n\n This serializer normalizes a JSON API payload that looks like:\n\n ```app/models/player.js\n import Model, { attr, belongsTo } from '@ember-data/model';\n\n export default class Player extends Model {\n   @attr('string') name;\n   @attr('string') skill;\n   @attr('number') gamesPlayed;\n   @belongsTo('club') club;\n }\n ```\n\n ```app/models/club.js\n import Model, { attr, hasMany } from '@ember-data/model';\n\n export default class Club extends Model {\n   @attr('string') name;\n   @attr('string') location;\n   @hasMany('player') players;\n }\n ```\n\n ```js\n   {\n     \"data\": [\n       {\n         \"attributes\": {\n           \"name\": \"Benfica\",\n           \"location\": \"Portugal\"\n         },\n         \"id\": \"1\",\n         \"relationships\": {\n           \"players\": {\n             \"data\": [\n               {\n                 \"id\": \"3\",\n                 \"type\": \"players\"\n               }\n             ]\n           }\n         },\n         \"type\": \"clubs\"\n       }\n     ],\n     \"included\": [\n       {\n         \"attributes\": {\n           \"name\": \"Eusebio Silva Ferreira\",\n           \"skill\": \"Rocket shot\",\n           \"games-played\": 431\n         },\n         \"id\": \"3\",\n         \"relationships\": {\n           \"club\": {\n             \"data\": {\n               \"id\": \"1\",\n               \"type\": \"clubs\"\n             }\n           }\n         },\n         \"type\": \"players\"\n       }\n     ]\n   }\n ```\n\n to the format that the Ember Data store expects.\n\n ### Customizing meta\n\n Since a JSON API Document can have meta defined in multiple locations you can\n use the specific serializer hooks if you need to customize the meta.\n\n One scenario would be to camelCase the meta keys of your payload. The example\n below shows how this could be done using `normalizeArrayResponse` and\n `extractRelationship`.\n\n ```app/serializers/application.js\n import JSONAPISerializer from '@ember-data/serializer/json-api';\n\n export default class ApplicationSerializer extends JSONAPISerializer {\n   normalizeArrayResponse(store, primaryModelClass, payload, id, requestType) {\n     let normalizedDocument = super.normalizeArrayResponse(...arguments);\n\n     // Customize document meta\n     normalizedDocument.meta = camelCaseKeys(normalizedDocument.meta);\n\n     return normalizedDocument;\n   }\n\n   extractRelationship(relationshipHash) {\n     let normalizedRelationship = super.extractRelationship(...arguments);\n\n     // Customize relationship meta\n     normalizedRelationship.meta = camelCaseKeys(normalizedRelationship.meta);\n\n     return normalizedRelationship;\n   }\n }\n ```",
      "itemtype": "main"
    },
    "@ember-data/serializer/json": {
      "name": "@ember-data/serializer/json",
      "submodules": {},
      "elements": {},
      "classes": {
        "JSONSerializer": 1
      },
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../serializer/src/json.js",
      "line": 17,
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n In EmberData a Serializer is used to serialize and deserialize\n records when they are transferred in and out of an external source.\n This process involves normalizing property names, transforming\n attribute values and serializing relationships.\n\n By default, EmberData uses and recommends the `JSONAPISerializer`.\n\n `JSONSerializer` is useful for simpler or legacy backends that may\n not support the http://jsonapi.org/ spec.\n\n For example, given the following `User` model and JSON payload:\n\n ```app/models/user.js\n import Model, { attr, belongsTo, hasMany } from '@ember-data/model';\n\n export default class UserModel extends Model {\n   @hasMany('user') friends;\n   @belongsTo('location') house;\n\n   @attr('string') name;\n }\n ```\n\n ```js\n {\n   id: 1,\n   name: 'Sebastian',\n   friends: [3, 4],\n   links: {\n     house: '/houses/lefkada'\n   }\n }\n ```\n\n `JSONSerializer` will normalize the JSON payload to the JSON API format that the\n Ember Data store expects.\n\n You can customize how JSONSerializer processes its payload by passing options in\n the `attrs` hash or by subclassing the `JSONSerializer` and overriding hooks:\n\n   - To customize how a single record is normalized, use the `normalize` hook.\n   - To customize how `JSONSerializer` normalizes the whole server response, use the\n     `normalizeResponse` hook.\n   - To customize how `JSONSerializer` normalizes a specific response from the server,\n     use one of the many specific `normalizeResponse` hooks.\n   - To customize how `JSONSerializer` normalizes your id, attributes or relationships,\n     use the `extractId`, `extractAttributes` and `extractRelationships` hooks.\n\n The `JSONSerializer` normalization process follows these steps:\n\n   1. `normalizeResponse`\n       - entry method to the serializer.\n   2. `normalizeCreateRecordResponse`\n       - a `normalizeResponse` for a specific operation is called.\n   3. `normalizeSingleResponse`|`normalizeArrayResponse`\n       - for methods like `createRecord` we expect a single record back, while for methods like `findAll` we expect multiple records back.\n   4. `normalize`\n       - `normalizeArrayResponse` iterates and calls `normalize` for each of its records while `normalizeSingle`\n         calls it once. This is the method you most likely want to subclass.\n   5. `extractId` | `extractAttributes` | `extractRelationships`\n       - `normalize` delegates to these methods to\n         turn the record payload into the JSON API format.",
      "itemtype": "main"
    },
    "@ember-data/tracking": {
      "name": "@ember-data/tracking",
      "submodules": {},
      "elements": {},
      "classes": {
        "@ember-data/tracking": 1
      },
      "fors": {
        "@ember-data/tracking": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../tracking/src/-private.ts",
      "line": 11,
      "description": "This package provides primitives that allow powerful low-level\nadjustments to change tracking notification behaviors.\n\nTypically you want to use these primitives when you want to divorce\nproperty accesses on EmberData provided objects from the current\ntracking context. Typically this sort of thing occurs when serializing\ntracked data to send in a request: the data itself is often ancillary\nto the thing which triggered the request in the first place and you\nwould not want to re-trigger the request for any update to the data.",
      "itemtype": "main"
    }
  },
  "classes": {
    "@ember-data/active-record/request": {
      "name": "@ember-data/active-record/request",
      "shortname": "@ember-data/active-record/request",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/active-record/request",
      "namespace": ""
    },
    "BuildURLMixin": {
      "name": "BuildURLMixin",
      "shortname": "BuildURLMixin",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [
        "RESTAdapter"
      ],
      "module": "@ember-data/adapter",
      "namespace": "",
      "file": "../adapter/src/-private/build-url-mixin.ts",
      "line": 117,
      "description": "## Using BuildURLMixin\n\nTo use URL building, include the mixin when extending an adapter, and call `buildURL` where needed.\nThe default behaviour is designed for RESTAdapter.\n\n### Example\n\n```javascript\nimport Adapter, { BuildURLMixin } from '@ember-data/adapter';\n\nexport default class ApplicationAdapter extends Adapter.extend(BuildURLMixin) {\n  findRecord(store, type, id, snapshot) {\n    var url = this.buildURL(type.modelName, id, snapshot, 'findRecord');\n    return this.ajax(url, 'GET');\n  }\n}\n```\n\n### Attributes\n\nThe `host` and `namespace` attributes will be used if defined, and are optional.",
      "access": "public",
      "tagname": ""
    },
    "AdapterError": {
      "name": "AdapterError",
      "shortname": "AdapterError",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/error",
      "namespace": "",
      "file": "../adapter/src/error.js",
      "line": 7,
      "itemtype": "main",
      "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new adapter, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nAn `AdapterError` is used by an adapter to signal that an error occurred\nduring a request to an external API. It indicates a generic error, and\nsubclasses are used to indicate specific error states.\n\nTo create a custom error to signal a specific error state in communicating\nwith an external API, extend the `AdapterError`. For example, if the\nexternal API exclusively used HTTP `503 Service Unavailable` to indicate\nit was closed for maintenance:\n\n```app/adapters/maintenance-error.js\nimport AdapterError from '@ember-data/adapter/error';\n\nexport default AdapterError.extend({ message: \"Down for maintenance.\" });\n```\n\nThis error would then be returned by an adapter's `handleResponse` method:\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\nimport MaintenanceError from './maintenance-error';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  handleResponse(status) {\n    if (503 === status) {\n      return new MaintenanceError();\n    }\n\n    return super.handleResponse(...arguments);\n  }\n}\n```\n\nAnd can then be detected in an application and used to send the user to an\n`under-maintenance` route:\n\n```app/routes/application.js\nimport MaintenanceError from '../adapters/maintenance-error';\n\nexport default class ApplicationRoute extends Route {\n  actions: {\n    error(error, transition) {\n      if (error instanceof MaintenanceError) {\n        this.transitionTo('under-maintenance');\n        return;\n      }\n\n      // ...other error handling logic\n    }\n  }\n}\n```\n  @mainName @ember-data/adapter/error\n  @tag main\n",
      "_main": true,
      "access": "public",
      "tagname": ""
    },
    "InvalidError": {
      "name": "InvalidError",
      "shortname": "InvalidError",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/error",
      "namespace": "",
      "file": "../adapter/src/error.js",
      "line": 121,
      "description": "A `InvalidError` is used by an adapter to signal the external API\nwas unable to process a request because the content was not\nsemantically correct or meaningful per the API. Usually, this means a\nrecord failed some form of server-side validation. When a promise\nfrom an adapter is rejected with a `InvalidError` the record will\ntransition to the `invalid` state and the errors will be set to the\n`errors` property on the record.\n\nFor Ember Data to correctly map errors to their corresponding\nproperties on the model, Ember Data expects each error to be\na valid JSON-API error object with a `source/pointer` that matches\nthe property name. For example, if you had a Post model that\nlooked like this.\n\n```app/models/post.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @attr('string') title;\n  @attr('string') content;\n}\n```\n\nTo show an error from the server related to the `title` and\n`content` properties your adapter could return a promise that\nrejects with a `InvalidError` object that looks like this:\n\n```app/adapters/post.js\nimport RSVP from 'RSVP';\nimport RESTAdapter from '@ember-data/adapter/rest';\nimport { InvalidError } from '@ember-data/adapter/error';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  updateRecord() {\n    // Fictional adapter that always rejects\n    return RSVP.reject(new InvalidError([\n      {\n        detail: 'Must be unique',\n        source: { pointer: '/data/attributes/title' }\n      },\n      {\n        detail: 'Must not be blank',\n        source: { pointer: '/data/attributes/content'}\n      }\n    ]));\n  }\n}\n```\n\nYour backend may use different property names for your records the\nstore will attempt to extract and normalize the errors using the\nserializer's `extractErrors` method before the errors get added to\nthe model. As a result, it is safe for the `InvalidError` to\nwrap the error payload unaltered.",
      "access": "public",
      "tagname": "",
      "extends": "AdapterError"
    },
    "TimeoutError": {
      "name": "TimeoutError",
      "shortname": "TimeoutError",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/error",
      "namespace": "",
      "file": "../adapter/src/error.js",
      "line": 188,
      "description": "A `TimeoutError` is used by an adapter to signal that a request\nto the external API has timed out. I.e. no response was received from\nthe external API within an allowed time period.\n\nAn example use case would be to warn the user to check their internet\nconnection if an adapter operation has timed out:\n\n```app/routes/application.js\nimport { TimeoutError } from '@ember-data/adapter/error';\n\nexport default class ApplicationRoute extends Route {\n  @action\n  error(error, transition) {\n    if (error instanceof TimeoutError) {\n      // alert the user\n      alert('Are you still connected to the Internet?');\n      return;\n    }\n\n    // ...other error handling logic\n  }\n}\n```",
      "access": "public",
      "tagname": "",
      "extends": "AdapterError"
    },
    "AbortError": {
      "name": "AbortError",
      "shortname": "AbortError",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/error",
      "namespace": "",
      "file": "../adapter/src/error.js",
      "line": 220,
      "description": "A `AbortError` is used by an adapter to signal that a request to\nthe external API was aborted. For example, this can occur if the user\nnavigates away from the current page after a request to the external API\nhas been initiated but before a response has been received.",
      "access": "public",
      "tagname": "",
      "extends": "AdapterError"
    },
    "UnauthorizedError": {
      "name": "UnauthorizedError",
      "shortname": "UnauthorizedError",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/error",
      "namespace": "",
      "file": "../adapter/src/error.js",
      "line": 233,
      "description": "A `UnauthorizedError` equates to a HTTP `401 Unauthorized` response\nstatus. It is used by an adapter to signal that a request to the external\nAPI was rejected because authorization is required and has failed or has not\nyet been provided.\n\nAn example use case would be to redirect the user to a login route if a\nrequest is unauthorized:\n\n```app/routes/application.js\nimport { UnauthorizedError } from '@ember-data/adapter/error';\n\nexport default class ApplicationRoute extends Route {\n  @action\n  error(error, transition) {\n    if (error instanceof UnauthorizedError) {\n      // go to the login route\n      this.transitionTo('login');\n      return;\n    }\n\n    // ...other error handling logic\n  }\n}\n```",
      "access": "public",
      "tagname": "",
      "extends": "AdapterError"
    },
    "ForbiddenError": {
      "name": "ForbiddenError",
      "shortname": "ForbiddenError",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/error",
      "namespace": "",
      "file": "../adapter/src/error.js",
      "line": 269,
      "description": "A `ForbiddenError` equates to a HTTP `403 Forbidden` response status.\nIt is used by an adapter to signal that a request to the external API was\nvalid but the server is refusing to respond to it. If authorization was\nprovided and is valid, then the authenticated user does not have the\nnecessary permissions for the request.",
      "access": "public",
      "tagname": "",
      "extends": "AdapterError"
    },
    "NotFoundError": {
      "name": "NotFoundError",
      "shortname": "NotFoundError",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/error",
      "namespace": "",
      "file": "../adapter/src/error.js",
      "line": 286,
      "description": "A `NotFoundError` equates to a HTTP `404 Not Found` response status.\nIt is used by an adapter to signal that a request to the external API\nwas rejected because the resource could not be found on the API.\n\nAn example use case would be to detect if the user has entered a route\nfor a specific model that does not exist. For example:\n\n```app/routes/post.js\nimport { NotFoundError } from '@ember-data/adapter/error';\n\nexport default class PostRoute extends Route {\n  @service store;\n  model(params) {\n    return this.store.findRecord('post', params.post_id);\n  }\n  @action\n  error(error, transition) {\n    if (error instanceof NotFoundError) {\n      // redirect to a list of all posts instead\n      this.transitionTo('posts');\n    } else {\n      // otherwise let the error bubble\n      return true;\n    }\n  }\n}\n```",
      "access": "public",
      "tagname": "",
      "extends": "AdapterError"
    },
    "ConflictError": {
      "name": "ConflictError",
      "shortname": "ConflictError",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/error",
      "namespace": "",
      "file": "../adapter/src/error.js",
      "line": 325,
      "description": "A `ConflictError` equates to a HTTP `409 Conflict` response status.\nIt is used by an adapter to indicate that the request could not be processed\nbecause of a conflict in the request. An example scenario would be when\ncreating a record with a client-generated ID but that ID is already known\nto the external API.",
      "access": "public",
      "tagname": "",
      "extends": "AdapterError"
    },
    "ServerError": {
      "name": "ServerError",
      "shortname": "ServerError",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/error",
      "namespace": "",
      "file": "../adapter/src/error.js",
      "line": 342,
      "description": "A `ServerError` equates to a HTTP `500 Internal Server Error` response\nstatus. It is used by the adapter to indicate that a request has failed\nbecause of an error in the external API.",
      "access": "public",
      "tagname": "",
      "extends": "AdapterError"
    },
    "Adapter": {
      "name": "Adapter",
      "shortname": "Adapter",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter",
      "namespace": "",
      "file": "../adapter/src/index.ts",
      "line": 201,
      "description": "An adapter is an object that receives requests from a store and\ntranslates them into the appropriate action to take against your\npersistence layer. The persistence layer is usually an HTTP API but\nmay be anything, such as the browser's local storage. Typically the\nadapter is not invoked directly instead its functionality is accessed\nthrough the `store`.\n\n> ‚ö†Ô∏è CAUTION you likely want the docs for [<Interface> Adapter](/ember-data/release/classes/%3CInterface%3E%20Adapter)\n> as extending this abstract class is unnecessary.\n\n### Creating an Adapter\n\nCreate a new subclass of `Adapter` in the `app/adapters` folder:\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\n\nexport default Adapter.extend({\n  // ...your code here\n});\n```\n\nModel-specific adapters can be created by putting your adapter\nclass in an `app/adapters/` + `model-name` + `.js` file of the application.\n\n```app/adapters/post.js\nimport Adapter from '@ember-data/adapter';\n\nexport default Adapter.extend({\n  // ...Post-specific adapter code goes here\n});\n```\n\n`Adapter` is an abstract base class that you should override in your\napplication to customize it for your backend. The minimum set of methods\nthat you should implement is:\n\n  * `findRecord()`\n  * `createRecord()`\n  * `updateRecord()`\n  * `deleteRecord()`\n  * `findAll()`\n  * `query()`\n\nTo improve the network performance of your application, you can optimize\nyour adapter by overriding these lower-level methods:\n\n  * `findMany()`\n\n\nFor an example of the implementation, see `RESTAdapter`, the\nincluded REST adapter.",
      "access": "public",
      "tagname": "",
      "extends": "Ember.EmberObject"
    },
    "JSONAPIAdapter": {
      "name": "JSONAPIAdapter",
      "shortname": "JSONAPIAdapter",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/json-api",
      "namespace": "",
      "file": "../adapter/src/json-api.ts",
      "line": 16,
      "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new adapter, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nThe `JSONAPIAdapter` is an adapter whichtransforms the store's\nrequests into HTTP requests that follow the [JSON API format](http://jsonapi.org/format/).\n\n## JSON API Conventions\n\nThe JSONAPIAdapter uses JSON API conventions for building the URL\nfor a record and selecting the HTTP verb to use with a request. The\nactions you can take on a record map onto the following URLs in the\nJSON API adapter:\n\n<table>\n<tr>\n  <th>\n    Action\n  </th>\n  <th>\n    HTTP Verb\n  </th>\n  <th>\n    URL\n  </th>\n</tr>\n<tr>\n  <th>\n    `store.findRecord('post', 123)`\n  </th>\n  <td>\n    GET\n  </td>\n  <td>\n    /posts/123\n  </td>\n</tr>\n<tr>\n  <th>\n    `store.findAll('post')`\n  </th>\n  <td>\n    GET\n  </td>\n  <td>\n    /posts\n  </td>\n</tr>\n<tr>\n  <th>\n    Update `postRecord.save()`\n  </th>\n  <td>\n    PATCH\n  </td>\n  <td>\n    /posts/123\n  </td>\n</tr>\n<tr>\n  <th>\n    Create `store.createRecord('post').save()`\n  </th>\n  <td>\n    POST\n  </td>\n  <td>\n    /posts\n  </td>\n</tr>\n<tr>\n  <th>\n    Delete `postRecord.destroyRecord()`\n  </th>\n  <td>\n    DELETE\n  </td>\n  <td>\n    /posts/123\n  </td>\n</tr>\n</table>\n\n## Success and failure\n\nThe JSONAPIAdapter will consider a success any response with a\nstatus code of the 2xx family (\"Success\"), as well as 304 (\"Not\nModified\"). Any other status code will be considered a failure.\n\nOn success, the request promise will be resolved with the full\nresponse payload.\n\nFailed responses with status code 422 (\"Unprocessable Entity\") will\nbe considered \"invalid\". The response will be discarded, except for\nthe `errors` key. The request promise will be rejected with a\n`InvalidError`. This error object will encapsulate the saved\n`errors` value.\n\nAny other status codes will be treated as an adapter error. The\nrequest promise will be rejected, similarly to the invalid case,\nbut with an instance of `AdapterError` instead.\n\n### Endpoint path customization\n\nEndpoint paths can be prefixed with a `namespace` by setting the\nnamespace property on the adapter:\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  namespace = 'api/1';\n}\n```\nRequests for the `person` model would now target `/api/1/people/1`.\n\n### Host customization\n\nAn adapter can target other hosts by setting the `host` property.\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  host = 'https://api.example.com';\n}\n```\n\nRequests for the `person` model would now target\n`https://api.example.com/people/1`.",
      "since": "1.13.0",
      "mainName": "@ember-data/adapter/json-api",
      "tag": "main",
      "itemtype": "main",
      "_main": true,
      "access": "public",
      "tagname": "",
      "is_constructor": 1,
      "extends": "RESTAdapter"
    },
    "RESTAdapter": {
      "name": "RESTAdapter",
      "shortname": "RESTAdapter",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/rest",
      "namespace": "",
      "file": "../adapter/src/rest.ts",
      "line": 68,
      "itemtype": "main",
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n The REST adapter allows your store to communicate with an HTTP server by\n transmitting JSON via XHR.\n\n This adapter is designed around the idea that the JSON exchanged with\n the server should be conventional. It builds URLs in a manner that follows\n the structure of most common REST-style web services.\n\n ## Success and failure\n\n The REST adapter will consider a success any response with a status code\n of the 2xx family (\"Success\"), as well as 304 (\"Not Modified\"). Any other\n status code will be considered a failure.\n\n On success, the request promise will be resolved with the full response\n payload.\n\n Failed responses with status code 422 (\"Unprocessable Entity\") will be\n considered \"invalid\". The response will be discarded, except for the\n `errors` key. The request promise will be rejected with a `InvalidError`.\n This error object will encapsulate the saved `errors` value.\n\n Any other status codes will be treated as an \"adapter error\". The request\n promise will be rejected, similarly to the \"invalid\" case, but with\n an instance of `AdapterError` instead.\n\n ## JSON Structure\n\n The REST adapter expects the JSON returned from your server to follow\n these conventions.\n\n ### Object Root\n\n The JSON payload should be an object that contains the record inside a\n root property. For example, in response to a `GET` request for\n `/posts/1`, the JSON should look like this:\n\n ```js\n {\n   \"posts\": {\n     \"id\": 1,\n     \"title\": \"I'm Running to Reform the W3C\",\n     \"author\": \"Yehuda Katz\"\n   }\n }\n ```\n\n Similarly, in response to a `GET` request for `/posts`, the JSON should\n look like this:\n\n ```js\n {\n   \"posts\": [\n     {\n       \"id\": 1,\n       \"title\": \"I'm Running to Reform the W3C\",\n       \"author\": \"Yehuda Katz\"\n     },\n     {\n       \"id\": 2,\n       \"title\": \"Rails is omakase\",\n       \"author\": \"D2H\"\n     }\n   ]\n }\n ```\n\n Note that the object root can be pluralized for both a single-object response\n and an array response: the REST adapter is not strict on this. Further, if the\n HTTP server responds to a `GET` request to `/posts/1` (e.g. the response to a\n `findRecord` query) with more than one object in the array, Ember Data will\n only display the object with the matching ID.\n\n ### Conventional Names\n\n Attribute names in your JSON payload should be the camelCased versions of\n the attributes in your Ember.js models.\n\n For example, if you have a `Person` model:\n\n ```app/models/person.js\n import Model, { attr } from '@ember-data/model';\n\n export default Model.extend({\n   firstName: attr('string'),\n   lastName: attr('string'),\n   occupation: attr('string')\n });\n ```\n\n The JSON returned should look like this:\n\n ```js\n {\n   \"people\": {\n     \"id\": 5,\n     \"firstName\": \"Zaphod\",\n     \"lastName\": \"Beeblebrox\",\n     \"occupation\": \"President\"\n   }\n }\n ```\n\n #### Relationships\n\n Relationships are usually represented by ids to the record in the\n relationship. The related records can then be sideloaded in the\n response under a key for the type.\n\n ```js\n {\n   \"posts\": {\n     \"id\": 5,\n     \"title\": \"I'm Running to Reform the W3C\",\n     \"author\": \"Yehuda Katz\",\n     \"comments\": [1, 2]\n   },\n   \"comments\": [{\n     \"id\": 1,\n     \"author\": \"User 1\",\n     \"message\": \"First!\",\n   }, {\n     \"id\": 2,\n     \"author\": \"User 2\",\n     \"message\": \"Good Luck!\",\n   }]\n }\n ```\n\n If the records in the relationship are not known when the response\n is serialized it's also possible to represent the relationship as a\n URL using the `links` key in the response. Ember Data will fetch\n this URL to resolve the relationship when it is accessed for the\n first time.\n\n ```js\n {\n   \"posts\": {\n     \"id\": 5,\n     \"title\": \"I'm Running to Reform the W3C\",\n     \"author\": \"Yehuda Katz\",\n     \"links\": {\n       \"comments\": \"/posts/5/comments\"\n     }\n   }\n }\n ```\n\n ### Errors\n\n If a response is considered a failure, the JSON payload is expected to include\n a top-level key `errors`, detailing any specific issues. For example:\n\n ```js\n {\n   \"errors\": {\n     \"msg\": \"Something went wrong\"\n   }\n }\n ```\n\n This adapter does not make any assumptions as to the format of the `errors`\n object. It will simply be passed along as is, wrapped in an instance\n of `InvalidError` or `AdapterError`. The serializer can interpret it\n afterwards.\n\n ## Customization\n\n ### Endpoint path customization\n\n Endpoint paths can be prefixed with a `namespace` by setting the namespace\n property on the adapter:\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   namespace = 'api/1';\n }\n ```\n Requests for the `Person` model would now target `/api/1/people/1`.\n\n ### Host customization\n\n An adapter can target other hosts by setting the `host` property.\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   host = 'https://api.example.com';\n }\n ```\n\n ### Headers customization\n\n Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary\n headers can be set as key/value pairs on the `RESTAdapter`'s `headers`\n object and EmberData will send them along with each ajax request.\n\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   get headers() {\n     return {\n       'API_KEY': 'secret key',\n       'ANOTHER_HEADER': 'Some header value'\n     };\n   }\n }\n ```\n  @mainName @ember-data/adapter/rest\n  @tag main\n",
      "_main": true,
      "access": "public",
      "tagname": "",
      "is_constructor": 1,
      "extends": "Adapter",
      "uses": [
        "BuildURLMixin"
      ]
    },
    "@ember-data/adapter/rest": {
      "name": "@ember-data/adapter/rest",
      "shortname": "@ember-data/adapter/rest",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/adapter/rest",
      "namespace": ""
    },
    "CanaryFeatures": {
      "name": "CanaryFeatures",
      "shortname": "CanaryFeatures",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/build-config",
      "namespace": "",
      "file": "../build-config/src/canary-features.ts",
      "line": 6,
      "description": "## Canary Features\nEmberData allows users to test features that are implemented but not yet\n available even in canary.\nTypically these features represent work that might introduce a new concept,\n new API, change an API, or risk an unintended change in behavior to consuming\n applications.\nSuch features have their implementations guarded by a \"feature flag\", and the\n flag is only activated once the core-data team is prepared to ship the work\n in a canary release.\n### Installing Canary\nTo test a feature you MUST be using a canary build. Canary builds are published\n to `npm` and can be installed using a precise tag (such as `ember-data@3.16.0-alpha.1`)\n or by installing the latest dist-tag published to the `canary` channel using your javascript\n package manager of choice. For instance with [pnpm](https://pnpm.io/)\n ```cli\n  pnpm add ember-data@canary\n  ```\n### Activating a Canary Feature\nOnce you have installed canary, feature-flags can be activated at build-time\nby setting an environment variable:\n```cli\n # Activate a single flag\n WARP_DRIVE_FEATURE_OVERRIDE=SOME_FLAG ember build\n# Activate multiple flags by separating with commas\n WARP_DRIVE_FEATURE_OVERRIDE=SOME_FLAG,OTHER_FLAG ember build\n# Activate all flags\n WARP_DRIVE_FEATURE_OVERRIDE=ENABLE_ALL_OPTIONAL ember build\n ```\nor by setting the appropriate flag in your `ember-cli-build` file:\n```ts\n setConfig(app, __dirname, {\n   features: {\n     SAMPLE_FEATURE_FLAG: false // utliize existing behavior, strip code for the new feature\n     OTHER_FEATURE_FLAG: true // utilize this new feature, strip code for the older behavior\n   }\n })\n ```\n**The \"off\" branch of feature-flagged code is always stripped from production builds.**\nThe list of available feature-flags is located [here](https://github.com/emberjs/data/tree/main/packages/build-config/src/virtual/canary-features.ts \"List of EmberData FeatureFlags\")\n\n### Preparing a Project to use a Canary Feature\nFor most projects, simple version detection should be enough.\n Using the provided version compatibility helpers from [embroider-macros](https://github.com/embroider-build/embroider/tree/main/packages/macros#readme)\n the following can be done:\n```js\n if (macroCondition(dependencySatisfies('@ember-data/store', '5.0'))) {\n   // do thing\n }\n ```\nThe current list of features used at build time for canary releases is defined below.\n If empty there are no features currently gated by feature flags.\nThe valid values are:\n - `true` | The feature is **enabled** at all times, and cannot be disabled.\n  - `false` | The feature is **disabled** at all times, and cannot be enabled.\n  - `null` | The feature is **disabled by default**, but can be enabled via configuration.",
      "access": "public",
      "tagname": ""
    },
    "DebugLogging": {
      "name": "DebugLogging",
      "shortname": "DebugLogging",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/build-config",
      "namespace": "",
      "file": "../build-config/src/debugging.ts",
      "line": 4,
      "description": "## Debug Logging\n\nMany portions of the internals are helpfully instrumented with logging that can be activated\nat build time. This instrumentation is always removed from production builds or any builds\nthat has not explicitly activated it. To activate it set the appropriate flag to `true`.\n\n```ts\nsetConfig(__dirname, app, {\n  debug: {\n    LOG_CACHE: false, // data store received to update cache with\n    LOG_NOTIFICATIONS: false,\n    LOG_REQUESTS: false,\n    LOG_REQUEST_STATUS: false,\n    LOG_IDENTIFIERS: false,\n    LOG_GRAPH: false,\n    LOG_INSTANCE_CACHE: false,\n    LOG_METRIC_COUNTS: false,\n    DEBUG_RELATIONSHIP_NOTIFICATIONS: false,\n  }\n});\n```",
      "access": "public",
      "tagname": ""
    },
    "CurrentDeprecations": {
      "name": "CurrentDeprecations",
      "shortname": "CurrentDeprecations",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/build-config",
      "namespace": "",
      "file": "../build-config/src/deprecation-versions.ts",
      "line": 22,
      "description": "## Deprecation Management\n\nEmberData allows users to opt-in and remove code that exists to support deprecated\nbehaviors.\n\nIf your app has resolved all deprecations present in a given version,\nyou may specify that version as your \"compatibility\" version to remove\nthe code that supported the deprecated behavior from your app.\n\nFor instance, if a deprecation was introduced in 3.13, and the app specifies\n3.13 as its minimum version compatibility, any deprecations introduced before\nor during 3.13 would be stripped away.\n\nAn app can use a different version than what it specifies as it's compatibility\nversion. For instance, an App could be using `3.16` while specifying compatibility\nwith `3.12`. This would remove any deprecations that were present in or before `3.12`\nbut keep support for anything deprecated in or above `3.13`.\n\nYou may also specify that specific deprecations are resolved. These approaches\nmay be used together.\n\n```ts\nsetConfig(app, __dirname, {\n  // declare that all deprecations through \"5.0\" have been fully resolved\n  compatWith: '5.0',\n\n  // mark individual deprecations as resolved by setting them to `false`\n  deprecations: {\n    // resolve individual deprecations here\n  },\n});\n```\n\n> [!TIP]\n> EmberData does not test against permutations of deprecations\n> being stripped, our tests run against \"all deprecated code included\"\n> and \"all deprecated code removed\". Unspecified behavior may sometimes occur\n> when removing code for only some deprecations associated to a version number.",
      "access": "public",
      "tagname": ""
    },
    "<Type> GenericField": {
      "name": "<Type> GenericField",
      "shortname": "<Type> GenericField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 6,
      "description": "A generic \"field\" that can be used to define\nprimitive value fields.\n\nReplaces \"attribute\" for primitive value fields.\nCan also be used to eject from deep-tracking of\nobjects or arrays.\n\nA major difference between \"field\" and \"attribute\"\nis that \"type\" points to a legacy transform on\n\"attribute\" that a serializer *might* use, while\n\"type\" points to a new-style transform on \"field\"\nthat a record implmentation *must* use.",
      "access": "public",
      "tagname": ""
    },
    "<Type> LegacyAliasField": {
      "name": "<Type> LegacyAliasField",
      "shortname": "<Type> LegacyAliasField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 60,
      "description": "A field that can be used to alias one key to another\nkey present in the cache version of the resource.\n\nUnlike DerivedField, an AliasField may write to its\nsource when a record is in an editable mode.\n\nAliasFields may utilize a transform, specified by type,\nto pre/post process the field.\n\nAn AliasField may also specify a `kind` via options.\n`kind` may be any other valid field kind other than\n\n- `@hash`\n- `@id`\n- `@local`\n- `derived`\n\nThis allows an AliasField to rename any field in the cache.\n\nAlias fields are generally intended to be used to support migrating\nbetween different schemas, though there are times where they are useful\nas a form of advanced derivation when used with a transform. For instance,\nan AliasField could be used to expose both a string and a Date version of the\nsame field, with both being capable of being written to.",
      "access": "public",
      "tagname": ""
    },
    "<Type> PolarisAliasField": {
      "name": "<Type> PolarisAliasField",
      "shortname": "<Type> PolarisAliasField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 133,
      "description": "A field that can be used to alias one key to another\nkey present in the cache version of the resource.\n\nUnlike DerivedField, an AliasField may write to its\nsource when a record is in an editable mode.\n\nAliasFields may utilize a transform, specified by type,\nto pre/post process the field.\n\nAn AliasField may also specify a `kind` via options.\n`kind` may be any other valid field kind other than\n\n- `@hash`\n- `@id`\n- `@local`\n- `derived`\n\nThis allows an AliasField to rename any field in the cache.\n\nAlias fields are generally intended to be used to support migrating\nbetween different schemas, though there are times where they are useful\nas a form of advanced derivation when used with a transform. For instance,\nan AliasField could be used to expose both a string and a Date version of the\nsame field, with both being capable of being written to.",
      "access": "public",
      "tagname": ""
    },
    "<Type> ObjectAliasField": {
      "name": "<Type> ObjectAliasField",
      "shortname": "<Type> ObjectAliasField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 205,
      "description": "A field that can be used to alias one key to another\nkey present in the cache version of the resource.\n\nUnlike DerivedField, an AliasField may write to its\nsource when a record is in an editable mode.\n\nAliasFields may utilize a transform, specified by type,\nto pre/post process the field.\n\nAn AliasField may also specify a `kind` via options.\n`kind` may be any other valid field kind other than\n\n- `@hash`\n- `@id`\n- `@local`\n- `derived`\n\nThis allows an AliasField to rename any field in the cache.\n\nAlias fields are generally intended to be used to support migrating\nbetween different schemas, though there are times where they are useful\nas a form of advanced derivation when used with a transform. For instance,\nan AliasField could be used to expose both a string and a Date version of the\nsame field, with both being capable of being written to.",
      "access": "public",
      "tagname": ""
    },
    "<Type> IdentityField": {
      "name": "<Type> IdentityField",
      "shortname": "<Type> IdentityField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 268,
      "description": "Represents a field whose value is the primary\nkey of the resource.\n\nThis allows any field to serve as the primary\nkey while still being able to drive identity\nneeds within the system.\n\nThis is useful for resources that use for instance\n'uuid', 'urn' or 'entityUrn' or 'primaryKey' as their\nprimary key field instead of 'id'.",
      "access": "public",
      "tagname": ""
    },
    "<Type> HashField": {
      "name": "<Type> HashField",
      "shortname": "<Type> HashField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 302,
      "description": "Represents a specialized field whose computed value\nwill be used as the primary key of a schema-object\nfor serializability and comparison purposes.\n\nThis field functions similarly to derived fields in that\nit is non-settable, derived state but differs in that\nit is only able to compute off of cache state and is given\nno access to a record instance.\n\nThis means that if a hashing function wants to compute its value\ntaking into account transformations and derivations it must\nperform those itself.\n\nA schema-array can declare its \"key\" value to be `@hash` if\na schema-object has such a field.\n\nOnly one hash field is permittable per schema-object, and\nit should be placed in the `ResourceSchema`'s `@id` field\nin place of an `IdentityField`.",
      "access": "public",
      "tagname": ""
    },
    "<Type> LocalField": {
      "name": "<Type> LocalField",
      "shortname": "<Type> LocalField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 367,
      "description": "Represents a field whose value is a local\nvalue that is not stored in the cache, nor\nis it sent to the server.\n\nLocal fields can be written to, and their\nvalue is both memoized and reactive (though\nnot deep-tracked).\n\nBecause their state is not derived from the cache\ndata or the server, they represent a divorced\nuncanonical source of state.\n\nFor this reason Local fields should be used sparingly.\n\nCurrently, while we document this feature here,\nonly allow our own SchemaRecord default fields to\nutilize them and the feature should be considered private.\n\nExample use cases that drove the creation of local\nfields are states like `isDestroying` and `isDestroyed`\nwhich are specific to a record instance but not\nstored in the cache. We wanted to be able to drive\nthese fields from schema the same as all other fields.\n\nDon't make us regret this decision.",
      "access": "public",
      "tagname": ""
    },
    "<Type> ObjectField": {
      "name": "<Type> ObjectField",
      "shortname": "<Type> ObjectField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 431,
      "description": "Represents a field whose value is an object\nwith keys pointing to values that are primitive\nvalues.\n\nIf values of the keys are not primitives, or\nif the key/value pairs have well-defined shape,\nuse 'schema-object' instead.",
      "access": "public",
      "tagname": ""
    },
    "<Type> SchemaObjectField": {
      "name": "<Type> SchemaObjectField",
      "shortname": "<Type> SchemaObjectField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 481,
      "description": "Represents a field whose value is an object\nwith a well-defined structure described by\na non-resource schema.\n\nIf the object's structure is not well-defined,\nuse 'object' instead.",
      "access": "public",
      "tagname": ""
    },
    "<Type> ArrayField": {
      "name": "<Type> ArrayField",
      "shortname": "<Type> ArrayField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 550,
      "description": "Represents a field whose value is an array\nof primitive values.\n\nIf the array's elements are not primitive\nvalues, use 'schema-array' instead.",
      "access": "public",
      "tagname": ""
    },
    "<Type> SchemaArrayField": {
      "name": "<Type> SchemaArrayField",
      "shortname": "<Type> SchemaArrayField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 599,
      "description": "Represents a field whose value is an array\nof objects with a well-defined structure\ndescribed by a non-resource schema.\n\nIf the array's elements are not well-defined,\nuse 'array' instead.",
      "access": "public",
      "tagname": ""
    },
    "<Type> DerivedField": {
      "name": "<Type> DerivedField",
      "shortname": "<Type> DerivedField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 713,
      "description": "Represents a field whose value is derived\nfrom other fields in the schema.\n\nThe value is read-only, and is not stored\nin the cache, nor is it sent to the server.\n\nUsage of derived fields should be minimized\nto scenarios where the derivation is known\nto be safe. For instance, derivations that\nrequired fields that are not always loaded\nor that require access to related resources\nthat may not be loaded should be avoided.",
      "access": "public",
      "tagname": ""
    },
    "<Type> ResourceField": {
      "name": "<Type> ResourceField",
      "shortname": "<Type> ResourceField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 781,
      "description": "Represents a field that is a reference to\nanother resource.\n\nSUPPORT FOR THIS FEATURE IS NOT YET IMPLEMENTED\nBY SchemaRecord",
      "access": "public",
      "tagname": ""
    },
    "<Type> CollectionField": {
      "name": "<Type> CollectionField",
      "shortname": "<Type> CollectionField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 874,
      "description": "Represents a field that is a reference to\na collection of other resources, potentially\npaginate.\n\nSUPPORT FOR THIS FEATURE IS NOT YET IMPLEMENTED\nBY SchemaRecord",
      "access": "public",
      "tagname": ""
    },
    "<Type> LegacyAttributeField": {
      "name": "<Type> LegacyAttributeField",
      "shortname": "<Type> LegacyAttributeField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 978,
      "description": "> [!CAUTION]\n> This Field is LEGACY\n> It cannot be used with PolarisMode\n\nA generic \"field\" that can be used to define\nprimitive value fields.\n\nIf the field points to an object or array,\nit will not be deep-tracked.\n\nTransforms when defined are legacy transforms\nthat a serializer *might* use, but their usage\nis not guaranteed.",
      "access": "public",
      "tagname": ""
    },
    "<Type> LegacyBelongsToField": {
      "name": "<Type> LegacyBelongsToField",
      "shortname": "<Type> LegacyBelongsToField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1030,
      "description": "> [!CAUTION]\n> This Field is LEGACY\n\nRepresents a field that is a reference to\nanother resource.\n\nThis is the legacy version of the `ResourceField`.",
      "access": "public",
      "tagname": ""
    },
    "<Type> LinksModeBelongsToField": {
      "name": "<Type> LinksModeBelongsToField",
      "shortname": "<Type> LinksModeBelongsToField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1173,
      "description": "> [!CAUTION]\n> This Field is LEGACY\n\nRepresents a field that is a reference to\nanother resource.\n\nThis is the legacy version of the `ResourceField`.",
      "access": "public",
      "tagname": ""
    },
    "<Type> LegacyHasManyField": {
      "name": "<Type> LegacyHasManyField",
      "shortname": "<Type> LegacyHasManyField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1315,
      "description": "> [!CAUTION]\n> This Field is LEGACY\n\nRepresents a field that is a reference to\na collection of other resources.\n\nThis is the legacy version of the `CollectionField`.",
      "access": "public",
      "tagname": ""
    },
    "<Type> LinksModeHasManyField": {
      "name": "<Type> LinksModeHasManyField",
      "shortname": "<Type> LinksModeHasManyField",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1463,
      "description": "> [!CAUTION]\n> This Field is LEGACY\n\nRepresents a field that is a reference to\na collection of other resources.\n\nThis is the legacy version of the `CollectionField`.",
      "access": "public",
      "tagname": ""
    },
    "<Type> LegacyModeFieldSchema": {
      "name": "<Type> LegacyModeFieldSchema",
      "shortname": "<Type> LegacyModeFieldSchema",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1617,
      "description": "A union of all possible LegacyMode field schemas.\n\nAvailable field schemas are:\n\n- [GenericField](../classes/<Type>%20GenericField)\n- [LegacyAliasField](../classes/<Type>%20LegacyAliasField)\n- [LocalField](../classes/<Type>%20LocalField)\n- [ObjectField](../classes/<Type>%20ObjectField)\n- [SchemaObjectField](../classes/<Type>%20SchemaObjectField)\n- [ArrayField](../classes/<Type>%20ArrayField)\n- [SchemaArrayField](../classes/<Type>%20SchemaArrayField)\n- [DerivedField](../classes/<Type>%20DerivedField)\n- [ResourceField (not yet implemented)](../classes/<Type>%20ResourceField)\n- [CollectionField (not yet implemented)](../classes/<Type>%20CollectionField)\n- [LegacyAttributeField](../classes/<Type>%20LegacyAttributeField)\n- [LegacyBelongsToField](../classes/<Type>%20LegacyBelongsToField)\n- [LegacyHasManyField](../classes/<Type>%20LegacyHasManyField)",
      "access": "public",
      "tagname": ""
    },
    "<Type> PolarisModeFieldSchema": {
      "name": "<Type> PolarisModeFieldSchema",
      "shortname": "<Type> PolarisModeFieldSchema",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1654,
      "description": "A union of all possible PolarisMode field schemas.\n\nAvailable field schemas are:\n\n- [GenericField](../classes/<Type>%20GenericField)\n- [PolarisAliasField](../classes/<Type>%20PolarisAliasField)\n- [LocalField](../classes/<Type>%20LocalField)\n- [ObjectField](../classes/<Type>%20ObjectField)\n- [SchemaObjectField](../classes/<Type>%20SchemaObjectField)\n- [ArrayField](../classes/<Type>%20ArrayField)\n- [SchemaArrayField](../classes/<Type>%20SchemaArrayField)\n- [DerivedField](../classes/<Type>%20DerivedField)\n- [ResourceField (not yet implemented)](../classes/<Type>%20ResourceField)\n- [CollectionField (not yet implemented)](../classes/<Type>%20CollectionField)\n- [LinksModeBelongsToField](../classes/<Type>%20LinksModeBelongsToField)\n- [LinksModeHasManyField](../classes/<Type>%20LinksModeHasManyField)",
      "access": "public",
      "tagname": ""
    },
    "<Type> FieldSchema": {
      "name": "<Type> FieldSchema",
      "shortname": "<Type> FieldSchema",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1689,
      "description": "A union of all possible LegacyMode and PolarisMode\nfield schemas.\n\nYou likely will want to use PolarisModeFieldSchema,\nLegacyModeFieldSchema, or ObjectFieldSchema instead\nas appropriate as they are more specific and will\nprovide better guidance around what is valid.",
      "access": "public",
      "tagname": ""
    },
    "<Type> ObjectFieldSchema": {
      "name": "<Type> ObjectFieldSchema",
      "shortname": "<Type> ObjectFieldSchema",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1719,
      "description": "A union of all possible field schemas that can be\nused in an ObjectSchema.",
      "access": "public",
      "tagname": ""
    },
    "<Type> PolarisResourceSchema": {
      "name": "<Type> PolarisResourceSchema",
      "shortname": "<Type> PolarisResourceSchema",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1736,
      "description": "Represents a schema for a primary resource in PolarisMode.\n\nPrimary resources are objects with a unique identity of their\nown which may allow them to appear in relationships, or in multiple\nresponse documents.",
      "access": "public",
      "tagname": ""
    },
    "<Type> LegacyResourceSchema": {
      "name": "<Type> LegacyResourceSchema",
      "shortname": "<Type> LegacyResourceSchema",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1805,
      "description": "Represents a schema for a primary resource in LegacyMode\n\nPrimary resources are objects with a unique identity of their\nown which may allow them to appear in relationships, or in multiple\nresponse documents.",
      "access": "public",
      "tagname": ""
    },
    "<Type> ObjectSchema": {
      "name": "<Type> ObjectSchema",
      "shortname": "<Type> ObjectSchema",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": "",
      "file": "../core-types/src/schema/fields.ts",
      "line": 1892,
      "description": "Represents a schema for an object that is not\na primary resource (has no unique identity of its own).\n\nObjectSchemas may not currently contain relationships.",
      "access": "public",
      "tagname": ""
    },
    "@warp-drive/core-types": {
      "name": "@warp-drive/core-types",
      "shortname": "@warp-drive/core-types",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/core-types",
      "namespace": ""
    },
    "<Interface> Cache": {
      "name": "<Interface> Cache",
      "shortname": "<Interface> Cache",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/experimental-preview-types",
      "namespace": "",
      "file": "../core-types/src/cache.ts",
      "line": 39,
      "description": "The interface for EmberData Caches.\n\nA Cache handles in-memory storage of Document and Resource\ndata.",
      "access": "public",
      "tagname": ""
    },
    "StableRecordIdentifier": {
      "name": "StableRecordIdentifier",
      "shortname": "StableRecordIdentifier",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../core-types/src/identifier.ts",
      "line": 99,
      "description": "A referentially stable object with a unique string (lid) that can be used\nas a reference to data in the cache.\n\nEvery record instance has a unique identifier, and identifiers may refer\nto data that has never been loaded (for instance, in an async relationship).",
      "access": "public",
      "tagname": ""
    },
    "InspectorDataAdapter": {
      "name": "InspectorDataAdapter",
      "shortname": "InspectorDataAdapter",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/debug",
      "namespace": "",
      "file": "../debug/src/data-adapter.ts",
      "line": 149,
      "description": "Implements `@ember/debug/data-adapter` with for EmberData\nintegration with the ember-inspector.",
      "extends": "DataAdapter",
      "access": "private",
      "tagname": ""
    },
    "<Throw />": {
      "name": "<Throw />",
      "shortname": "<Throw />",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/ember",
      "namespace": "",
      "file": "../ember/src/-private/await.gts",
      "line": 18,
      "description": "The `<Throw />` component is used to throw an error in a template.\n\nThat's all it does. So don't use it unless the application should\nthrow an error if it reaches this point in the template.\n\n```hbs\n<Throw @error={{anError}} />\n```",
      "access": "public",
      "tagname": ""
    },
    "<Await />": {
      "name": "<Await />",
      "shortname": "<Await />",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/ember",
      "namespace": "",
      "file": "../ember/src/-private/await.gts",
      "line": 53,
      "description": "The <Await /> component allow you to utilize reactive control flow\nfor asynchronous states in your application.\n\nAwait is ideal for handling \"boundaries\", outside which some state is\nstill allowed to be unresolved and within which it MUST be resolved.\n\n```gjs\nimport { Await } from '@warp-drive/ember';\n\n<template>\n  <Await @promise={{@request}}>\n    <:pending>\n      <Spinner />\n    </:pending>\n\n    <:error as |error|>\n      <ErrorForm @error={{error}} />\n    </:error>\n\n    <:success as |result|>\n      <h1>{{result.title}}</h1>\n    </:success>\n  </Await>\n</template>\n```\n\nThe <Await /> component requires that error states are properly handled.\n\nIf no error block is provided and the promise rejects, the error will\nbe thrown.",
      "access": "public",
      "tagname": ""
    },
    "PromiseState": {
      "name": "PromiseState",
      "shortname": "PromiseState",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/ember",
      "namespace": "",
      "file": "../ember/src/-private/promise-state.ts",
      "line": 11,
      "description": "PromiseState provides a reactive wrapper for a promise which allows you write declarative\ncode around a promise's control flow. It is useful in both Template and JavaScript contexts,\nallowing you to quickly derive behaviors and data from pending, error and success states.\n\n```ts\ninterface PromiseState<T = unknown, E = unknown> {\n  isPending: boolean;\n  isSuccess: boolean;\n  isError: boolean;\n  result: T | null;\n  error: E | null;\n}\n```\n\nTo get the state of a promise, use `getPromiseState`.",
      "access": "public",
      "tagname": ""
    },
    "@warp-drive/ember": {
      "name": "@warp-drive/ember",
      "shortname": "@warp-drive/ember",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/ember",
      "namespace": ""
    },
    "RequestLoadingState": {
      "name": "RequestLoadingState",
      "shortname": "RequestLoadingState",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/ember",
      "namespace": "",
      "file": "../ember/src/-private/request-state.ts",
      "line": 77,
      "description": "Lazily consumes the stream of a request, providing a number of\nreactive properties that can be used to build UIs that respond\nto the progress of a request.",
      "access": "public",
      "tagname": ""
    },
    "RequestState": {
      "name": "RequestState",
      "shortname": "RequestState",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/ember",
      "namespace": "",
      "file": "../ember/src/-private/request-state.ts",
      "line": 232,
      "description": "RequestState extends the concept of PromiseState to provide a reactive\nwrapper for a request `Future` which allows you write declarative code\naround a Future's control flow.\n\nIt is useful in both Template and JavaScript contexts, allowing you\nto quickly derive behaviors and data from pending, error and success\nstates.\n\nThe key difference between a Promise and a Future is that Futures provide\naccess to a stream of their content, the identity of the request (if any)\nas well as the ability to attempt to abort the request.\n\n```ts\ninterface Future<T> extends Promise<T>> {\n  getStream(): Promise<ReadableStream>;\n  abort(): void;\n  lid: StableDocumentIdentifier | null;\n}\n```\n\nThese additional APIs allow us to craft even richer state experiences.\n\nTo get the state of a request, use `getRequestState`.",
      "access": "public",
      "tagname": ""
    },
    "<Request />": {
      "name": "<Request />",
      "shortname": "<Request />",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/ember",
      "namespace": "",
      "file": "../ember/src/-private/request.gts",
      "line": 186,
      "description": "The `<Request />` component is a powerful tool for managing data fetching and\nstate in your Ember application. It provides a declarative approach to reactive\ncontrol-flow for managing requests and state in your application.\n\nThe `<Request />` component is ideal for handling \"boundaries\", outside which some\nstate is still allowed to be unresolved and within which it MUST be resolved.\n\n## Request States\n\n`<Request />` has five states, only one of which will be active and rendered at a time.\n\n- `idle`: The component is waiting to be given a request to monitor\n- `loading`: The request is in progress\n- `error`: The request failed\n- `content`: The request succeeded\n- `cancelled`: The request was cancelled\n\nAdditionally, the `content` state has a `refresh` method that can be used to\nrefresh the request in the background, which is available as a sub-state of\nthe `content` state.\n\nAs with the `<Await />` component, if no error block is provided and the request\nrejects, the error will be thrown. Cancellation errors are swallowed instead of\nrethrown if no error block or cancellation block is present.\n\n```gts\nimport { Request } from '@warp-drive/ember';\n\n<template>\n  <Request @request={{@request}}>\n    <:loading as |state|>\n      <Spinner @percentDone={{state.completedRatio}} />\n      <button {{on \"click\" state.abort}}>Cancel</button>\n    </:loading>\n\n    <:error as |error state|>\n      <ErrorForm @error={{error}} />\n      <button {{on \"click\" state.retry}}>Retry</button>\n    </:error>\n\n    <:content as |data state|>\n      <h1>{{data.title}}</h1>\n      {{#if state.isBackgroundReloading}}\n        <SmallSpinner />\n        <button {{on \"click\" state.abort}}>Cancel</button>\n      {{else}}\n        <button {{on \"click\" state.refresh}}>Refresh</button>\n      {{/if}}\n    </:content>\n\n    <:cancelled as |error state|>\n      <h2>The Request was cancelled</h2>\n      <button {{on \"click\" state.retry}}>Retry</button>\n    </:cancelled>\n\n    <:idle>\n      <button {{on \"click\" @kickOffRequest}}>Load Preview?</button>\n    </:idle>\n\n  </Request>\n</template>\n```\n\n## Streaming Data\n\nThe loading state exposes the download `ReadableStream` instance for consumption\n\n```gjs\nimport { Request } from '@warp-drive/ember';\n\n<template>\n  <Request @request={{@request}}>\n    <:loading as |state|>\n      <Video @stream={{state.stream}} />\n    </:loading>\n\n    <:error as |error|>\n      <ErrorForm @error={{error}} />\n    </:error>\n  </Request>\n</template>\n```\n\n## Retry\n\nCancelled and error'd requests may be retried by calling the `retry` method.\n\nRetry will restart the state progression, using the loading, error, cancelled,\nand content blocks as appropriate.\n\n## Reloading\n\nThe `reload` method will force the request to be fully re-executed, bypassing\ncache and restarting the state progression through the loading, error, and\ncontent blocks as appropriate.\n\nBackground reload (refresh) is a special substate of the content state that\nallows you to refresh the request in the background. This is useful for when\nyou want to update the data in the background without blocking the UI.\n\nReload and refresh are available as methods on the `content` state.\n\n```gjs\nimport { Request } from '@warp-drive/ember';\n\n<template>\n  <Request @request={{@request}}>\n    <:content as |data state|>\n      <h1>{{data.title}}</h1>\n      {{#if state.isBackgroundReloading}}\n        <SmallSpinner />\n        <button {{on \"click\" state.abort}}>Cancel</button>\n      {{/if}}\n\n      <button {{on \"click\" state.refresh}}>Refresh</button>\n      <button {{on \"click\" state.reload}}>Reload</button>\n    </:content>\n </Request>\n</template>\n```\n\n## Advanced Reloading\n\nWe can nest our usage of `<Request />` to handle more advanced\nreloading scenarios.\n\n```gjs\nimport { Request } from '@warp-drive/ember';\n\n<template>\n  <Request @request={{@request}}>\n    <:cancelled>\n      <h2>The Request Cancelled</h2>\n    </:cancelled>\n\n    <:error as |error|>\n      <ErrorForm @error={{error}} />\n    </:error>\n\n    <:content as |result state|>\n      <Request @request={{state.latestRequest}}>\n        <!-- Handle Background Request -->\n      </Request>\n\n      <h1>{{result.title}}</h1>\n\n      <button {{on \"click\" state.refresh}}>Refresh</button>\n    </:content>\n  </Request>\n</template>\n```\n\n## Autorefresh\n\n`<Request />` supports automatic refresh and reload under certain conditions.\n\n- `online`: This occurs when a browser window or tab comes back to the foreground\n  after being backgrounded or when the network reports as being online after\n  having been offline.\n- `interval`: This occurs when a specified amount of time has passed.\n- `invalid`: This occurs when the store emits a notification that the request\n  has become invalid.\n\nYou can specify when autorefresh should occur by setting the `autorefresh` arg\nto `true` or a comma-separated list of the above values.\n\nA value of `true` is equivalent to `'online,invalid'`.\n\nBy default, an autorefresh will only occur if the browser was backgrounded or\noffline for more than 30s before coming back available. This amount of time can\nbe tweaked by setting the number of milliseconds via `@autorefreshThreshold`.\n\nThis arg also controls the interval at which the request will be refreshed\nif the `interval` autorefresh type is enabled.\n\nFinally, the behavior of the request initiated by autorefresh can be adjusted\nby setting the `autorefreshBehavior` arg to `'refresh'`, `'reload'`, or `'policy'`.\n\n- `'refresh'`: Refresh the request in the background\n- `'reload'`: Force a reload of the request\n- `'policy'` (**default**): Let the store's configured CachePolicy decide whether to\n   reload, refresh, or do nothing.\n\nMore advanced refresh and reload behaviors can be created by passing the reload and\nrefresh actions into another component. For instance, refresh could be set up on a\ntimer or on a websocket subscription.\n\n\n```gjs\nimport { Request } from '@warp-drive/ember';\n\n<template>\n  <Request @request={{@request}}>\n    <:content as |result state|>\n      <h1>{{result.title}}</h1>\n\n      <Interval @period={{30_000}} @fn={{state.refresh}} />\n      <Subscribe @channel={{@someValue}} @fn={{state.refresh}} />\n    </:content>\n  </Request>\n</template>\n```\n\nIf a matching request is refreshed or reloaded by any other component,\nthe `Request` component will react accordingly.\n\n## Deduping\n\nThe store dedupes requests by identity. If a request is made for the same identity\nfrom multiple `<Request />` components, even if the request is not referentially the\nsame, only one actual request will be made.",
      "access": "public",
      "tagname": ""
    },
    "@ember-data/json-api/request": {
      "name": "@ember-data/json-api/request",
      "shortname": "@ember-data/json-api/request",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/json-api/request",
      "namespace": ""
    },
    "Cache": {
      "name": "Cache",
      "shortname": "Cache",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/json-api",
      "namespace": "",
      "file": "../json-api/src/-private/cache.ts",
      "line": 125,
      "description": "A JSON:API Cache implementation.\n\nWhat cache the store uses is configurable. Using a different\nimplementation can be achieved by implementing the store's\ncreateCache hook.\n\nThis is the cache implementation used by `ember-data`.\n\n```js\nimport Cache from '@ember-data/json-api';\nimport Store from '@ember-data/store';\n\nexport default class extends Store {\n  createCache(wrapper) {\n    return new Cache(wrapper);\n  }\n}\n```",
      "access": "public",
      "tagname": ""
    },
    "@ember-data/legacy-compat/builders": {
      "name": "@ember-data/legacy-compat/builders",
      "shortname": "@ember-data/legacy-compat/builders",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/legacy-compat/builders",
      "namespace": ""
    },
    "<Interface> Adapter": {
      "name": "<Interface> Adapter",
      "shortname": "<Interface> Adapter",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/experimental-preview-types",
      "namespace": "",
      "file": "../legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 20,
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n The following documentation describes the methods an\n adapter should implement with descriptions around when an\n application might expect these methods to be called.\n\n Methods that are not required are marked as **optional**.",
      "access": "public",
      "tagname": ""
    },
    "<Interface> Serializer": {
      "name": "<Interface> Serializer",
      "shortname": "<Interface> Serializer",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/experimental-preview-types",
      "namespace": "",
      "file": "../legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts",
      "line": 25,
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n The following documentation describes the methods an application\n serializer should implement with descriptions around when an\n application might expect these methods to be called.\n\n Methods that are not required are marked as **optional**.",
      "access": "public",
      "tagname": ""
    },
    "SnapshotRecordArray": {
      "name": "SnapshotRecordArray",
      "shortname": "SnapshotRecordArray",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/legacy-compat",
      "namespace": "",
      "file": "../legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 12,
      "description": "SnapshotRecordArray is not directly instantiable.\nInstances are provided to consuming application's\nadapters for certain `findAll` requests.",
      "access": "public",
      "tagname": ""
    },
    "Snapshot": {
      "name": "Snapshot",
      "shortname": "Snapshot",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 23,
      "description": "Snapshot is not directly instantiable.\nInstances are provided to a consuming application's\nadapters and serializers for certain requests.\n\nSnapshots are only available when using `@ember-data/legacy-compat`\nfor legacy compatibility with adapters and serializers.",
      "access": "public",
      "tagname": ""
    },
    "Store": {
      "name": "Store",
      "shortname": "Store",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/store-service.ts",
      "line": 283,
      "description": "A Store coordinates interaction between your application, a [Cache](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache),\nand sources of data (such as your API or a local persistence layer)\naccessed via a [RequestManager](https://github.com/emberjs/data/tree/main/packages/request).\n\n```app/services/store.js\nimport Store from '@ember-data/store';\n\nexport default class extends Store {}\n```\n\nMost Applications will only have a single `Store` configured as a Service\nin this manner. However, setting up multiple stores is possible, including using\neach as a unique service or within a specific context.",
      "access": "public",
      "tagname": ""
    },
    "@ember-data/legacy-compat/utils": {
      "name": "@ember-data/legacy-compat/utils",
      "shortname": "@ember-data/legacy-compat/utils",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/legacy-compat/utils",
      "namespace": ""
    },
    "BelongsToReference": {
      "name": "BelongsToReference",
      "shortname": "BelongsToReference",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/model",
      "namespace": "",
      "file": "../model/src/-private/references/belongs-to.ts",
      "line": 42,
      "description": "A `BelongsToReference` is a low-level API that allows access\nand manipulation of a belongsTo relationship.\n\nIt is especially useful when you're dealing with `async` relationships\nfrom `@ember-data/model` as it allows synchronous access to\nthe relationship data if loaded, as well as APIs for loading, reloading\nthe data or accessing available information without triggering a load.\n\nIt may also be useful when using `sync` relationships with `@ember-data/model`\nthat need to be loaded/reloaded with more precise timing than marking the\nrelationship as `async` and relying on autofetch would have allowed.\n\nHowever,keep in mind that marking a relationship as `async: false` will introduce\nbugs into your application if the data is not always guaranteed to be available\nby the time the relationship is accessed. Ergo, it is recommended when using this\napproach to utilize `links` for unloaded relationship state instead of identifiers.\n\nReference APIs are entangled with the relationship's underlying state,\nthus any getters or cached properties that utilize these will properly\ninvalidate if the relationship state changes.\n\nReferences are \"stable\", meaning that multiple calls to retrieve the reference\n for a given relationship will always return the same HasManyReference.",
      "access": "public",
      "tagname": ""
    },
    "HasManyReference": {
      "name": "HasManyReference",
      "shortname": "HasManyReference",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/model",
      "namespace": "",
      "file": "../model/src/-private/references/has-many.ts",
      "line": 45,
      "description": "A `HasManyReference` is a low-level API that allows access\nand manipulation of a hasMany relationship.\n\nIt is especially useful when you're dealing with `async` relationships\nfrom `@ember-data/model` as it allows synchronous access to\nthe relationship data if loaded, as well as APIs for loading, reloading\nthe data or accessing available information without triggering a load.\n\nIt may also be useful when using `sync` relationships with `@ember-data/model`\nthat need to be loaded/reloaded with more precise timing than marking the\nrelationship as `async` and relying on autofetch would have allowed.\n\nHowever,keep in mind that marking a relationship as `async: false` will introduce\nbugs into your application if the data is not always guaranteed to be available\nby the time the relationship is accessed. Ergo, it is recommended when using this\napproach to utilize `links` for unloaded relationship state instead of identifiers.\n\nReference APIs are entangled with the relationship's underlying state,\nthus any getters or cached properties that utilize these will properly\ninvalidate if the relationship state changes.\n\nReferences are \"stable\", meaning that multiple calls to retrieve the reference\n for a given relationship will always return the same HasManyReference.",
      "access": "public",
      "tagname": ""
    },
    "@ember-data/model": {
      "name": "@ember-data/model",
      "shortname": "@ember-data/model",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/model",
      "namespace": ""
    },
    "Errors": {
      "name": "Errors",
      "shortname": "Errors",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/model",
      "namespace": "",
      "file": "../model/src/-private/errors.ts",
      "line": 29,
      "description": "Holds validation errors for a given record, organized by attribute names.\n\nThis class is not directly instantiable.\n\nEvery `Model` has an `errors` property that is an instance of\n`Errors`. This can be used to display validation error\nmessages returned from the server when a `record.save()` rejects.\n\nFor Example, if you had a `User` model that looked like this:\n\n```app/models/user.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('string') username;\n  @attr('string') email;\n}\n```\nAnd you attempted to save a record that did not validate on the backend:\n\n```javascript\nlet user = store.createRecord('user', {\n  username: 'tomster',\n  email: 'invalidEmail'\n});\nuser.save();\n```\n\nYour backend would be expected to return an error response that described\nthe problem, so that error messages can be generated on the app.\n\nAPI responses will be translated into instances of `Errors` differently,\ndepending on the specific combination of adapter and serializer used. You\nmay want to check the documentation or the source code of the libraries\nthat you are using, to know how they expect errors to be communicated.\n\nErrors can be displayed to the user by accessing their property name\nto get an array of all the error objects for that property. Each\nerror object is a JavaScript object with two keys:\n\n- `message` A string containing the error message from the backend\n- `attribute` The name of the property associated with this error message\n\n```handlebars\n<label>Username: <Input @value={{@model.username}} /> </label>\n{{#each @model.errors.username as |error|}}\n  <div class=\"error\">\n    {{error.message}}\n  </div>\n{{/each}}\n\n<label>Email: <Input @value={{@model.email}} /> </label>\n{{#each @model.errors.email as |error|}}\n  <div class=\"error\">\n    {{error.message}}\n  </div>\n{{/each}}\n```\n\nYou can also access the special `messages` property on the error\nobject to get an array of all the error strings.\n\n```handlebars\n{{#each @model.errors.messages as |message|}}\n  <div class=\"error\">\n    {{message}}\n  </div>\n{{/each}}\n```",
      "access": "public",
      "tagname": "",
      "extends": "Ember.ArrayProxy"
    },
    "Model": {
      "name": "Model",
      "shortname": "Model",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/model",
      "namespace": "",
      "file": "../model/src/-private/model.ts",
      "line": 94,
      "description": "Base class from which Models can be defined.\n\n```js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class User extends Model {\n  @attr name;\n}\n```\n\nModels are used both to define the static schema for a\nparticular resource type as well as the class to instantiate\nto present that data from cache.",
      "access": "public",
      "tagname": "",
      "extends": "Ember.EmberObject"
    },
    "PromiseBelongsTo": {
      "name": "PromiseBelongsTo",
      "shortname": "PromiseBelongsTo",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/model",
      "namespace": "",
      "file": "../model/src/-private/promise-belongs-to.ts",
      "line": 41,
      "description": "A PromiseBelongsTo is a PromiseObject that also proxies certain method calls\nto the underlying belongsTo model.\nRight now we proxy:\n  * `reload()`",
      "extends": "PromiseObject",
      "access": "private",
      "tagname": ""
    },
    "PromiseManyArray": {
      "name": "PromiseManyArray",
      "shortname": "PromiseManyArray",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/model",
      "namespace": "",
      "file": "../model/src/-private/promise-many-array.ts",
      "line": 18,
      "description": "This class is returned as the result of accessing an async hasMany relationship\non an instance of a Model extending from `@ember-data/model`.\n\nA PromiseManyArray is an iterable proxy that allows templates to consume related\nManyArrays and update once their contents are no longer pending.\n\nIn your JS code you should resolve the promise first.\n\n```js\nconst comments = await post.comments;\n```",
      "access": "public",
      "tagname": ""
    },
    "@ember-data/request-utils": {
      "name": "@ember-data/request-utils",
      "shortname": "@ember-data/request-utils",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/request-utils",
      "namespace": ""
    },
    "CachePolicy": {
      "name": "CachePolicy",
      "shortname": "CachePolicy",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/request-utils",
      "namespace": "",
      "file": "../request-utils/src/index.ts",
      "line": 683,
      "description": "A basic CachePolicy that can be added to the Store service.\n\nDetermines staleness based on time since the request was last received from the API\nusing the `date` header.\n\nInvalidates any request for which `cacheOptions.types` was provided when a createRecord\nrequest for that type is successful.\n\nFor this to work, the `createRecord` request must include the `cacheOptions.types` array\nwith the types that should be invalidated, or its request should specify the identifiers\nof the records that are being created via `records`. Providing both is valid.\n\n> [!NOTE]\n> only requests that had specified `cacheOptions.types` and occurred prior to the\n> createRecord request will be invalidated. This means that a given request should always\n> specify the types that would invalidate it to opt into this behavior. Abstracting this\n> behavior via builders is recommended to ensure consistency.\n\nThis allows the Store's CacheHandler to determine if a request is expired and\nshould be refetched upon next request.\n\nThe `Fetch` handler provided by `@ember-data/request/fetch` will automatically\nadd the `date` header to responses if it is not present.\n\n> [!NOTE]\n> Date headers do not have millisecond precision, so expiration times should\n> generally be larger than 1000ms.\n\nUsage:\n\n```ts\nimport { CachePolicy } from '@ember-data/request-utils';\nimport DataStore from '@ember-data/store';\n\n// ...\n\nexport class Store extends DataStore {\n  constructor(args) {\n    super(args);\n    this.lifetimes = new CachePolicy({ apiCacheSoftExpires: 30_000, apiCacheHardExpires: 60_000 });\n  }\n}\n```",
      "access": "public",
      "tagname": ""
    },
    "RequestManager": {
      "name": "RequestManager",
      "shortname": "RequestManager",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/request",
      "namespace": "",
      "file": "../request/src/-private/manager.ts",
      "line": 441,
      "description": "```js\nimport RequestManager from '@ember-data/request';\n```\n\nA RequestManager provides a request/response flow in which configured\nhandlers are successively given the opportunity to handle, modify, or\npass-along a request.\n\n```ts\ninterface RequestManager {\n  request<T>(req: RequestInfo): Future<T>;\n}\n```\n\nFor example:\n\n```ts\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport Auth from 'ember-simple-auth/ember-data-handler';\nimport Config from './config';\n\nconst { apiUrl } = Config;\n\n// ... create manager\nconst manager = new RequestManager().use([Auth, Fetch]);\n\n// ... execute a request\nconst response = await manager.request({\n  url: `${apiUrl}/users`\n});\n```\n\n### Futures\n\nThe return value of `manager.request` is a `Future`, which allows\naccess to limited information about the request while it is still\npending and fulfills with the final state when the request completes.\n\nA `Future` is cancellable via `abort`.\n\nHandlers may optionally expose a `ReadableStream` to the `Future` for\nstreaming data; however, when doing so the future should not resolve\nuntil the response stream is fully read.\n\n```ts\ninterface Future<T> extends Promise<StructuredDocument<T>> {\n  abort(): void;\n\n  async getStream(): ReadableStream | null;\n}\n```\n\n### StructuredDocuments\n\nA Future resolves with a `StructuredDataDocument` or rejects with a `StructuredErrorDocument`.\n\n```ts\ninterface StructuredDataDocument<T> {\n  request: ImmutableRequestInfo;\n  response: ImmutableResponseInfo;\n  content: T;\n}\ninterface StructuredErrorDocument extends Error {\n  request: ImmutableRequestInfo;\n  response: ImmutableResponseInfo;\n  error: string | object;\n}\ntype StructuredDocument<T> = StructuredDataDocument<T> | StructuredErrorDocument;\n```",
      "access": "public",
      "tagname": ""
    },
    "Future": {
      "name": "Future",
      "shortname": "Future",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/request",
      "namespace": "",
      "file": "../request/src/-private/types.ts",
      "line": 38,
      "description": "A Future is a Promise which resolves to a StructuredDocument\nwhile providing the ability to `abort` the underlying request,\n`getStream` the response before the outer promise resolves;",
      "extends": "Promise",
      "access": "public",
      "tagname": ""
    },
    "<Interface> Handler": {
      "name": "<Interface> Handler",
      "shortname": "<Interface> Handler",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/request",
      "namespace": "",
      "file": "../request/src/-private/types.ts",
      "line": 107,
      "description": "Requests are fulfilled by handlers. A handler receives the request context\nas well as a `next` function with which to pass along a request to the next\nhandler if it so chooses.\n\nA handler may be any object with a `request` method. This allows both stateful and non-stateful\nhandlers to be utilized.\n\nIf a handler calls `next`, it receives a `Future` which resolves to a `StructuredDocument`\nthat it can then compose how it sees fit with its own response.\n\n```ts\ntype NextFn<P> = (req: RequestInfo) => Future<P>;\n\ninterface Handler {\n async request<T>(context: RequestContext, next: NextFn<P>): T;\n}\n```\n\n`RequestContext` contains a readonly version of the RequestInfo as well as a few methods for building up the `StructuredDocument` and `Future` that will be part of the response.\n\n```ts\ninterface RequestContext<T> {\n readonly request: RequestInfo;\n\n setStream(stream: ReadableStream | Promise<ReadableStream>): void;\n setResponse(response: Response | ResponseInfo): void;\n}\n```\n\nA basic `fetch` handler with support for streaming content updates while\nthe download is still underway might look like the following, where we use\n[`response.clone()`](https://developer.mozilla.org/en-US/docs/Web/API/Response/clone) to `tee` the `ReadableStream` into two streams.\n\nA more efficient handler might read from the response stream, building up the\nresponse content before passing along the chunk downstream.\n\n```ts\nconst FetchHandler = {\n async request(context) {\n   const response = await fetch(context.request);\n   context.setResponse(reponse);\n   context.setStream(response.clone().body);\n\n   return response.json();\n }\n}\n```\n\n### Stream Currying\n\n`RequestManager.request` and `next` differ from `fetch` in one **crucial detail** in that the outer Promise resolves only once the response stream has been processed.\n\nFor context, it helps to understand a few of the use-cases that RequestManager\nis intended to allow.\n\n- to manage and return streaming content (such as video files)\n- to fulfill a request from multiple sources or by splitting one request into multiple requests\n  - for instance one API call for a user and another for the user's friends\n  - or e.g. fulfilling part of the request from one source (one API, in-memory, localStorage, IndexedDB etc.) and the rest from another source (a different API, a WebWorker, etc.)\n- to coalesce multiple requests\n- to decorate a request with additional info\n  - e.g. an Auth handler that ensures the correct tokens or headers or cookies are attached.\n\n----\n\n`await fetch(<req>)` resolves at the moment headers are received. This allows for the body of the request to be processed as a stream by application\ncode *while chunks are still being received by the browser*.\n\nWhen an app chooses to `await response.json()` what occurs is the browser reads the stream to completion and then returns the result. Additionally, this stream may only be read **once**.\n\nThe `RequestManager` preserves this ability to subscribe to and utilize the stream by either the application or the handler ‚Äì¬†thereby delivering the full power and flexibility of native APIs ‚Äì without restricting developers in ways that lead to complicated workarounds.\n\nEach handler may call `setStream` only once, but may do so *at any time* until the promise that the handler returns has resolved. The associated promise returned by calling `future.getStream` will resolve with the stream set by `setStream` if that method is called, or `null` if that method\nhas not been called by the time that the handler's request method has resolved.\n\nHandlers that do not create a stream of their own, but which call `next`, should defensively pipe the stream forward. While this is not required (see automatic currying below) it is better to do so in most cases as otherwise the stream may not become available to downstream handlers or the application until the upstream handler has fully read it.\n\n```ts\ncontext.setStream(future.getStream());\n```\n\nHandlers that either call `next` multiple times or otherwise have reason to create multiple  fetch requests should either choose to return no stream, meaningfully combine the streams, or select a single prioritized stream.\n\nOf course, any handler may choose to read and handle the stream, and return either no stream or a different stream in the process.\n\n### Automatic Currying of Stream and Response\n\nIn order to simplify the common case for handlers which decorate a request, if `next` is called only a single time and `setResponse` was never called by the handler, the response set by the next handler in the chain will be applied to that handler's outcome. For instance, this makes the following pattern possible `return (await next(<req>)).content;`.\n\nSimilarly, if `next` is called only a single time and neither `setStream` nor `getStream` was called, we automatically curry the stream from the future returned by `next` onto the future returned by the handler.\n\nFinally, if the return value of a handler is a `Future`, we curry `content` and `errors` as well, thus enabling the simplest form `return next(<req>)`.\n\nIn the case of the `Future` being returned, `Stream` proxying is automatic and immediate and does not wait for the `Future` to resolve.\n\n### Handler Order\n\nRequest handlers are registered by configuring the manager via `use`\n\n```ts\nconst manager = new RequestManager()\n .use([Handler1, Handler2]);\n```\n\nHandlers will be invoked in the order they are registered (\"fifo\", first-in first-out), and may only be registered up until the first request is made. It is recommended but not required to register all handlers at one time in order to ensure explicitly visible handler ordering.",
      "access": "public",
      "tagname": ""
    },
    "<Interface> CacheHandler": {
      "name": "<Interface> CacheHandler",
      "shortname": "<Interface> CacheHandler",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/request",
      "namespace": "",
      "file": "../request/src/-private/types.ts",
      "line": 232,
      "description": "The CacheHandler is identical to other handlers ecxept that it\nis allowed to return a value synchronously. This is useful for\nfeatures like reducing microtask queueing when de-duping.\n\nA RequestManager may only have one CacheHandler, registered via\n`manager.useCache(CacheHandler)`.",
      "access": "public",
      "tagname": ""
    },
    "Fetch": {
      "name": "Fetch",
      "shortname": "Fetch",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/request/fetch",
      "namespace": "",
      "file": "../request/src/fetch.ts",
      "line": 108,
      "description": "A basic handler which converts a request into a\n`fetch` call presuming the response to be `json`.\n\n```ts\nimport Fetch from '@ember-data/request/fetch';\n\nmanager.use([Fetch]);\n```",
      "access": "public",
      "tagname": ""
    },
    "@ember-data/rest/request": {
      "name": "@ember-data/rest/request",
      "shortname": "@ember-data/rest/request",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/rest/request",
      "namespace": ""
    },
    "@warp-drive/schema-record": {
      "name": "@warp-drive/schema-record",
      "shortname": "@warp-drive/schema-record",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/schema-record",
      "namespace": ""
    },
    "SchemaService": {
      "name": "SchemaService",
      "shortname": "SchemaService",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@warp-drive/schema-record",
      "namespace": "",
      "file": "../schema-record/src/-private/schema.ts",
      "line": 195,
      "description": "A SchemaService designed to work with dynamically registered schemas.",
      "access": "public",
      "tagname": ""
    },
    "BooleanTransform": {
      "name": "BooleanTransform",
      "shortname": "BooleanTransform",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer",
      "namespace": "",
      "file": "../serializer/src/-private/transforms/boolean.ts",
      "line": 7,
      "description": "The `BooleanTransform` class is used to serialize and deserialize\nboolean attributes on Ember Data record objects. This transform is\nused when `boolean` is passed as the type parameter to the\n[attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function.\n\nUsage\n\n```app/models/user.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('boolean') isAdmin;\n  @attr('string') name;\n  @attr('string') email;\n}\n```\n\nBy default, the boolean transform only allows for values of `true` or\n`false`. You can opt into allowing `null` values for\nboolean attributes via `attr('boolean', { allowNull: true })`\n\n```app/models/user.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('string') email;\n  @attr('string') username;\n  @attr('boolean', { allowNull: true }) wantsWeeklyEmail;\n}\n```",
      "access": "public",
      "tagname": ""
    },
    "DateTransform": {
      "name": "DateTransform",
      "shortname": "DateTransform",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer",
      "namespace": "",
      "file": "../serializer/src/-private/transforms/date.ts",
      "line": 7,
      "description": "The `DateTransform` class is used to serialize and deserialize\ndate attributes on Ember Data record objects. This transform is used\nwhen `date` is passed as the type parameter to the\n[attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function. It uses the [`ISO 8601`](https://en.wikipedia.org/wiki/ISO_8601)\nstandard.\n\n```app/models/score.js\nimport Model, { attr, belongsTo } from '@ember-data/model';\n\nexport default class ScoreModel extends Model {\n   @attr('number') value;\n   @belongsTo('player') player;\n   @attr('date') date;\n }\n```",
      "access": "public",
      "tagname": ""
    },
    "NumberTransform": {
      "name": "NumberTransform",
      "shortname": "NumberTransform",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer",
      "namespace": "",
      "file": "../serializer/src/-private/transforms/number.ts",
      "line": 11,
      "description": "The `NumberTransform` class is used to serialize and deserialize\nnumeric attributes on Ember Data record objects. This transform is\nused when `number` is passed as the type parameter to the\n[attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function.\n\nUsage\n\n```app/models/score.js\nimport Model, { attr, belongsTo } from '@ember-data/model';\n\nexport default class ScoreModel extends Model {\n  @attr('number') value;\n  @belongsTo('player') player;\n  @attr('date') date;\n}\n```",
      "access": "public",
      "tagname": ""
    },
    "StringTransform": {
      "name": "StringTransform",
      "shortname": "StringTransform",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer",
      "namespace": "",
      "file": "../serializer/src/-private/transforms/string.ts",
      "line": 7,
      "description": "The `StringTransform` class is used to serialize and deserialize\nstring attributes on Ember Data record objects. This transform is\nused when `string` is passed as the type parameter to the\n[attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function.\n\nUsage\n\n```app/models/user.js\nimport Model, { attr, belongsTo } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('boolean') isAdmin;\n  @attr('string') name;\n  @attr('string') email;\n}\n```",
      "access": "public",
      "tagname": ""
    },
    "Transform": {
      "name": "Transform",
      "shortname": "Transform",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer",
      "namespace": "",
      "file": "../serializer/src/-private/transforms/transform.ts",
      "line": 8,
      "description": "The `Transform` class is used to serialize and deserialize model\nattributes when they are saved or loaded from an\nadapter. Subclassing `Transform` is useful for creating custom\nattributes. All subclasses of `Transform` must implement a\n`serialize` and a `deserialize` method.\n\nExample\n\n```app/transforms/temperature.js\n\n// Converts centigrade in the JSON to fahrenheit in the app\nexport default class TemperatureTransform {\n  deserialize(serialized, options) {\n    return (serialized *  1.8) + 32;\n  }\n\n  serialize(deserialized, options) {\n    return (deserialized - 32) / 1.8;\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```\n\nUsage\n\n```app/models/requirement.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class RequirementModel extends Model {\n  @attr('string') name;\n  @attr('temperature') temperature;\n}\n```\n\nThe options passed into the `attr` function when the attribute is\ndeclared on the model is also available in the transform.\n\n```app/models/post.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @attr('string') title;\n  @attr('markdown', {\n    markdown: {\n      gfm: false,\n      sanitize: true\n    }\n  })\n  markdown;\n}\n```\n\n```app/transforms/markdown.js\nexport default class MarkdownTransform {\n  serialize(deserialized, options) {\n    return deserialized.raw;\n  }\n\n  deserialize(serialized, options) {\n    let markdownOptions = options.markdown || {};\n\n    return marked(serialized, markdownOptions);\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```",
      "access": "public",
      "tagname": ""
    },
    "EmbeddedRecordsMixin": {
      "name": "EmbeddedRecordsMixin",
      "shortname": "EmbeddedRecordsMixin",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer/rest",
      "namespace": "",
      "file": "../serializer/src/-private/embedded-records-mixin.js",
      "line": 10,
      "description": "## Using Embedded Records\n\n`EmbeddedRecordsMixin` supports serializing embedded records.\n\nTo set up embedded records, include the mixin when extending a serializer,\nthen define and configure embedded (model) relationships.\n\nNote that embedded records will serialize with the serializer for their model instead of the serializer in which they are defined.\n\nNote also that this mixin does not work with JSONAPISerializer because the JSON:API specification does not describe how to format embedded resources.\n\nBelow is an example of a per-type serializer (`post` type).\n\n```app/serializers/post.js\nimport RESTSerializer, { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';\n\nexport default class PostSerializer extends RESTSerializer.extend(EmbeddedRecordsMixin) {\n  attrs = {\n    author: { embedded: 'always' },\n    comments: { serialize: 'ids' }\n  }\n}\n```\nNote that this use of `{ embedded: 'always' }` is unrelated to\nthe `{ embedded: 'always' }` that is defined as an option on `attr` as part of\ndefining a model while working with the `ActiveModelSerializer`.  Nevertheless,\nusing `{ embedded: 'always' }` as an option to `attr` is not a valid way to set up\nembedded records.\n\nThe `attrs` option for a resource `{ embedded: 'always' }` is shorthand for:\n\n```js\n{\n  serialize: 'records',\n  deserialize: 'records'\n}\n```\n\n### Configuring Attrs\n\nA resource's `attrs` option may be set to use `ids`, `records` or false for the\n`serialize`  and `deserialize` settings.\n\nThe `attrs` property can be set on the `ApplicationSerializer` or a per-type\nserializer.\n\nIn the case where embedded JSON is expected while extracting a payload (reading)\nthe setting is `deserialize: 'records'`, there is no need to use `ids` when\nextracting as that is the default behaviour without this mixin if you are using\nthe vanilla `EmbeddedRecordsMixin`. Likewise, to embed JSON in the payload while\nserializing `serialize: 'records'` is the setting to use. There is an option of\nnot embedding JSON in the serialized payload by using `serialize: 'ids'`. If you\ndo not want the relationship sent at all, you can use `serialize: false`.\n\n\n### EmbeddedRecordsMixin defaults\nIf you do not overwrite `attrs` for a specific relationship, the `EmbeddedRecordsMixin`\nwill behave in the following way:\n\nBelongsTo: `{ serialize: 'id', deserialize: 'id' }`\nHasMany:   `{ serialize: false, deserialize: 'ids' }`\n\n### Model Relationships\n\nEmbedded records must have a model defined to be extracted and serialized. Note that\nwhen defining any relationships on your model such as `belongsTo` and `hasMany`, you\nshould not both specify `async: true` and also indicate through the serializer's\n`attrs` attribute that the related model should be embedded for deserialization.\nIf a model is declared embedded for deserialization (`embedded: 'always'` or `deserialize: 'records'`),\nthen do not use `async: true`.\n\nTo successfully extract and serialize embedded records the model relationships\nmust be set up correctly. See the\n[defining relationships](https://guides.emberjs.com/current/models/relationships)\nsection of the **Defining Models** guide page.\n\nRecords without an `id` property are not considered embedded records, model\ninstances must have an `id` property to be used with Ember Data.\n\n### Example JSON payloads, Models and Serializers\n\n**When customizing a serializer it is important to grok what the customizations\nare. Please read the docs for the methods this mixin provides, in case you need\nto modify it to fit your specific needs.**\n\nFor example, review the docs for each method of this mixin:\n* [normalize](/ember-data/release/classes/EmbeddedRecordsMixin/methods/normalize?anchor=normalize)\n* [serializeBelongsTo](/ember-data/release/classes/EmbeddedRecordsMixin/methods/serializeBelongsTo?anchor=serializeBelongsTo)\n* [serializeHasMany](/ember-data/release/classes/EmbeddedRecordsMixin/methods/serializeHasMany?anchor=serializeHasMany)",
      "access": "public",
      "tagname": ""
    },
    "Serializer": {
      "name": "Serializer",
      "shortname": "Serializer",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer",
      "namespace": "",
      "file": "../serializer/src/index.ts",
      "line": 119,
      "description": "> ‚ö†Ô∏è CAUTION you likely want the docs for [<Interface> Serializer](/ember-data/release/classes/%3CInterface%3E%20Serializer)\n> as extending this abstract class is unnecessary.\n\n`Serializer` is an abstract base class that you may override in your\napplication to customize it for your backend. The minimum set of methods\nthat you should implement is:\n\n  * `normalizeResponse()`\n  * `serialize()`\n\nAnd you can optionally override the following methods:\n\n  * `normalize()`\n\nFor an example implementation, see\n[JSONSerializer](JSONSerializer), the included JSON serializer.",
      "access": "public",
      "tagname": "",
      "extends": "Ember.EmberObject"
    },
    "JSONAPISerializer": {
      "name": "JSONAPISerializer",
      "shortname": "JSONAPISerializer",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer/json-api",
      "namespace": "",
      "file": "../serializer/src/json-api.js",
      "line": 12,
      "itemtype": "main",
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n In EmberData a Serializer is used to serialize and deserialize\n records when they are transferred in and out of an external source.\n This process involves normalizing property names, transforming\n attribute values and serializing relationships.\n\n `JSONAPISerializer` supports the http://jsonapi.org/ spec and is the\n serializer recommended by Ember Data.\n\n This serializer normalizes a JSON API payload that looks like:\n\n ```app/models/player.js\n import Model, { attr, belongsTo } from '@ember-data/model';\n\n export default class Player extends Model {\n   @attr('string') name;\n   @attr('string') skill;\n   @attr('number') gamesPlayed;\n   @belongsTo('club') club;\n }\n ```\n\n ```app/models/club.js\n import Model, { attr, hasMany } from '@ember-data/model';\n\n export default class Club extends Model {\n   @attr('string') name;\n   @attr('string') location;\n   @hasMany('player') players;\n }\n ```\n\n ```js\n   {\n     \"data\": [\n       {\n         \"attributes\": {\n           \"name\": \"Benfica\",\n           \"location\": \"Portugal\"\n         },\n         \"id\": \"1\",\n         \"relationships\": {\n           \"players\": {\n             \"data\": [\n               {\n                 \"id\": \"3\",\n                 \"type\": \"players\"\n               }\n             ]\n           }\n         },\n         \"type\": \"clubs\"\n       }\n     ],\n     \"included\": [\n       {\n         \"attributes\": {\n           \"name\": \"Eusebio Silva Ferreira\",\n           \"skill\": \"Rocket shot\",\n           \"games-played\": 431\n         },\n         \"id\": \"3\",\n         \"relationships\": {\n           \"club\": {\n             \"data\": {\n               \"id\": \"1\",\n               \"type\": \"clubs\"\n             }\n           }\n         },\n         \"type\": \"players\"\n       }\n     ]\n   }\n ```\n\n to the format that the Ember Data store expects.\n\n ### Customizing meta\n\n Since a JSON API Document can have meta defined in multiple locations you can\n use the specific serializer hooks if you need to customize the meta.\n\n One scenario would be to camelCase the meta keys of your payload. The example\n below shows how this could be done using `normalizeArrayResponse` and\n `extractRelationship`.\n\n ```app/serializers/application.js\n import JSONAPISerializer from '@ember-data/serializer/json-api';\n\n export default class ApplicationSerializer extends JSONAPISerializer {\n   normalizeArrayResponse(store, primaryModelClass, payload, id, requestType) {\n     let normalizedDocument = super.normalizeArrayResponse(...arguments);\n\n     // Customize document meta\n     normalizedDocument.meta = camelCaseKeys(normalizedDocument.meta);\n\n     return normalizedDocument;\n   }\n\n   extractRelationship(relationshipHash) {\n     let normalizedRelationship = super.extractRelationship(...arguments);\n\n     // Customize relationship meta\n     normalizedRelationship.meta = camelCaseKeys(normalizedRelationship.meta);\n\n     return normalizedRelationship;\n   }\n }\n ```\n  @mainName @ember-data/serializer/json-api\n  @tag main\n",
      "_main": true,
      "since": "1.13.0",
      "access": "public",
      "tagname": "",
      "extends": "JSONSerializer"
    },
    "JSONSerializer": {
      "name": "JSONSerializer",
      "shortname": "JSONSerializer",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer/json",
      "namespace": "",
      "file": "../serializer/src/json.js",
      "line": 17,
      "itemtype": "main",
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n In EmberData a Serializer is used to serialize and deserialize\n records when they are transferred in and out of an external source.\n This process involves normalizing property names, transforming\n attribute values and serializing relationships.\n\n By default, EmberData uses and recommends the `JSONAPISerializer`.\n\n `JSONSerializer` is useful for simpler or legacy backends that may\n not support the http://jsonapi.org/ spec.\n\n For example, given the following `User` model and JSON payload:\n\n ```app/models/user.js\n import Model, { attr, belongsTo, hasMany } from '@ember-data/model';\n\n export default class UserModel extends Model {\n   @hasMany('user') friends;\n   @belongsTo('location') house;\n\n   @attr('string') name;\n }\n ```\n\n ```js\n {\n   id: 1,\n   name: 'Sebastian',\n   friends: [3, 4],\n   links: {\n     house: '/houses/lefkada'\n   }\n }\n ```\n\n `JSONSerializer` will normalize the JSON payload to the JSON API format that the\n Ember Data store expects.\n\n You can customize how JSONSerializer processes its payload by passing options in\n the `attrs` hash or by subclassing the `JSONSerializer` and overriding hooks:\n\n   - To customize how a single record is normalized, use the `normalize` hook.\n   - To customize how `JSONSerializer` normalizes the whole server response, use the\n     `normalizeResponse` hook.\n   - To customize how `JSONSerializer` normalizes a specific response from the server,\n     use one of the many specific `normalizeResponse` hooks.\n   - To customize how `JSONSerializer` normalizes your id, attributes or relationships,\n     use the `extractId`, `extractAttributes` and `extractRelationships` hooks.\n\n The `JSONSerializer` normalization process follows these steps:\n\n   1. `normalizeResponse`\n       - entry method to the serializer.\n   2. `normalizeCreateRecordResponse`\n       - a `normalizeResponse` for a specific operation is called.\n   3. `normalizeSingleResponse`|`normalizeArrayResponse`\n       - for methods like `createRecord` we expect a single record back, while for methods like `findAll` we expect multiple records back.\n   4. `normalize`\n       - `normalizeArrayResponse` iterates and calls `normalize` for each of its records while `normalizeSingle`\n         calls it once. This is the method you most likely want to subclass.\n   5. `extractId` | `extractAttributes` | `extractRelationships`\n       - `normalize` delegates to these methods to\n         turn the record payload into the JSON API format.\n  @mainName @ember-data/serializer/json\n  @tag main\n",
      "_main": true,
      "access": "public",
      "tagname": "",
      "extends": "Serializer"
    },
    "RESTSerializer": {
      "name": "RESTSerializer",
      "shortname": "RESTSerializer",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/serializer/rest",
      "namespace": "",
      "file": "../serializer/src/rest.js",
      "line": 17,
      "itemtype": "main",
      "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n Normally, applications will use the `RESTSerializer` by implementing\n the `normalize` method.\n\n This allows you to do whatever kind of munging you need and is\n especially useful if your server is inconsistent and you need to\n do munging differently for many different kinds of responses.\n\n See the `normalize` documentation for more information.\n\n ## Across the Board Normalization\n\n There are also a number of hooks that you might find useful to define\n across-the-board rules for your payload. These rules will be useful\n if your server is consistent, or if you're building an adapter for\n an infrastructure service, like Firebase, and want to encode service\n conventions.\n\n For example, if all of your keys are underscored and all-caps, but\n otherwise consistent with the names you use in your models, you\n can implement across-the-board rules for how to convert an attribute\n name in your model to a key in your JSON.\n\n ```app/serializers/application.js\n import RESTSerializer from '@ember-data/serializer/rest';\n import { underscore } from '<app-name>/utils/string-utils';\n\n export default class ApplicationSerializer extends RESTSerializer {\n   keyForAttribute(attr, method) {\n     return underscore(attr).toUpperCase();\n   }\n }\n ```\n\n You can also implement `keyForRelationship`, which takes the name\n of the relationship as the first parameter, the kind of\n relationship (`hasMany` or `belongsTo`) as the second parameter, and\n the method (`serialize` or `deserialize`) as the third parameter.\n  @mainName @ember-data/serializer/rest\n  @tag main\n",
      "_main": true,
      "access": "public",
      "tagname": "",
      "extends": "JSONSerializer"
    },
    "<Interface> CachePolicy": {
      "name": "<Interface> CachePolicy",
      "shortname": "<Interface> CachePolicy",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/cache-handler/types.ts",
      "line": 6,
      "description": "A service which an application may provide to the store via\nthe store's `lifetimes` property to configure the behavior\nof the CacheHandler.\n\nThe default behavior for request lifetimes is to never expire\nunless manually refreshed via `cacheOptions.reload` or `cacheOptions.backgroundReload`.\n\nImplementing this service allows you to programatically define\nwhen a request should be considered expired.",
      "access": "public",
      "tagname": ""
    },
    "IdentifierCache": {
      "name": "IdentifierCache",
      "shortname": "IdentifierCache",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/caches/identifier-cache.ts",
      "line": 221,
      "description": "Each instance of {Store} receives a unique instance of a IdentifierCache.\n\nThis cache is responsible for assigning or retrieving the unique identify\nfor arbitrary resource data encountered by the store. Data representing\na unique resource or record should always be represented by the same\nidentifier.\n\nIt can be configured by consuming applications.",
      "access": "public",
      "tagname": ""
    },
    "@ember-data/store": {
      "name": "@ember-data/store",
      "shortname": "@ember-data/store",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": ""
    },
    "RecordReference": {
      "name": "RecordReference",
      "shortname": "RecordReference",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/legacy-model-support/record-reference.ts",
      "line": 17,
      "description": "A `RecordReference` is a low-level API that allows users and\naddon authors to perform meta-operations on a record.",
      "access": "public",
      "tagname": ""
    },
    "CacheManager": {
      "name": "CacheManager",
      "shortname": "CacheManager",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/managers/cache-manager.ts",
      "line": 14,
      "description": "The CacheManager wraps a Cache enforcing that only\nthe public API surface area is exposed.\n\nHence, it is the value of `Store.cache`, wrapping\nthe cache instance returned by `Store.createCache`.\n\nIt handles translating between cache versions when\nnecessary, for instance when a Store is configured\nto use both a v1 and a v2 cache depending on some\nheuristic.\n\nStarting with the v2 spec, the cache is designed such\nthat it must be implemented as a singleton.",
      "access": "public",
      "tagname": ""
    },
    "NotificationManager": {
      "name": "NotificationManager",
      "shortname": "NotificationManager",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/managers/notification-manager.ts",
      "line": 93,
      "description": "The NotificationManager provides the ability to subscribe to\nchanges to Cache state.\n\nThis Feature is what allows EmberData to create subscriptions that\nwork with any framework or change-notification system.",
      "access": "public",
      "tagname": ""
    },
    "RequestStateService": {
      "name": "RequestStateService",
      "shortname": "RequestStateService",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/network/request-cache.ts",
      "line": 61,
      "description": "The RequestStateService is used to track the state of requests\nfor fetching or updating known resource identifies that are inflight.",
      "access": "public",
      "tagname": ""
    },
    "RecordArray": {
      "name": "RecordArray",
      "shortname": "RecordArray",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/record-arrays/identifier-array.ts",
      "line": 147,
      "description": "A record array is an array that contains records of a certain type (or modelName).\nThe record array materializes records as needed when they are retrieved for the first\ntime. You should not create record arrays yourself. Instead, an instance of\n`RecordArray` or its subclasses will be returned by your application's store\nin response to queries.\n\nThis class should not be imported and instantiated by consuming applications.",
      "access": "public",
      "tagname": ""
    },
    "ManyArray": {
      "name": "ManyArray",
      "shortname": "ManyArray",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/record-arrays/many-array.ts",
      "line": 47,
      "description": "A `ManyArray` is a `MutableArray` that represents the contents of a has-many\nrelationship.\n\nThe `ManyArray` is instantiated lazily the first time the relationship is\nrequested.\n\nThis class is not intended to be directly instantiated by consuming applications.\n\n### Inverses\n\nOften, the relationships in Ember Data applications will have\nan inverse. For example, imagine the following models are\ndefined:\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment') comments;\n}\n```\n\n```app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class CommentModel extends Model {\n  @belongsTo('post') post;\n}\n```\n\nIf you created a new instance of `Post` and added\na `Comment` record to its `comments` has-many\nrelationship, you would expect the comment's `post`\nproperty to be set to the post that contained\nthe has-many.\n\nWe call the record to which a relationship belongs-to the\nrelationship's _owner_.",
      "access": "public",
      "tagname": ""
    },
    "ReactiveDocument": {
      "name": "ReactiveDocument",
      "shortname": "ReactiveDocument",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-private/document.ts",
      "line": 21,
      "description": "A Document is a class that wraps the response content from a request to the API\nreturned by `Cache.put` or `Cache.peek`, converting resource-identifiers into\nrecord instances.\n\nIt is not directly instantiated by the user, and its properties should not\nbe directly modified. Whether individual properties are mutable or not is\ndetermined by the record instance itself.",
      "access": "public",
      "tagname": ""
    },
    "CacheCapabilitiesManager": {
      "name": "CacheCapabilitiesManager",
      "shortname": "CacheCapabilitiesManager",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-types/q/cache-capabilities-manager.ts",
      "line": 11,
      "description": "CacheCapabilitiesManager provides encapsulated API access to the minimal\nsubset of the Store's functionality that Cache implementations\nshould interact with. It is provided to the Store's `createCache` hook.\n\nCache implementations should not need more than this API provides.\n\nThis class cannot be directly instantiated.",
      "access": "public",
      "tagname": ""
    },
    "<Interface> SchemaService": {
      "name": "<Interface> SchemaService",
      "shortname": "<Interface> SchemaService",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/store",
      "namespace": "",
      "file": "../store/src/-types/q/schema-service.ts",
      "line": 24,
      "description": "The SchemaService provides the ability to query for information about the structure\nof any resource type.\n\nApplications can provide any implementation of the SchemaService they please so long\nas it conforms to this interface.\n\nThe design of the service means that schema information could be lazily populated,\nderived-on-demand, or progressively enhanced during the course of an application's runtime.\nThe primary requirement is merely that any information the service needs to correctly\nrespond to an inquest is available by the time it is asked.\n\nThe `@ember-data/model` package provides an implementation of this service which\nmakes use of your model classes as the source of information to respond to queries\nabout resource schema. While this is useful, this may not be ideal for your application.\nFor instance, Schema information could be sideloaded or pre-flighted for API calls,\nresulting in no need to bundle and ship potentially large and expensive JSON\nor large Javascript based Models to pull information from.\n\nTo register a custom schema implementation, implement the store's `createSchemaService`\nhook to return an instance of your service.\n\n```ts\nimport Store from '@ember-data/store';\nimport CustomSchemas from './custom-schemas';\n\nexport default class extends Store {\n  createSchemaService() {\n    return new CustomSchemas();\n  }\n}\n```\n\nAt runtime, both the `Store` and the `CacheCapabilitiesManager` provide\naccess to this service via the `schema` property.\n\n```ts\nexport default class extends Component {\n @service store;\n\n get fields() {\n   return this.store\n     .schema\n     .fields(this.args.dataType);\n }\n}\n```",
      "access": "public",
      "tagname": ""
    },
    "@ember-data/tracking": {
      "name": "@ember-data/tracking",
      "shortname": "@ember-data/tracking",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@ember-data/tracking",
      "namespace": ""
    }
  },
  "elements": {},
  "classitems": [
    {
      "file": "../packages/active-record/src/-private/builders/find-record.ts",
      "line": 18,
      "description": "Builds request options to fetch a single resource by a known id or identifier\nconfigured for the url and header expectations of most ActiveRecord APIs.\n\n**Basic Usage**\n\n```ts\nimport { findRecord } from '@ember-data/active-record/request';\n\nconst data = await store.request(findRecord('person', '1'));\n```\n\n**With Options**\n\n```ts\nimport { findRecord } from '@ember-data/active-record/request';\n\nconst options = findRecord('person', '1', { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**With an Identifier**\n\n```ts\nimport { findRecord } from '@ember-data/active-record/request';\n\nconst options = findRecord({ type: 'person', id: '1' }, { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing and underscoring the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { findRecord } from '@ember-data/active-record/request';\n\nconst options = findRecord('person', '1', { include: ['pets', 'friends'] }, { namespace: 'api/v2' });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "findRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/active-record/request",
      "module": "@ember-data/active-record/request"
    },
    {
      "file": "../packages/active-record/src/-private/builders/query.ts",
      "line": 13,
      "description": "Builds request options to query for resources, usually by a primary\ntype, configured for the url and header expectations of most ActiveRecord APIs.\n\n**Basic Usage**\n\n```ts\nimport { query } from '@ember-data/active-record/request';\n\nconst data = await store.request(query('person'));\n```\n\n**With Query Params**\n\n```ts\nimport { query } from '@ember-data/active-record/request';\n\nconst options = query('person', { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing and underscoring the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { query } from '@ember-data/active-record/request';\n\nconst options = query('person', { include: ['pets', 'friends'] }, { reload: true });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "query",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "query",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/active-record/request",
      "module": "@ember-data/active-record/request"
    },
    {
      "file": "../packages/active-record/src/-private/builders/save-record.ts",
      "line": 24,
      "description": "Builds request options to delete record for resources,\nconfigured for the url, method and header expectations of ActiveRecord APIs.\n\n**Basic Usage**\n\n```ts\nimport { deleteRecord } from '@ember-data/active-record/request';\n\nconst person = store.peekRecord('person', '1');\n\n// mark record as deleted\nstore.deleteRecord(person);\n\n// persist deletion\nconst data = await store.request(deleteRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { deleteRecord } from '@ember-data/active-record/request';\n\nconst person = store.peekRecord('person', '1');\n\n// mark record as deleted\nstore.deleteRecord(person);\n\n// persist deletion\nconst options = deleteRecord(person, { namespace: 'api/v1' });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "deleteRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/active-record/request",
      "module": "@ember-data/active-record/request"
    },
    {
      "file": "../packages/active-record/src/-private/builders/save-record.ts",
      "line": 107,
      "description": "Builds request options to create new record for resources,\nconfigured for the url, method and header expectations of most ActiveRecord APIs.\n\n**Basic Usage**\n\n```ts\nimport { createRecord } from '@ember-data/active-record/request';\n\nconst person = store.createRecord('person', { name: 'Ted' });\nconst data = await store.request(createRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { createRecord } from '@ember-data/active-record/request';\n\nconst person = store.createRecord('person', { name: 'Ted' });\nconst options = createRecord(person, { namespace: 'api/v1' });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "createRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/active-record/request",
      "module": "@ember-data/active-record/request"
    },
    {
      "file": "../packages/active-record/src/-private/builders/save-record.ts",
      "line": 179,
      "description": "Builds request options to update existing record for resources,\nconfigured for the url, method and header expectations of most ActiveRecord APIs.\n\n**Basic Usage**\n\n```ts\nimport { updateRecord } from '@ember-data/active-record/request';\n\nconst person = store.peekRecord('person', '1');\nperson.name = 'Chris';\nconst data = await store.request(updateRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `patch` - Allows caller to specify whether to use a PATCH request instead of a PUT request, defaults to `false`.\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { updateRecord } from '@ember-data/active-record/request';\n\nconst person = store.peekRecord('person', '1');\nperson.name = 'Chris';\nconst options = updateRecord(person, { patch: true });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "updateRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/active-record/request",
      "module": "@ember-data/active-record/request"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 143,
      "description": "Builds a URL for a given type and optional ID.\n\nBy default, it pluralizes the type's name (for example, 'post'\nbecomes 'posts' and 'person' becomes 'people'). To override the\npluralization see [pathForType](./pathForType?anchor=pathForType).\n\nIf an ID is specified, it adds the ID to the path generated\nfor the type, separated by a `/`.\n\nWhen called by `RESTAdapter.findMany()` the `id` and `snapshot` parameters\nwill be arrays of ids and snapshots.",
      "itemtype": "method",
      "name": "buildURL",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "id",
          "description": "single id or array of ids or query",
          "type": "(String|Array|Object)"
        },
        {
          "name": "snapshot",
          "description": "single snapshot or array of snapshots",
          "type": "(Snapshot|SnapshotRecordArray)"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        },
        {
          "name": "query",
          "description": "object of query parameters to send for query requests.",
          "type": "Object"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 292,
      "itemtype": "method",
      "name": "_buildURL",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "id",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 327,
      "description": "Builds a URL for a `store.findRecord(type, id)` call.\n\nExample:\n\n```app/adapters/user.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  urlForFindRecord(id, modelName, snapshot) {\n    let baseUrl = this.buildURL(modelName, id, snapshot);\n    return `${baseUrl}/users/${snapshot.adapterOptions.user_id}/playlists/${id}`;\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForFindRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "id",
          "description": "",
          "type": "String"
        },
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 355,
      "description": "Builds a URL for a `store.findAll(type)` call.\n\nExample:\n\n```app/adapters/comment.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  urlForFindAll(modelName, snapshot) {\n    let baseUrl = this.buildURL(modelName);\n    return `${baseUrl}/data/comments.json`;\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForFindAll",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "SnapshotRecordArray"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 381,
      "description": "Builds a URL for a `store.query(type, query)` call.\n\nExample:\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  host = 'https://api.github.com';\n  urlForQuery (query, modelName) {\n    switch(modelName) {\n      case 'repo':\n        return `https://api.github.com/orgs/${query.orgId}/repos`;\n      default:\n        return super.urlForQuery(...arguments);\n    }\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForQuery",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "query",
          "description": "",
          "type": "Object"
        },
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 412,
      "description": "Builds a URL for a `store.queryRecord(type, query)` call.\n\nExample:\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  urlForQueryRecord({ slug }, modelName) {\n    let baseUrl = this.buildURL();\n    return `${baseUrl}/${encodeURIComponent(slug)}`;\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForQueryRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "query",
          "description": "",
          "type": "Object"
        },
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 438,
      "description": "Builds a URL for coalescing multiple `store.findRecord(type, id)`\nrecords into 1 request when the adapter's `coalesceFindRequests`\nproperty is `true`.\n\nExample:\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  urlForFindMany(ids, modelName) {\n    let baseUrl = this.buildURL();\n    return `${baseUrl}/coalesce`;\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForFindMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "ids",
          "description": "",
          "type": "Array"
        },
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshots",
          "description": "",
          "type": "Array"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 467,
      "description": "Builds a URL for fetching an async `hasMany` relationship when a URL\nis not provided by the server.\n\nExample:\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  urlForFindHasMany(id, modelName, snapshot) {\n    let baseUrl = this.buildURL(modelName, id);\n    return `${baseUrl}/relationships`;\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForFindHasMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "id",
          "description": "",
          "type": "String"
        },
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 495,
      "description": "Builds a URL for fetching an async `belongsTo` relationship when a url\nis not provided by the server.\n\nExample:\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  urlForFindBelongsTo(id, modelName, snapshot) {\n    let baseUrl = this.buildURL(modelName, id);\n    return `${baseUrl}/relationships`;\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForFindBelongsTo",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "id",
          "description": "",
          "type": "String"
        },
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 523,
      "description": "Builds a URL for a `record.save()` call when the record was created\nlocally using `store.createRecord()`.\n\nExample:\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  urlForCreateRecord(modelName, snapshot) {\n    return super.urlForCreateRecord(...arguments) + '/new';\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForCreateRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 549,
      "description": "Builds a URL for a `record.save()` call when the record has been updated locally.\n\nExample:\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  urlForUpdateRecord(id, modelName, snapshot) {\n    return `/${id}/feed?access_token=${snapshot.adapterOptions.token}`;\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForUpdateRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "id",
          "description": "",
          "type": "String"
        },
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 575,
      "description": "Builds a URL for a `record.save()` call when the record has been deleted locally.\n\nExample:\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  urlForDeleteRecord(id, modelName, snapshot) {\n    return super.urlForDeleteRecord(...arguments) + '/destroy';\n  }\n}\n```",
      "itemtype": "method",
      "name": "urlForDeleteRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "id",
          "description": "",
          "type": "String"
        },
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "url",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 601,
      "itemtype": "method",
      "name": "urlPrefix",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "path",
          "description": "",
          "type": "String"
        },
        {
          "name": "parentURL",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "urlPrefix",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/-private/build-url-mixin.ts",
      "line": 642,
      "description": "Determines the pathname for a given type.\n\nBy default, it pluralizes the type's name (for example,\n'post' becomes 'posts' and 'person' becomes 'people').\n\n### Pathname customization\n\nFor example, if you have an object `LineItem` with an\nendpoint of `/line_items/`.\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\nimport { undesrcore, pluralize } from '<app-name>/utils/string-utils';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  pathForType(modelName) {\n    return pluralize(underscore(modelName));\n  }\n}\n```",
      "itemtype": "method",
      "name": "pathForType",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "path",
        "type": "String"
      },
      "class": "BuildURLMixin",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 264,
      "description": "The `findRecord()` method is invoked when the store is asked for a record that\nhas not previously been loaded. In response to `findRecord()` being called, you\nshould query your persistence layer for a record with the given ID. The `findRecord`\nmethod should return a promise that will resolve to a JavaScript object that will be\nnormalized by the serializer.\n\nHere is an example of the `findRecord` implementation:\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\nimport RSVP from 'RSVP';\nimport $ from 'jquery';\n\nexport default class ApplicationAdapter extends Adapter {\n  findRecord(store, type, id, snapshot) {\n    return new RSVP.Promise(function(resolve, reject) {\n      $.getJSON(`/${type.modelName}/${id}`).then(function(data) {\n        resolve(data);\n      }, function(jqXHR) {\n        reject(jqXHR);\n      });\n    });\n  }\n}\n```",
      "itemtype": "method",
      "name": "findRecord",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "id",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 306,
      "description": "The `findAll()` method is used to retrieve all records for a given type.\n\nExample\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\nimport RSVP from 'RSVP';\nimport $ from 'jquery';\n\nexport default class ApplicationAdapter extends Adapter {\n  findAll(store, type) {\n    return new RSVP.Promise(function(resolve, reject) {\n      $.getJSON(`/${type.modelName}`).then(function(data) {\n        resolve(data);\n      }, function(jqXHR) {\n        reject(jqXHR);\n      });\n    });\n  }\n}\n```",
      "itemtype": "method",
      "name": "findAll",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "neverSet",
          "description": "a value is never provided to this argument",
          "type": "Null"
        },
        {
          "name": "snapshotRecordArray",
          "description": "",
          "type": "SnapshotRecordArray"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 349,
      "description": "This method is called when you call `query` on the store.\n\nExample\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\nimport RSVP from 'RSVP';\nimport $ from 'jquery';\n\nexport default class ApplicationAdapter extends Adapter {\n  query(store, type, query) {\n    return new RSVP.Promise(function(resolve, reject) {\n      $.getJSON(`/${type.modelName}`, query).then(function(data) {\n        resolve(data);\n      }, function(jqXHR) {\n        reject(jqXHR);\n      });\n    });\n  }\n}\n```",
      "itemtype": "method",
      "name": "query",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "query",
          "description": "",
          "type": "Object"
        },
        {
          "name": "recordArray",
          "description": "",
          "type": "Collection"
        },
        {
          "name": "adapterOptions",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 388,
      "description": "The `queryRecord()` method is invoked when the store is asked for a single\nrecord through a query object.\n\nIn response to `queryRecord()` being called, you should always fetch fresh\ndata. Once found, you can asynchronously call the store's `push()` method\nto push the record into the store.\n\nHere is an example `queryRecord` implementation:\n\nExample\n\n```app/adapters/application.js\nimport Adapter, { BuildURLMixin } from '@ember-data/adapter';\nimport RSVP from 'RSVP';\nimport $ from 'jquery';\n\nexport default class ApplicationAdapter extends Adapter.extend(BuildURLMixin) {\n  queryRecord(store, type, query) {\n    return new RSVP.Promise(function(resolve, reject) {\n      $.getJSON(`/${type.modelName}`, query).then(function(data) {\n        resolve(data);\n      }, function(jqXHR) {\n        reject(jqXHR);\n      });\n    });\n  }\n}\n```",
      "itemtype": "method",
      "name": "queryRecord",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Subclass of Model"
        },
        {
          "name": "query",
          "description": "",
          "type": "Object"
        },
        {
          "name": "adapterOptions",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 433,
      "description": "If the globally unique IDs for your records should be generated on the client,\nimplement the `generateIdForRecord()` method. This method will be invoked\neach time you create a new record, and the value returned from it will be\nassigned to the record's `primaryKey`.\n\nMost traditional REST-like HTTP APIs will not use this method. Instead, the ID\nof the record will be set by the server, and your adapter will update the store\nwith the new ID when it calls `didCreateRecord()`. Only implement this method if\nyou intend to generate record IDs on the client-side.\n\nThe `generateIdForRecord()` method will be invoked with the requesting store as\nthe first parameter and the newly created record as the second parameter:\n\n```javascript\nimport Adapter from '@ember-data/adapter';\nimport { v4 } from 'uuid';\n\nexport default class ApplicationAdapter extends Adapter {\n  generateIdForRecord(store, type, inputProperties) {\n    return v4();\n  }\n}\n```",
      "itemtype": "method",
      "name": "generateIdForRecord",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "the Model class of the record",
          "type": "Model"
        },
        {
          "name": "inputProperties",
          "description": "a hash of properties to set on the\n  newly created record.",
          "type": "Object"
        }
      ],
      "return": {
        "description": "id",
        "type": "(String|Number)"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 467,
      "description": "Proxies to the serializer's `serialize` method.\n\nExample\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\n\nexport default class ApplicationAdapter extends Adapter {\n  createRecord(store, type, snapshot) {\n    let data = this.serialize(snapshot, { includeId: true });\n    let url = `/${type.modelName}`;\n\n    // ...\n  }\n}\n```",
      "itemtype": "method",
      "name": "serialize",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "serialized snapshot",
        "type": "Object"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 500,
      "description": "Implement this method in a subclass to handle the creation of\nnew records.\n\nSerializes the record and sends it to the server.\n\nExample\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\nimport RSVP from 'RSVP';\nimport $ from 'jquery';\n\nexport default class ApplicationAdapter extends Adapter {\n  createRecord(store, type, snapshot) {\n    let data = this.serialize(snapshot, { includeId: true });\n\n    return new RSVP.Promise(function (resolve, reject) {\n      $.ajax({\n        type: 'POST',\n        url: `/${type.modelName}`,\n        dataType: 'json',\n        data: data\n      }).then(function (data) {\n        resolve(data);\n      }, function (jqXHR) {\n        jqXHR.then = null; // tame jQuery's ill mannered promises\n        reject(jqXHR);\n      });\n    });\n  }\n}\n```",
      "itemtype": "method",
      "name": "createRecord",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "the Model class of the record",
          "type": "Model"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 548,
      "description": "Implement this method in a subclass to handle the updating of\na record.\n\nSerializes the record update and sends it to the server.\n\nThe updateRecord method is expected to return a promise that will\nresolve with the serialized record. This allows the backend to\ninform the Ember Data store the current state of this record after\nthe update. If it is not possible to return a serialized record\nthe updateRecord promise can also resolve with `undefined` and the\nEmber Data store will assume all of the updates were successfully\napplied on the backend.\n\nExample\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\nimport RSVP from 'RSVP';\nimport $ from 'jquery';\n\nexport default class ApplicationAdapter extends Adapter {\n  updateRecord(store, type, snapshot) {\n    let data = this.serialize(snapshot, { includeId: true });\n    let id = snapshot.id;\n\n    return new RSVP.Promise(function(resolve, reject) {\n      $.ajax({\n        type: 'PUT',\n        url: `/${type.modelName}/${id}`,\n        dataType: 'json',\n        data: data\n      }).then(function(data) {\n        resolve(data);\n      }, function(jqXHR) {\n        jqXHR.then = null; // tame jQuery's ill mannered promises\n        reject(jqXHR);\n      });\n    });\n  }\n}\n```",
      "itemtype": "method",
      "name": "updateRecord",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "the Model class of the record",
          "type": "Model"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 605,
      "description": "Implement this method in a subclass to handle the deletion of\na record.\n\nSends a delete request for the record to the server.\n\nExample\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\nimport RSVP from 'RSVP';\nimport $ from 'jquery';\n\nexport default class ApplicationAdapter extends Adapter {\n  deleteRecord(store, type, snapshot) {\n    let data = this.serialize(snapshot, { includeId: true });\n    let id = snapshot.id;\n\n    return new RSVP.Promise(function(resolve, reject) {\n      $.ajax({\n        type: 'DELETE',\n        url: `/${type.modelName}/${id}`,\n        dataType: 'json',\n        data: data\n      }).then(function(data) {\n        resolve(data)\n      }, function(jqXHR) {\n        jqXHR.then = null; // tame jQuery's ill mannered promises\n        reject(jqXHR);\n      });\n    });\n  }\n}\n```",
      "itemtype": "method",
      "name": "deleteRecord",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "the Model class of the record",
          "type": "Model"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 654,
      "description": "By default the store will try to coalesce all `findRecord` calls within the same runloop\ninto as few requests as possible by calling groupRecordsForFindMany and passing it into a findMany call.\nYou can opt out of this behaviour by either not implementing the findMany hook or by setting\ncoalesceFindRequests to false.",
      "itemtype": "property",
      "name": "coalesceFindRequests",
      "access": "public",
      "tagname": "",
      "type": "{boolean}",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 676,
      "description": "The store will call `findMany` instead of multiple `findRecord`\nrequests to find multiple records at once if coalesceFindRequests\nis true.\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\nimport RSVP from 'RSVP';\nimport $ from 'jquery';\n\nexport default class ApplicationAdapter extends Adapter {\n  findMany(store, type, ids, snapshots) {\n    return new RSVP.Promise(function(resolve, reject) {\n      $.ajax({\n        type: 'GET',\n        url: `/${type.modelName}/`,\n        dataType: 'json',\n        data: { filter: { id: ids.join(',') } }\n      }).then(function(data) {\n        resolve(data);\n      }, function(jqXHR) {\n        jqXHR.then = null; // tame jQuery's ill mannered promises\n        reject(jqXHR);\n      });\n    });\n  }\n}\n```",
      "itemtype": "method",
      "name": "findMany",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "the Model class of the records",
          "type": "Model"
        },
        {
          "name": "ids",
          "description": "",
          "type": "Array"
        },
        {
          "name": "snapshots",
          "description": "",
          "type": "Array"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 714,
      "description": "Organize records into groups, each of which is to be passed to separate\ncalls to `findMany`.\n\nFor example, if your API has nested URLs that depend on the parent, you will\nwant to group records by their parent.\n\nThe default implementation returns the records as a single group.",
      "itemtype": "method",
      "name": "groupRecordsForFindMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "snapshots",
          "description": "",
          "type": "Array"
        }
      ],
      "return": {
        "description": "an array of arrays of records, each of which is to be\n                  loaded separately by `findMany`.",
        "type": "Array"
      },
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 734,
      "description": "This method is used by the store to determine if the store should\nreload a record from the adapter when a record is requested by\n`store.findRecord`.\n\nIf this method returns `true`, the store will re-fetch a record from\nthe adapter. If this method returns `false`, the store will resolve\nimmediately using the cached record.\n\nFor example, if you are building an events ticketing system, in which users\ncan only reserve tickets for 20 minutes at a time, and want to ensure that\nin each route you have data that is no more than 20 minutes old you could\nwrite:\n\n```javascript\nshouldReloadRecord(store, ticketSnapshot) {\n  let lastAccessedAt = ticketSnapshot.attr('lastAccessedAt');\n  let timeDiff = moment().diff(lastAccessedAt, 'minutes');\n\n  if (timeDiff > 20) {\n    return true;\n  } else {\n    return false;\n  }\n}\n```\n\nThis method would ensure that whenever you do `store.findRecord('ticket',\nid)` you will always get a ticket that is no more than 20 minutes old. In\ncase the cached version is more than 20 minutes old, `findRecord` will not\nresolve until you fetched the latest version.\n\nBy default this hook returns `false`, as most UIs should not block user\ninteractions while waiting on data update.\n\nNote that, with default settings, `shouldBackgroundReloadRecord` will always\nre-fetch the records in the background even if `shouldReloadRecord` returns\n`false`. You can override `shouldBackgroundReloadRecord` if this does not\nsuit your use case.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "shouldReloadRecord",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 785,
      "description": "This method is used by the store to determine if the store should\nreload all records from the adapter when records are requested by\n`store.findAll`.\n\nIf this method returns `true`, the store will re-fetch all records from\nthe adapter. If this method returns `false`, the store will resolve\nimmediately using the cached records.\n\nFor example, if you are building an events ticketing system, in which users\ncan only reserve tickets for 20 minutes at a time, and want to ensure that\nin each route you have data that is no more than 20 minutes old you could\nwrite:\n\n```javascript\nshouldReloadAll(store, snapshotArray) {\n  let snapshots = snapshotArray.snapshots();\n\n  return snapshots.any((ticketSnapshot) => {\n    let lastAccessedAt = ticketSnapshot.attr('lastAccessedAt');\n    let timeDiff = moment().diff(lastAccessedAt, 'minutes');\n\n    if (timeDiff > 20) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n```\n\nThis method would ensure that whenever you do `store.findAll('ticket')` you\nwill always get a list of tickets that are no more than 20 minutes old. In\ncase a cached version is more than 20 minutes old, `findAll` will not\nresolve until you fetched the latest versions.\n\nBy default, this method returns `true` if the passed `snapshotRecordArray`\nis empty (meaning that there are no records locally available yet),\notherwise, it returns `false`.\n\nNote that, with default settings, `shouldBackgroundReloadAll` will always\nre-fetch all the records in the background even if `shouldReloadAll` returns\n`false`. You can override `shouldBackgroundReloadAll` if this does not suit\nyour use case.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "shouldReloadAll",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "snapshotRecordArray",
          "description": "",
          "type": "SnapshotRecordArray"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 841,
      "description": "This method is used by the store to determine if the store should\nreload a record after the `store.findRecord` method resolves a\ncached record.\n\nThis method is *only* checked by the store when the store is\nreturning a cached record.\n\nIf this method returns `true` the store will re-fetch a record from\nthe adapter.\n\nFor example, if you do not want to fetch complex data over a mobile\nconnection, or if the network is down, you can implement\n`shouldBackgroundReloadRecord` as follows:\n\n```javascript\nshouldBackgroundReloadRecord(store, snapshot) {\n  let { downlink, effectiveType } = navigator.connection;\n\n  return downlink > 0 && effectiveType === '4g';\n}\n```\n\nBy default, this hook returns `true` so the data for the record is updated\nin the background.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "shouldBackgroundReloadRecord",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/index.ts",
      "line": 878,
      "description": "This method is used by the store to determine if the store should\nreload a record array after the `store.findAll` method resolves\nwith a cached record array.\n\nThis method is *only* checked by the store when the store is\nreturning a cached record array.\n\nIf this method returns `true` the store will re-fetch all records\nfrom the adapter.\n\nFor example, if you do not want to fetch complex data over a mobile\nconnection, or if the network is down, you can implement\n`shouldBackgroundReloadAll` as follows:\n\n```javascript\nshouldBackgroundReloadAll(store, snapshotArray) {\n  let { downlink, effectiveType } = navigator.connection;\n\n  return downlink > 0 && effectiveType === '4g';\n}\n```\n\nBy default this method returns `true`, indicating that a background reload\nshould always be triggered.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "shouldBackgroundReloadAll",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "snapshotRecordArray",
          "description": "",
          "type": "SnapshotRecordArray"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "access": "public",
      "tagname": "",
      "class": "Adapter",
      "module": "@ember-data/adapter"
    },
    {
      "file": "../packages/adapter/src/json-api.ts",
      "line": 164,
      "itemtype": "method",
      "name": "ajaxOptions",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "url",
          "description": "",
          "type": "String"
        },
        {
          "name": "type",
          "description": "The request type GET, POST, PUT, DELETE etc.",
          "type": "String"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "JSONAPIAdapter",
      "module": "@ember-data/adapter/json-api"
    },
    {
      "file": "../packages/adapter/src/json-api.ts",
      "line": 184,
      "description": "By default the JSONAPIAdapter will send each find request coming from a `store.find`\nor from accessing a relationship separately to the server. If your server supports passing\nids as a query string, you can set coalesceFindRequests to true to coalesce all find requests\nwithin a single runloop.\n\nFor example, if you have an initial payload of:\n\n```javascript\n{\n  data: {\n    id: 1,\n    type: 'post',\n    relationship: {\n      comments: {\n        data: [\n          { id: 1, type: 'comment' },\n          { id: 2, type: 'comment' }\n        ]\n      }\n    }\n  }\n}\n```\n\nBy default calling `post.comments` will trigger the following requests(assuming the\ncomments haven't been loaded before):\n\n```\nGET /comments/1\nGET /comments/2\n```\n\nIf you set coalesceFindRequests to `true` it will instead trigger the following request:\n\n```\nGET /comments?filter[id]=1,2\n```\n\nSetting coalesceFindRequests to `true` also works for `store.find` requests and `belongsTo`\nrelationships accessed within the same runloop. If you set `coalesceFindRequests: true`\n\n```javascript\nstore.findRecord('comment', 1);\nstore.findRecord('comment', 2);\n```\n\nwill also send a request to: `GET /comments?filter[id]=1,2`\n\nNote: Requests coalescing rely on URL building strategy. So if you override `buildURL` in your app\n`groupRecordsForFindMany` more likely should be overridden as well in order for coalescing to work.",
      "itemtype": "property",
      "name": "coalesceFindRequests",
      "access": "public",
      "tagname": "",
      "type": "{boolean}",
      "class": "JSONAPIAdapter",
      "module": "@ember-data/adapter/json-api"
    },
    {
      "file": "../packages/adapter/src/json-api.ts",
      "line": 273,
      "description": "Used by `findAll` and `findRecord` to build the query's `data` hash\nsupplied to the ajax method.",
      "itemtype": "method",
      "name": "buildQuery",
      "since": "2.5.0",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "JSONAPIAdapter",
      "module": "@ember-data/adapter/json-api"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 303,
      "description": "This property allows ajax to still be used instead when `false`.",
      "itemtype": "property",
      "name": "useFetch",
      "type": "{Boolean}",
      "default": "true",
      "access": "public",
      "tagname": "",
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 330,
      "description": "By default, the RESTAdapter will send the query params sorted alphabetically to the\nserver.\n\nFor example:\n\n```js\nstore.query('posts', { sort: 'price', category: 'pets' });\n```\n\nwill generate a requests like this `/posts?category=pets&sort=price`, even if the\nparameters were specified in a different order.\n\nThat way the generated URL will be deterministic and that simplifies caching mechanisms\nin the backend.\n\nSetting `sortQueryParams` to a falsey value will respect the original order.\n\nIn case you want to sort the query parameters with a different criteria, set\n`sortQueryParams` to your custom sort function.\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  sortQueryParams(params) {\n    let sortedKeys = Object.keys(params).sort().reverse();\n    let len = sortedKeys.length, newParams = {};\n\n    for (let i = 0; i < len; i++) {\n      newParams[sortedKeys[i]] = params[sortedKeys[i]];\n    }\n\n    return newParams;\n  }\n}\n```",
      "itemtype": "method",
      "name": "sortQueryParams",
      "params": [
        {
          "name": "obj",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "access": "public",
      "tagname": "",
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 388,
      "description": "By default the RESTAdapter will send each find request coming from a `store.find`\nor from accessing a relationship separately to the server. If your server supports passing\nids as a query string, you can set coalesceFindRequests to true to coalesce all find requests\nwithin a single runloop.\n\nFor example, if you have an initial payload of:\n\n```javascript\n{\n  post: {\n    id: 1,\n    comments: [1, 2]\n  }\n}\n```\n\nBy default calling `post.comments` will trigger the following requests(assuming the\ncomments haven't been loaded before):\n\n```\nGET /comments/1\nGET /comments/2\n```\n\nIf you set coalesceFindRequests to `true` it will instead trigger the following request:\n\n```\nGET /comments?ids[]=1&ids[]=2\n```\n\nSetting coalesceFindRequests to `true` also works for `store.find` requests and `belongsTo`\nrelationships accessed within the same runloop. If you set `coalesceFindRequests: true`\n\n```javascript\nstore.findRecord('comment', 1);\nstore.findRecord('comment', 2);\n```\n\nwill also send a request to: `GET /comments?ids[]=1&ids[]=2`\n\nNote: Requests coalescing rely on URL building strategy. So if you override `buildURL` in your app\n`groupRecordsForFindMany` more likely should be overridden as well in order for coalescing to work.",
      "itemtype": "property",
      "name": "coalesceFindRequests",
      "access": "public",
      "tagname": "",
      "type": "{boolean}",
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 448,
      "description": "Endpoint paths can be prefixed with a `namespace` by setting the namespace\nproperty on the adapter:\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  namespace = 'api/1';\n}\n```\n\nRequests for the `Post` model would now target `/api/1/post/`.",
      "itemtype": "property",
      "name": "namespace",
      "access": "public",
      "tagname": "",
      "type": "{String}",
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 467,
      "description": "An adapter can target other hosts by setting the `host` property.\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  host = 'https://api.example.com';\n}\n```\n\nRequests for the `Post` model would now target `https://api.example.com/post/`.",
      "itemtype": "property",
      "name": "host",
      "access": "public",
      "tagname": "",
      "type": "{String}",
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 485,
      "description": "Some APIs require HTTP headers, e.g. to provide an API\nkey. Arbitrary headers can be set as key/value pairs on the\n`RESTAdapter`'s `headers` object and Ember Data will send them\nalong with each ajax request. For dynamic headers see [headers\ncustomization](/ember-data/release/classes/RESTAdapter).\n\n```app/adapters/application.js\nimport RESTAdapter from '@ember-data/adapter/rest';\n\nexport default class ApplicationAdapter extends RESTAdapter {\n  get headers() {\n    return {\n      'API_KEY': 'secret key',\n      'ANOTHER_HEADER': 'Some header value'\n    };\n  }\n}\n```",
      "itemtype": "property",
      "name": "headers",
      "access": "public",
      "tagname": "",
      "type": "{Object}",
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 511,
      "description": "Called by the store in order to fetch the JSON for a given\ntype and ID.\n\nThe `findRecord` method makes an Ajax request to a URL computed by\n`buildURL`, and returns a promise for the resulting payload.\n\nThis method performs an HTTP `GET` request with the id provided as part of the query string.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "findRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "id",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 536,
      "description": "Called by the store in order to fetch a JSON array for all\nof the records for a given type.\n\nThe `findAll` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a\npromise for the resulting payload.",
      "itemtype": "method",
      "name": "findAll",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "neverSet",
          "description": "a value is never provided to this argument",
          "type": "Undefined"
        },
        {
          "name": "snapshotRecordArray",
          "description": "",
          "type": "SnapshotRecordArray"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 567,
      "description": "Called by the store in order to fetch a JSON array for\nthe records that match a particular query.\n\nThe `query` method makes an Ajax (HTTP GET) request to a URL\ncomputed by `buildURL`, and returns a promise for the resulting\npayload.\n\nThe `query` argument is a simple JavaScript object that will be passed directly\nto the server as parameters.",
      "itemtype": "method",
      "name": "query",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "query",
          "description": "",
          "type": "Object"
        },
        {
          "name": "recordArray",
          "description": "",
          "type": "Collection"
        },
        {
          "name": "adapterOptions",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 597,
      "description": "Called by the store in order to fetch a JSON object for\nthe record that matches a particular query.\n\nThe `queryRecord` method makes an Ajax (HTTP GET) request to a URL\ncomputed by `buildURL`, and returns a promise for the resulting\npayload.\n\nThe `query` argument is a simple JavaScript object that will be passed directly\nto the server as parameters.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "queryRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "query",
          "description": "",
          "type": "Object"
        },
        {
          "name": "adapterOptions",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 632,
      "description": "Called by the store in order to fetch several records together if `coalesceFindRequests` is true\n\nFor example, if the original payload looks like:\n\n```js\n{\n  \"id\": 1,\n  \"title\": \"Rails is omakase\",\n  \"comments\": [ 1, 2, 3 ]\n}\n```\n\nThe IDs will be passed as a URL-encoded Array of IDs, in this form:\n\n```\nids[]=1&ids[]=2&ids[]=3\n```\n\nMany servers, such as Rails and PHP, will automatically convert this URL-encoded array\ninto an Array for you on the server-side. If you want to encode the\nIDs, differently, just override this (one-line) method.\n\nThe `findMany` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a\npromise for the resulting payload.",
      "itemtype": "method",
      "name": "findMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "ids",
          "description": "",
          "type": "Array"
        },
        {
          "name": "snapshots",
          "description": "",
          "type": "Array"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 671,
      "description": "Called by the store in order to fetch a JSON array for\nthe unloaded records in a has-many relationship that were originally\nspecified as a URL (inside of `links`).\n\nFor example, if your original payload looks like this:\n\n```js\n{\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Rails is omakase\",\n    \"links\": { \"comments\": \"/posts/1/comments\" }\n  }\n}\n```\n\nThis method will be called with the parent record and `/posts/1/comments`.\n\nThe `findHasMany` method will make an Ajax (HTTP GET) request to the originally specified URL.\n\nThe format of your `links` value will influence the final request URL via the `urlPrefix` method:\n\n* Links beginning with `//`, `http://`, `https://`, will be used as is, with no further manipulation.\n\n* Links beginning with a single `/` will have the current adapter's `host` value prepended to it.\n\n* Links with no beginning `/` will have a parentURL prepended to it, via the current adapter's `buildURL`.",
      "itemtype": "method",
      "name": "findHasMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "url",
          "description": "",
          "type": "String"
        },
        {
          "name": "relationship",
          "description": "meta object describing the relationship",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 726,
      "description": "Called by the store in order to fetch the JSON for the unloaded record in a\nbelongs-to relationship that was originally specified as a URL (inside of\n`links`).\n\nFor example, if your original payload looks like this:\n\n```js\n{\n  \"person\": {\n    \"id\": 1,\n    \"name\": \"Tom Dale\",\n    \"links\": { \"group\": \"/people/1/group\" }\n  }\n}\n```\n\nThis method will be called with the parent record and `/people/1/group`.\n\nThe `findBelongsTo` method will make an Ajax (HTTP GET) request to the originally specified URL.\n\nThe format of your `links` value will influence the final request URL via the `urlPrefix` method:\n\n* Links beginning with `//`, `http://`, `https://`, will be used as is, with no further manipulation.\n\n* Links beginning with a single `/` will have the current adapter's `host` value prepended to it.\n\n* Links with no beginning `/` will have a parentURL prepended to it, via the current adapter's `buildURL`.",
      "itemtype": "method",
      "name": "findBelongsTo",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "url",
          "description": "",
          "type": "String"
        },
        {
          "name": "relationship",
          "description": "meta object describing the relationship",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 775,
      "description": "Called by the store when a newly created record is\nsaved via the `save` method on a model record instance.\n\nThe `createRecord` method serializes the record and makes an Ajax (HTTP POST) request\nto a URL computed by `buildURL`.\n\nSee `serialize` for information on how to customize the serialized form\nof a record.",
      "itemtype": "method",
      "name": "createRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 800,
      "description": "Called by the store when an existing record is saved\nvia the `save` method on a model record instance.\n\nThe `updateRecord` method serializes the record and makes an Ajax (HTTP PUT) request\nto a URL computed by `buildURL`.\n\nSee `serialize` for information on how to customize the serialized form\nof a record.",
      "itemtype": "method",
      "name": "updateRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "",
          "type": "Model"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 827,
      "description": "Called by the store when a record is deleted.\n\nThe `deleteRecord` method  makes an Ajax (HTTP DELETE) request to a URL computed by `buildURL`.",
      "itemtype": "method",
      "name": "deleteRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "Model"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 877,
      "description": "Organize records into groups, each of which is to be passed to separate\ncalls to `findMany`.\n\nThis implementation groups together records that have the same base URL but\ndiffering ids. For example `/comments/1` and `/comments/2` will be grouped together\nbecause we know findMany can coalesce them together as `/comments?ids[]=1&ids[]=2`\n\nIt also supports urls where ids are passed as a query param, such as `/comments?id=1`\nbut not those where there is more than 1 query param such as `/comments?id=2&name=David`\nCurrently only the query param of `id` is supported. If you need to support others, please\noverride this or the `_stripIDFromURL` method.\n\nIt does not group records that have differing base urls, such as for example: `/posts/1/comments/2`\nand `/posts/2/comments/3`",
      "itemtype": "method",
      "name": "groupRecordsForFindMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "snapshots",
          "description": "",
          "type": "Array"
        }
      ],
      "return": {
        "description": "an array of arrays of records, each of which is to be\n                  loaded separately by `findMany`.",
        "type": "Array"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 924,
      "description": "Takes an ajax response, and returns the json payload or an error.\n\nBy default this hook just returns the json payload passed to it.\nYou might want to override it in two cases:\n\n1. Your API might return useful results in the response headers.\nResponse headers are passed in as the second argument.\n\n2. Your API might return errors as successful responses with status code\n200 and an Errors text or object. You can return a `InvalidError` or a\n`AdapterError` (or a sub class) from this hook and it will automatically\nreject the promise and put your record into the invalid or error state.\n\nReturning a `InvalidError` from this method will cause the\nrecord to transition into the `invalid` state and make the\n`errors` object available on the record. When returning an\n`InvalidError` the store will attempt to normalize the error data\nreturned from the server using the serializer's `extractErrors`\nmethod.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "handleResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "status",
          "description": "",
          "type": "Number"
        },
        {
          "name": "headers",
          "description": "",
          "type": "Object"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "requestData",
          "description": "- the original request information",
          "type": "Object"
        }
      ],
      "return": {
        "description": "response",
        "type": "Object | AdapterError"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 987,
      "description": "Default `handleResponse` implementation uses this hook to decide if the\nresponse is a success.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "isSuccess",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "status",
          "description": "",
          "type": "Number"
        },
        {
          "name": "headers",
          "description": "",
          "type": "Object"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 1003,
      "description": "Default `handleResponse` implementation uses this hook to decide if the\nresponse is an invalid error.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "isInvalid",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "status",
          "description": "",
          "type": "Number"
        },
        {
          "name": "headers",
          "description": "",
          "type": "Object"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 1019,
      "description": "Takes a URL, an HTTP method and a hash of data, and makes an\nHTTP request.\n\nWhen the server responds with a payload, Ember Data will call into `extractSingle`\nor `extractArray` (depending on whether the original query was for one record or\nmany records).\n\nBy default, `ajax` method has the following behavior:\n\n* It sets the response `dataType` to `\"json\"`\n* If the HTTP method is not `\"GET\"`, it sets the `Content-Type` to be\n  `application/json; charset=utf-8`\n* If the HTTP method is not `\"GET\"`, it stringifies the data passed in. The\n  data is the serialized record in the case of a save.\n* Registers success and failure handlers.",
      "itemtype": "method",
      "name": "ajax",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "url",
          "description": "",
          "type": "String"
        },
        {
          "name": "type",
          "description": "The request type GET, POST, PUT, DELETE etc.",
          "type": "String"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 1066,
      "itemtype": "method",
      "name": "_ajaxRequest",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "jQuery ajax options to be used for the ajax request",
          "type": "Object"
        }
      ],
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 1090,
      "itemtype": "method",
      "name": "ajaxOptions",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "url",
          "description": "",
          "type": "String"
        },
        {
          "name": "type",
          "description": "The request type GET, POST, PUT, DELETE etc.",
          "type": "String"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 1171,
      "itemtype": "method",
      "name": "parseErrorResponse",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "responseText",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 1189,
      "itemtype": "method",
      "name": "normalizeErrorResponse",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "status",
          "description": "",
          "type": "Number"
        },
        {
          "name": "headers",
          "description": "",
          "type": "Object"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "errors payload",
        "type": "Array"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 1219,
      "description": "Generates a detailed (\"friendly\") error message, with plenty\nof information for debugging (good luck!)",
      "itemtype": "method",
      "name": "generatedDetailedMessage",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "status",
          "description": "",
          "type": "Number"
        },
        {
          "name": "headers",
          "description": "",
          "type": "Object"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "requestData",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "detailed error message",
        "type": "String"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 1258,
      "description": "Used by `findAll` and `findRecord` to build the query's `data` hash\nsupplied to the ajax method.",
      "itemtype": "method",
      "name": "buildQuery",
      "since": "2.5.0",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "RESTAdapter",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/adapter/src/rest.ts",
      "line": 1448,
      "description": "Helper function that translates the options passed to `jQuery.ajax` into a format that `fetch` expects.",
      "itemtype": "method",
      "name": "fetchOptions",
      "params": [
        {
          "name": "_options",
          "description": "",
          "type": "Object"
        },
        {
          "name": "adapter",
          "description": "",
          "type": "Adapter"
        }
      ],
      "access": "private",
      "tagname": "",
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "@ember-data/adapter/rest",
      "module": "@ember-data/adapter/rest"
    },
    {
      "file": "../packages/build-config/src/canary-features.ts",
      "line": 91,
      "description": "This upcoming feature adds a validation step to payloads received\nby the JSONAPICache implementation.\n\nWhen a request completes and the result is given to the cache via\n`cache.put`, the cache will validate the payload against registered\nschemas as well as the JSON:API spec.",
      "itemtype": "property",
      "name": "JSON_API_CACHE_VALIDATION_ERRORS",
      "since": "5.4",
      "access": "public",
      "tagname": "",
      "class": "CanaryFeatures",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/debugging.ts",
      "line": 30,
      "description": "log cache updates for both local\nand remote state.",
      "itemtype": "property",
      "name": "LOG_CACHE",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "DebugLogging",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/debugging.ts",
      "line": 39,
      "description": "log notifications received by the NotificationManager",
      "itemtype": "property",
      "name": "LOG_NOTIFICATIONS",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "DebugLogging",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/debugging.ts",
      "line": 46,
      "description": "log requests issued by the RequestManager",
      "itemtype": "property",
      "name": "LOG_REQUESTS",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "DebugLogging",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/debugging.ts",
      "line": 53,
      "description": "log updates to requests the store has issued to\nthe network (adapter) to fulfill.",
      "itemtype": "property",
      "name": "LOG_REQUEST_STATUS",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "DebugLogging",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/debugging.ts",
      "line": 61,
      "description": "log peek, generation and updates to\nRecord Identifiers.",
      "itemtype": "property",
      "name": "LOG_IDENTIFIERS",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "DebugLogging",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/debugging.ts",
      "line": 69,
      "description": "log updates received by the graph (relationship pointer storage)",
      "itemtype": "property",
      "name": "LOG_GRAPH",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "DebugLogging",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/debugging.ts",
      "line": 76,
      "description": "log creation/removal of RecordData and Record\ninstances.",
      "itemtype": "property",
      "name": "LOG_INSTANCE_CACHE",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "DebugLogging",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/debugging.ts",
      "line": 84,
      "description": "Log key count metrics, useful for performance\ndebugging.",
      "itemtype": "property",
      "name": "LOG_METRIC_COUNTS",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "DebugLogging",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/debugging.ts",
      "line": 92,
      "description": "Helps when debugging causes of a change notification\nwhen processing an update to a hasMany relationship.",
      "itemtype": "property",
      "name": "DEBUG_RELATIONSHIP_NOTIFICATIONS",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "DebugLogging",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 66,
      "description": "**id: ember-data:deprecate-non-strict-types**\n\nCurrently, EmberData expects that the `type` property associated with\na resource follows several conventions.\n\n- The `type` property must be a non-empty string\n- The `type` property must be singular\n- The `type` property must be dasherized\n\nWe are deprecating support for types that do not match this pattern\nin order to unlock future improvements in which we can support `type`\nbeing any string of your choosing.\n\nThe goal is that in the future, you will be able to use any string\nso long as it matches what your configured cache, identifier generation,\nand schemas expect.\n\nE.G. It will matter not that your string is in a specific format like\nsingular, dasherized, etc. so long as everywhere you refer to the type\nyou use the same string.\n\nIf using @ember-data/model, there will always be a restriction that the\n`type` must match the path on disk where the model is defined.\n\ne.g. `app/models/foo/bar-bem.js` must have a type of `foo/bar-bem`",
      "itemtype": "property",
      "name": "DEPRECATE_NON_STRICT_TYPES",
      "since": "5.3",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 100,
      "description": "**id: ember-data:deprecate-non-strict-id**\n\nCurrently, EmberData expects that the `id` property associated with\na resource is a string.\n\nHowever, for legacy support in many locations we would accept a number\nwhich would then immediately be coerced into a string.\n\nWe are deprecating this legacy support for numeric IDs.\n\nThe goal is that in the future, you will be able to use any ID format\nso long as everywhere you refer to the ID you use the same format.\n\nHowever, for identifiers we will always use string IDs and so any\ncustom identifier configuration should provide a string ID.",
      "itemtype": "property",
      "name": "DEPRECATE_NON_STRICT_ID",
      "since": "5.3",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 124,
      "description": "**id: <none yet assigned>**\n\nThis is a planned deprecation which will trigger when observer or computed\nchains are used to watch for changes on any EmberData LiveArray, CollectionRecordArray,\nManyArray or PromiseManyArray.\n\nSupport for these chains is currently guarded by the deprecation flag\nlisted here, enabling removal of the behavior if desired.",
      "itemtype": "property",
      "name": "DEPRECATE_COMPUTED_CHAINS",
      "since": "5.0",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 141,
      "description": "**id: ember-data:deprecate-legacy-imports**\n\nDeprecates when importing from `ember-data/*` instead of `@ember-data/*`\nin order to prepare for the eventual removal of the legacy `ember-data/*`\n\nAll imports from `ember-data/*` should be updated to `@ember-data/*`\nexcept for `ember-data/store`. When you are using `ember-data` (as opposed to\ninstalling the indivudal packages) you should import from `ember-data/store`\ninstead of `@ember-data/store` in order to receive the appropriate configuration\nof defaults.",
      "itemtype": "property",
      "name": "DEPRECATE_LEGACY_IMPORTS",
      "since": "5.3",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 160,
      "description": "**id: ember-data:deprecate-non-unique-collection-payloads**\n\nDeprecates when the data for a hasMany relationship contains\nduplicate identifiers.\n\nPreviously, relationships would silently de-dupe the data\nwhen received, but this behavior is being removed in favor\nof erroring if the same related record is included multiple\ntimes.\n\nFor instance, in JSON:API the below relationship data would\nbe considered invalid:\n\n```json\n{\n \"data\": {\n  \"type\": \"article\",\n   \"id\": \"1\",\n   \"relationships\": {\n     \"comments\": {\n       \"data\": [\n         { \"type\": \"comment\", \"id\": \"1\" },\n         { \"type\": \"comment\", \"id\": \"2\" },\n         { \"type\": \"comment\", \"id\": \"1\" } // duplicate\n       ]\n    }\n }\n}\n```\n\nTo resolve this deprecation, either update your server to\nnot include duplicate data, or implement normalization logic\nin either a request handler or serializer which removes\nduplicate data from relationship payloads.",
      "itemtype": "property",
      "name": "DEPRECATE_NON_UNIQUE_PAYLOADS",
      "since": "5.3",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 203,
      "description": "**id: ember-data:deprecate-relationship-remote-update-clearing-local-state**\n\nDeprecates when a relationship is updated remotely and the local state\nis cleared of all changes except for \"new\" records.\n\nInstead, any records not present in the new payload will be considered\n\"removed\" while any records present in the new payload will be considered \"added\".\n\nThis allows us to \"commit\" local additions and removals, preserving any additions\nor removals that are not yet reflected in the remote state.\n\nFor instance, given the following initial state:\n\nremote: A, B, C\nlocal: add D, E\n       remove B, C\n=> A, D, E\n\n\nIf after an update, the remote state is now A, B, D, F then the new state will be\n\nremote: A, B, D, F\nlocal: add E\n       remove B\n=> A, D, E, F\n\nUnder the old behavior the updated local state would instead have been\n=> A, B, D, F\n\nSimilarly, if a belongsTo remote State was A while its local state was B,\nthen under the old behavior if the remote state changed to C, the local state\nwould be updated to C. Under the new behavior, the local state would remain B.\n\nIf the remote state was A while its local state was `null`, then under the old\nbehavior if the remote state changed to C, the local state would be updated to C.\nUnder the new behavior, the local state would remain `null`.\n\nThus the new correct mental model is that the state of the relationship at any point\nin time is whatever the most recent remote state is, plus any local additions or removals\nyou have made that have not yet been reflected by the remote state.\n\n> Note: The old behavior extended to modifying the inverse of a relationship. So if\n> you had local state not reflected in the new remote state, inverses would be notified\n> and their state reverted as well when \"resetting\" the relationship.\n> Under the new behavior, since the local state is preserved the inverses will also\n> not be reverted.\n\n### Resolving this deprecation\n\nResolving this deprecation can be done individually for each relationship\nor globally for all relationships.\n\nTo resolve it globally, set the `DEPRECATE_RELATIONSHIP_REMOTE_UPDATE_CLEARING_LOCAL_STATE`\nto `false` in ember-cli-build.js\n\n```js\nconst { setConfig } = await import('@warp-drive/build-config');\n\nlet app = new EmberApp(defaults, {});\n\nsetConfig(app, __dirname, {\n  deprecations: {\n    // set to false to strip the deprecated code (thereby opting into the new behavior)\n    DEPRECATE_RELATIONSHIP_REMOTE_UPDATE_CLEARING_LOCAL_STATE: false\n  }\n});\n```\n\nTo resolve this deprecation on an individual relationship, adjust the `options` passed to\nthe relationship. For relationships with inverses, both sides MUST be migrated to the new\nbehavior at the same time.\n\n```js\nclass Person extends Model {\n @hasMany('person', {\n   async: false,\n   inverse: null,\n   resetOnRemoteUpdate: false\n }) children;\n\n @belongsTo('person', {\n   async: false,\n   inverse: null,\n   resetOnRemoteUpdate: false\n }) parent;\n}\n```\n\n> Note: false is the only valid value here, all other values (including missing)\n> will be treated as true, where `true` is the legacy behavior that is now deprecated.\n\nOnce you have migrated all relationships, you can remove the the resetOnRemoteUpdate\noption and set the deprecation flag to false in ember-cli-build.\n\n### What if I don't want the new behavior?\n\nEmberData's philosophy is to not make assumptions about your application. Where possible\nwe seek out \"100%\" solutions ‚Äì solutions that work for all use cases - and where that is\nnot possible we default to \"90%\" solutions ‚Äì solutions that work for the vast majority of use\ncases. In the case of \"90%\" solutions we look for primitives that allow you to resolve the\n10% case in your application. If no such primitives exist, we provide an escape hatch that\nensures you can build the behavior you need without adopting the cost of the default solution.\n\nIn this case, the old behavior was a \"40%\" solution. The inability for an application developer\nto determine what changes were made locally, and thus what changes should be preserved, made\nit impossible to build certain features easily, or in some cases at all. The proliferation of\nfeature requests, bug reports (from folks surprised by the prior behavior) and addon attempts\nin this space are all evidence of this.\n\nWe believe the new behavior is a \"90%\" solution. It works for the vast majority of use cases,\noften without noticeable changes to existing application behavior, and provides primitives that\nallow you to build the behavior you need for the remaining 10%.\n\nThe great news is that this behavior defaults to trusting your API similar to the old behavior.\nIf your API is correct, you will not need to make any changes to your application to adopt\nthe new behavior.\n\nThis means the 10% cases are those where you can't trust your API to provide the correct\ninformation. In these cases, because you now have cheap access to a diff of the relationship\nstate, there are a few options that weren't available before:\n\n- you can adjust returned API payloads to contain the expected changes that it doesn't include\n- you can modify local state by adding or removing records on the HasMany record array to remove\n  any local changes that were not returned by the API.\n- you can use `<Cache>.mutate(mutation)` to directly modify the local cache state of the relationship\n  to match the expected state.\n\nWhat this version (5.3) does not yet provide is a way to directly modify the cache's remote state\nfor the relationship via public APIs other than via the broader action of upserting a response via\n`<Cache>.put(document)`. However, such an API was sketched in the Cache 2.1 RFC\n`<Cache>.patch(operation)` and is likely to be added in a future 5.x release of EmberData.\n\nThis version (5.3) also does not yet provide a way to directly modify the graph (a general purpose\nsubset of cache behaviors specific to relationships) via public APIs. However, during the\n5.x release series we will be working on finalizing the Graph API and making it public.\n\nIf none of these options work for you, you can always opt-out more broadly by implementing\na custom Cache with the relationship behaviors you need.",
      "itemtype": "property",
      "name": "DEPRECATE_RELATIONSHIP_REMOTE_UPDATE_CLEARING_LOCAL_STATE",
      "since": "5.3",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 350,
      "description": "**id: ember-data:deprecate-many-array-duplicates**\n\nWhen the flag is `true` (default), adding duplicate records to a `ManyArray`\nis deprecated in non-production environments. In production environments,\nduplicate records added to a `ManyArray` will be deduped and no error will\nbe thrown.\n\nWhen the flag is `false`, an error will be thrown when duplicates are added.",
      "itemtype": "property",
      "name": "DEPRECATE_MANY_ARRAY_DUPLICATES",
      "since": "5.3",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 367,
      "description": "**id: ember-data:deprecate-store-extends-ember-object**\n\nWhen the flag is `true` (default), the Store class will extend from `@ember/object`.\nWhen the flag is `false` or `ember-source` is not present, the Store will not extend\nfrom EmberObject.",
      "itemtype": "property",
      "name": "DEPRECATE_STORE_EXTENDS_EMBER_OBJECT",
      "since": "5.4",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 381,
      "description": "**id: ember-data:schema-service-updates**\n\nWhen the flag is `true` (default), the legacy schema\nservice features will be enabled on the store and\nthe service, and deprecations will be thrown when\nthey are used.\n\nDeprecated features include:\n\n- `Store.registerSchema` method is deprecated in favor of the `Store.createSchemaService` hook\n- `Store.registerSchemaDefinitionService` method is deprecated in favor of the `Store.createSchemaService` hook\n- `Store.getSchemaDefinitionService` method is deprecated in favor of `Store.schema` property\n- `SchemaService.doesTypeExist` method is deprecated in favor of the `SchemaService.hasResource` method\n- `SchemaService.attributesDefinitionFor` method is deprecated in favor of the `SchemaService.fields` method\n- `SchemaService.relationshipsDefinitionFor` method is deprecated in favor of the `SchemaService.fields` method",
      "itemtype": "property",
      "name": "ENABLE_LEGACY_SCHEMA_SERVICE",
      "since": "5.4",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 405,
      "description": "**id: warp-drive.ember-inflector**\n\nDeprecates the use of ember-inflector for pluralization and singularization in favor\nof the `@ember-data/request-utils` package.\n\nRule configuration methods (singular, plural, uncountable, irregular) and\nusage methods (singularize, pluralize) are are available as imports from\n`@ember-data/request-utils/string`\n\nNotable differences with ember-inflector:\n- there cannot be multiple inflector instances with separate rules\n- pluralization does not support a count argument\n- string caches now default to 10k entries instead of 1k, and this\n  size is now configurable. Additionally, the cache is now a LRU cache\n  instead of a first-N cache.\n\nThis deprecation can be resolved by removing usage of ember-inflector or by using\nboth ember-inflector and @ember-data/request-utils in parallel and updating your\nEmberData/WarpDrive build config to mark the deprecation as resolved\nin ember-cli-build\n\n```js\nsetConfig(app, __dirname, { deprecations: { DEPRECATE_EMBER_INFLECTOR: false }});\n```",
      "itemtype": "property",
      "name": "DEPRECATE_EMBER_INFLECTOR",
      "since": "5.3",
      "until": "6.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/build-config/src/deprecation-versions.ts",
      "line": 438,
      "description": "This is a special flag that can be used to opt-in early to receiving deprecations introduced in 6.x\nwhich have had their infra backported to 5.x versions of EmberData.\n\nWhen this flag is not present or set to `true`, the deprecations from the 6.x branch\nwill not print their messages and the deprecation cannot be resolved.\n\nWhen this flag is present and set to `false`, the deprecations from the 6.x branch will\nprint and can be resolved.",
      "itemtype": "property",
      "name": "DISABLE_7X_DEPRECATIONS",
      "since": "5.3",
      "until": "7.0",
      "access": "public",
      "tagname": "",
      "class": "CurrentDeprecations",
      "module": "@warp-drive/build-config"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 24,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'field'",
      "access": "public",
      "tagname": "",
      "class": "<Type> GenericField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 32,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> GenericField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 40,
      "description": "the name of the transform to use, if any",
      "itemtype": "property",
      "name": "type",
      "type": "String | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> GenericField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 48,
      "description": "Options to pass to the transform, if any\n\nMust comply to the specific transform's options\nschema.",
      "itemtype": "property",
      "name": "options",
      "type": "ObjectValue | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> GenericField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 90,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'alias'",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 98,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 106,
      "description": "Always null (for now)",
      "itemtype": "property",
      "name": "type",
      "type": "Null",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 114,
      "description": "The field def for which this is an alias.",
      "itemtype": "property",
      "name": "options",
      "type": "GenericField | ObjectField | SchemaObjectField | ArrayField | SchemaArrayField | LegacyAttributeField | LegacyBelongsToField | LegacyHasManyField",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 163,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'alias'",
      "access": "public",
      "tagname": "",
      "class": "<Type> PolarisAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 171,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> PolarisAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 179,
      "description": "Always null (for now)",
      "itemtype": "property",
      "name": "type",
      "type": "Null",
      "access": "public",
      "tagname": "",
      "class": "<Type> PolarisAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 187,
      "description": "The field def for which this is an alias.",
      "itemtype": "property",
      "name": "options",
      "type": "GenericField | ObjectField | SchemaObjectField | ArrayField | SchemaArrayField | LinksModeBelongsToField | LinksModeHasManyField",
      "access": "public",
      "tagname": "",
      "class": "<Type> PolarisAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 235,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'alias'",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 243,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 251,
      "description": "Always null (for now)",
      "itemtype": "property",
      "name": "type",
      "type": "Null",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 259,
      "description": "The field def for which this is an alias.",
      "itemtype": "property",
      "name": "options",
      "type": "GenericField | ObjectField | SchemaObjectField | ArrayField | SchemaArrayField",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectAliasField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 284,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'@id'",
      "access": "public",
      "tagname": "",
      "class": "<Type> IdentityField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 292,
      "description": "The name of the field that serves as the\nprimary key for the resource.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> IdentityField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 327,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'@hash'",
      "access": "public",
      "tagname": "",
      "class": "<Type> HashField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 335,
      "description": "The name of the field that serves as the\nhash for the resource.\n\nOnly required if access to this value by\nthe UI is desired, it can be `null` otherwise.",
      "itemtype": "property",
      "name": "name",
      "type": "String | null",
      "access": "public",
      "tagname": "",
      "class": "<Type> HashField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 347,
      "description": "The name of a function to run to compute the hash.\nThe function will only have access to the cached\ndata for the record.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> HashField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 357,
      "description": "Any options that should be provided to the hash\nfunction.",
      "itemtype": "property",
      "name": "options",
      "type": "ObjectValue | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> HashField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 398,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'@local'",
      "access": "public",
      "tagname": "",
      "class": "<Type> LocalField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 406,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LocalField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 413,
      "description": "Not currently utilized, we are considering\nallowing transforms to operate on local fields",
      "itemtype": "property",
      "name": "type",
      "type": "String | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> LocalField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 422,
      "description": "Options for the field.",
      "itemtype": "property",
      "name": "options",
      "type": "ObjectValue | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> LocalField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 444,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'object'",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 452,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 460,
      "description": "The name of a transform to pass the entire object\nthrough before displaying or serializing it.",
      "itemtype": "property",
      "name": "type",
      "type": "String | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 469,
      "description": "Options to pass to the transform, if any\n\nMust comply to the specific transform's options\nschema.",
      "itemtype": "property",
      "name": "options",
      "type": "ObjectValue | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 493,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'schema-object'",
      "access": "public",
      "tagname": "",
      "class": "<Type> SchemaObjectField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 501,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> SchemaObjectField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 509,
      "description": "The name of the ObjectSchema that describes the\nstructure of the object.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> SchemaObjectField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 518,
      "description": "Options for configuring the behavior of the\nSchemaObject.\n\n- `polymorphic` : Whether this SchemaObject is Polymorphic.\n- `type` : If the SchemaObject is Polymorphic, the key on the raw cache data to use as the \"resource-type\" value for the schema-object.",
      "itemtype": "property",
      "name": "options",
      "type": "ObjectValue | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> SchemaObjectField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 561,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'array'",
      "access": "public",
      "tagname": "",
      "class": "<Type> ArrayField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 569,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> ArrayField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 577,
      "description": "The name of a transform to pass each item\nin the array through before displaying or\nor serializing it.",
      "itemtype": "property",
      "name": "type",
      "type": "String | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> ArrayField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 587,
      "description": "Options to pass to the transform, if any\n\nMust comply to the specific transform's options\nschema.",
      "itemtype": "property",
      "name": "options",
      "type": "ObjectValue | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> ArrayField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 611,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'schema-array'",
      "access": "public",
      "tagname": "",
      "class": "<Type> SchemaArrayField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 619,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> SchemaArrayField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 627,
      "description": "The name of the ObjectSchema that describes the\nstructure of the objects in the array.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> SchemaArrayField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 636,
      "description": "Options for configuring the behavior of the\nSchemaArray.\n\n- `key`\n\nConfigures how the SchemaArray determines whether an object in the cache is the same\nas an object previously used to instantiate one of the schema-objects it contains.\n\nThe default is `'@identity'`.\n\nValid options are:\n\n- `'@identity'` (default) : the cached object's referential identity will be used.\n      This may result in significant instability when resource data is updated from the API\n- `'@index'`              : the cached object's index in the array will be used.\n      This is only a good choice for arrays that rarely if ever change membership\n- `'@hash'`               : will lookup the `@hash` function supplied in the ResourceSchema for\n      The contained schema-object and use the computed result to determine and compare identity.\n- <field-name> (string)   : the name of a field to use as the key, only GenericFields (kind `field`)\n      Are valid field names for this purpose. The cache state without transforms applied will be\n      used when comparing values. The field value should be unique enough to guarantee two schema-objects\n      of the same type will not collide.\n\n- `polymorphic` : Whether this SchemaArray is Polymorphic.\n- `type` : If the SchemaArray is Polymorphic, the key on the raw cache data to use as the \"resource-type\" value for the schema-object.",
      "itemtype": "property",
      "name": "options",
      "type": "ObjectValue | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> SchemaArrayField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 731,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'derived'",
      "access": "public",
      "tagname": "",
      "class": "<Type> DerivedField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 739,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> DerivedField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 747,
      "description": "The name of the derivation to use.\n\nDerivations are functions that take the\nrecord, options, and the name of the field\nas arguments, and return the derived value.\n\nDerivations are memoized, and are only\nrecomputed when the fields they depend on\nchange.\n\nDerivations are not stored in the cache,\nand are not sent to the server.\n\nDerivation functions must be explicitly\nregistered with the schema service.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> DerivedField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 769,
      "description": "Options to pass to the derivation, if any\n\nMust comply to the specific derivation's\noptions schema.",
      "itemtype": "property",
      "name": "options",
      "type": "ObjectValue | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> DerivedField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 792,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'resource'",
      "access": "public",
      "tagname": "",
      "class": "<Type> ResourceField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 800,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> ResourceField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 808,
      "description": "The name of the resource that this field\nrefers to. In the case of a polymorphic\nrelationship, this should be the trait\nor abstract type.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> ResourceField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 819,
      "description": "Options for resources are optional. If\nnot present, all options are presumed\nto be falsey",
      "itemtype": "property",
      "name": "options",
      "type": "ObjectValue | undefined",
      "access": "public",
      "tagname": "",
      "class": "<Type> ResourceField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 886,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'collection'",
      "access": "public",
      "tagname": "",
      "class": "<Type> CollectionField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 894,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> CollectionField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 902,
      "description": "The name of the resource that this field\nrefers to. In the case of a polymorphic\nrelationship, this should be the trait\nor abstract type.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> CollectionField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 997,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'attribute'",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyAttributeField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1005,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyAttributeField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1012,
      "description": "The name of the transform to use, if any",
      "itemtype": "property",
      "name": "type",
      "type": "String | undefined | null",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyAttributeField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1043,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'belongsTo'",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyBelongsToField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1051,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyBelongsToField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1059,
      "description": "The name of the resource that this field\nrefers to. In the case of a polymorphic\nrelationship, this should be the trait\nor abstract type.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyBelongsToField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1186,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'belongsTo'",
      "access": "public",
      "tagname": "",
      "class": "<Type> LinksModeBelongsToField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1194,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LinksModeBelongsToField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1202,
      "description": "The name of the resource that this field\nrefers to. In the case of a polymorphic\nrelationship, this should be the trait\nor abstract type.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LinksModeBelongsToField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1328,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'hasMany'",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyHasManyField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1336,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyHasManyField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1344,
      "description": "the name of the resource that this field\nrefers to. In the case of a polymorphic\nrelationship, this should be the trait\nor abstract type.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyHasManyField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1476,
      "description": "The kind of field this is.",
      "itemtype": "property",
      "name": "kind",
      "type": "'hasMany'",
      "access": "public",
      "tagname": "",
      "class": "<Type> LinksModeHasManyField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1484,
      "description": "The name of the field.",
      "itemtype": "property",
      "name": "name",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LinksModeHasManyField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1492,
      "description": "the name of the resource that this field\nrefers to. In the case of a polymorphic\nrelationship, this should be the trait\nor abstract type.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LinksModeHasManyField",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1749,
      "description": "For primary resources, this should be an IdentityField\n\nfor schema-objects, this should be either a HashField or null",
      "itemtype": "property",
      "name": "identity",
      "type": "IdentityField",
      "access": "public",
      "tagname": "",
      "class": "<Type> PolarisResourceSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1759,
      "description": "The name of the schema\n\nFor cacheable resources, this should be the\nprimary resource type.\n\nFor object schemas, this should be the name\nof the object schema.\n\nThe names of object and resource schemas share\na single namespace and must not conflict.\n\nWe recommend a naming convention for object schemas\nsuch as below for ensuring uniqueness:\n\n- for globally shared objects: The pattern `$field:${KlassName}` e.g. `$field:AddressObject`\n- for resource-specific objects: The pattern `$${ResourceKlassName}:$field:${KlassName}` e.g. `$User:$field:ReusableAddress`\n- for inline objects: The pattern `$${ResourceKlassName}.${fieldPath}:$field:anonymous` e.g. `$User.shippingAddress:$field:anonymous`",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> PolarisResourceSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1783,
      "description": "The fields that make up the shape of the resource",
      "itemtype": "property",
      "name": "fields",
      "type": "PolarisModeFieldSchema[]",
      "access": "public",
      "tagname": "",
      "class": "<Type> PolarisResourceSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1791,
      "description": "A list of traits that this resource implements. The fields for these\ntraits should still be defined in the fields array.\n\nEach trait should be a string that matches the `type` of another\nresource schema. The trait can be abstract and reference a resource\ntype that is never defined as a schema.",
      "itemtype": "property",
      "name": "traits",
      "type": "String[]",
      "access": "public",
      "tagname": "",
      "class": "<Type> PolarisResourceSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1816,
      "description": "A flag indicating that this is a legacy resource schema",
      "itemtype": "property",
      "name": "legacy",
      "type": "True",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyResourceSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1824,
      "description": "This should be an IdentityField.\n\nTo maximize compatibility with Model where `id` was the\nname of the identity field, we recommend using `{ kind: '@id', name: 'id' }`\nfor records in legacy mode, but this is not required.",
      "itemtype": "property",
      "name": "identity",
      "type": "IdentityField",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyResourceSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1836,
      "description": "The name of the schema\n\nFor cacheable resources, this should be the\nprimary resource type.\n\nThe names of object and resource schemas share\na single namespace and must not conflict.\n\nWe recommend a naming convention for object schemas\nsuch as below for ensuring uniqueness:\n\n- for globally shared objects: The pattern `$field:${KlassName}` e.g. `$field:AddressObject`\n- for resource-specific objects: The pattern `$${ResourceKlassName}:$field:${KlassName}` e.g. `$User:$field:ReusableAddress`\n- for inline objects: The pattern `$${ResourceKlassName}.${fieldPath}:$field:anonymous` e.g. `$User.shippingAddress:$field:anonymous`",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyResourceSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1857,
      "description": "The fields that make up the shape of the resource",
      "itemtype": "property",
      "name": "fields",
      "type": "LegacyModeFieldSchema[]",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyResourceSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1865,
      "description": "A list of traits that this resource implements. The fields for these\ntraits should still be defined in the fields array.\n\nEach trait should be a string that matches the `type` of another\nresource schema. The trait can be abstract and reference a resource\ntype that is never defined as a schema.",
      "itemtype": "property",
      "name": "traits",
      "type": "String[]",
      "access": "public",
      "tagname": "",
      "class": "<Type> LegacyResourceSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1902,
      "description": "Either a HashField from which to calculate an identity or null\n\nIn the case of `null`, the object's identity will be based\non the referential identity of the object in the cache itself\nwhen an identity is needed.",
      "itemtype": "property",
      "name": "identity",
      "type": "HashField | null",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1914,
      "description": "The name of the schema\n\nThe names of object and resource schemas share\na single namespace and must not conflict.\n\nWe recommend a naming convention for object schemas\nsuch as below for ensuring uniqueness:\n\n- for globally shared objects: The pattern `$field:${KlassName}` e.g. `$field:AddressObject`\n- for resource-specific objects: The pattern `$${ResourceKlassName}:$field:${KlassName}` e.g. `$User:$field:ReusableAddress`\n- for inline objects: The pattern `$${ResourceKlassName}.${fieldPath}:$field:anonymous` e.g. `$User.shippingAddress:$field:anonymous`",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1932,
      "description": "The fields that make up the shape of the object",
      "itemtype": "property",
      "name": "fields",
      "type": "ObjectFieldSchema[]",
      "access": "public",
      "tagname": "",
      "class": "<Type> ObjectSchema",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1943,
      "description": "A no-op type utility that enables type-checking resource schema\ndefinitions.\n\nWill return the passed in schema.\n\nThis will not validate relationship inverses or related types,\nas doing so would require a full schema graph to be passed in\nand no cycles in the graph to be present.",
      "itemtype": "method",
      "name": "resourceSchema",
      "static": 1,
      "params": [
        {
          "name": "schema",
          "description": "",
          "type": "ResourceSchema"
        }
      ],
      "return": {
        "description": "the passed in schema",
        "type": "ResourceSchema"
      },
      "access": "public",
      "tagname": "",
      "class": "@warp-drive/core-types",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1964,
      "description": "A no-op type utility that enables type-checking object schema\ndefinitions.\n\nWill return the passed in schema.",
      "itemtype": "method",
      "name": "objectSchema",
      "static": 1,
      "params": [
        {
          "name": "schema",
          "description": "",
          "type": "ObjectSchema"
        }
      ],
      "return": {
        "description": "the passed in schema",
        "type": "ObjectSchema"
      },
      "access": "public",
      "tagname": "",
      "class": "@warp-drive/core-types",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1981,
      "description": "A type utility to narrow a schema to a ResourceSchema",
      "itemtype": "method",
      "name": "isResourceSchema",
      "static": 1,
      "params": [
        {
          "name": "schema",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "access": "public",
      "tagname": "",
      "class": "@warp-drive/core-types",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/schema/fields.ts",
      "line": 1995,
      "description": "A type utility to narrow a schema to LegacyResourceSchema",
      "itemtype": "method",
      "name": "isLegacyResourceSchema",
      "static": 1,
      "params": [
        {
          "name": "schema",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "access": "public",
      "tagname": "",
      "class": "@warp-drive/core-types",
      "module": "@warp-drive/core-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 49,
      "description": "The Cache Version that this implementation implements.",
      "type": "{'2'}",
      "access": "public",
      "tagname": "",
      "itemtype": "property",
      "name": "version",
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 61,
      "description": "Cache the response to a request\n\nUnlike `store.push` which has UPSERT\nsemantics, `put` has `replace` semantics similar to\nthe `http` method `PUT`\n\nthe individually cacheable resource data it may contain\nshould upsert, but the document data surrounding it should\nfully replace any existing information\n\nNote that in order to support inserting arbitrary data\nto the cache that did not originate from a request `put`\nshould expect to sometimes encounter a document with only\na `content` member and therefor must not assume the existence\nof `request` and `response` on the document.",
      "itemtype": "method",
      "name": "put",
      "params": [
        {
          "name": "doc",
          "description": "",
          "type": "StructuredDocument"
        }
      ],
      "return": {
        "description": "",
        "type": "ResourceDocument"
      },
      "access": "public",
      "tagname": "",
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 85,
      "description": "Update the \"remote\" or \"canonical\" (persisted) state of the Cache\nby merging new information into the existing state.",
      "itemtype": "method",
      "name": "patch",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "op",
          "description": "the operation(s) to perform",
          "type": "Operation | Operation[]"
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 96,
      "description": "Update the \"local\" or \"current\" (unpersisted) state of the Cache",
      "itemtype": "method",
      "name": "mutate",
      "params": [
        {
          "name": "mutation",
          "description": "",
          "type": "Mutation"
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "access": "public",
      "tagname": "",
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 106,
      "description": "Peek resource data from the Cache.\n\nIn development, if the return value\nis JSON the return value\nwill be deep-cloned and deep-frozen\nto prevent mutation thereby enforcing cache\nImmutability.\n\nThis form of peek is useful for implementations\nthat want to feed raw-data from cache to the UI\nor which want to interact with a blob of data\ndirectly from the presentation cache.\n\nAn implementation might want to do this because\nde-referencing records which read from their own\nblob is generally safer because the record does\nnot require retainining connections to the Store\nand Cache to present data on a per-field basis.\n\nThis generally takes the place of `getAttr` as\nan API and may even take the place of `getRelationship`\ndepending on implementation specifics, though this\nlatter usage is less recommended due to the advantages\nof the Graph handling necessary entanglements and\nnotifications for relational data.",
      "itemtype": "method",
      "name": "peek",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier | StableDocumentIdentifier"
        }
      ],
      "return": {
        "description": "the known resource data",
        "type": "ResourceDocument | ResourceBlob | null"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 141,
      "description": "Peek remote resource data from the Cache.\n\nThis will give the data provided from the server without any local changes.\n\nIn development, if the return value\nis JSON the return value\nwill be deep-cloned and deep-frozen\nto prevent mutation thereby enforcing cache\nImmutability.\n\nThis form of peek is useful for implementations\nthat want to feed raw-data from cache to the UI\nor which want to interact with a blob of data\ndirectly from the presentation cache.\n\nAn implementation might want to do this because\nde-referencing records which read from their own\nblob is generally safer because the record does\nnot require retainining connections to the Store\nand Cache to present data on a per-field basis.\n\nThis generally takes the place of `getAttr` as\nan API and may even take the place of `getRelationship`\ndepending on implementation specifics, though this\nlatter usage is less recommended due to the advantages\nof the Graph handling necessary entanglements and\nnotifications for relational data.",
      "itemtype": "method",
      "name": "peek",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier | StableDocumentIdentifier"
        }
      ],
      "return": {
        "description": "the known resource data",
        "type": "ResourceDocument | ResourceBlob | null"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 178,
      "description": "Peek the Cache for the existing request data associated with\na cacheable request\n\nThis is effectively the reverse of `put` for a request in\nthat it will return the the request, response, and content\nwhereas `peek` will return just the `content`.",
      "itemtype": "method",
      "name": "peekRequest",
      "params": [
        {
          "name": "UNKNOWN",
          "description": "",
          "type": "StableDocumentIdentifier"
        }
      ],
      "return": {
        "description": "",
        "type": "StructuredDocument<ResourceDocument> | null"
      },
      "access": "public",
      "tagname": "",
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 193,
      "description": "Push resource data from a remote source into the cache for this identifier",
      "itemtype": "method",
      "name": "upsert",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "data",
          "description": ""
        },
        {
          "name": "hasRecord",
          "description": ""
        }
      ],
      "return": {
        "description": "if `hasRecord` is true then calculated key changes should be returned",
        "type": "Void | string[]"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 208,
      "description": "Create a fork of the cache from the current state.\n\nApplications should typically not call this method themselves,\npreferring instead to fork at the Store level, which will\nutilize this method to fork the cache.",
      "itemtype": "method",
      "name": "fork",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "Promise<Cache>"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 221,
      "description": "Merge a fork back into a parent Cache.\n\nApplications should typically not call this method themselves,\npreferring instead to merge at the Store level, which will\nutilize this method to merge the caches.",
      "itemtype": "method",
      "name": "merge",
      "params": [
        {
          "name": "cache",
          "description": "",
          "type": "Cache"
        }
      ],
      "access": "public",
      "tagname": "",
      "return": {
        "description": "Promise<void>"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 235,
      "description": "Generate the list of changes applied to all\nrecord in the store.\n\nEach individual resource or document that has\nbeen mutated should be described as an individual\n`Change` entry in the returned array.\n\nA `Change` is described by an object containing up to\nthree properties: (1) the `identifier` of the entity that\nchanged; (2) the `op` code of that change being one of\n`upsert` or `remove`, and if the op is `upsert` a `patch`\ncontaining the data to merge into the cache for the given\nentity.\n\nThis `patch` is opaque to the Store but should be understood\nby the Cache and may expect to be utilized by an Adapter\nwhen generating data during a `save` operation.\n\nIt is generally recommended that the `patch` contain only\nthe updated state, ignoring fields that are unchanged\n\n```ts\ninterface Change {\n identifier: StableRecordIdentifier | StableDocumentIdentifier;\n op: 'upsert' | 'remove';\n patch?: unknown;\n}\n```",
      "itemtype": "method",
      "name": "diff",
      "access": "public",
      "tagname": "",
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 273,
      "description": "Serialize the entire contents of the Cache into a Stream\nwhich may be fed back into a new instance of the same Cache\nvia `cache.hydrate`.",
      "itemtype": "method",
      "name": "dump",
      "return": {
        "description": "",
        "type": "Promise<ReadableStream>"
      },
      "access": "public",
      "tagname": "",
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 284,
      "description": "hydrate a Cache from a Stream with content previously serialized\nfrom another instance of the same Cache, resolving when hydration\nis complete.\n\nThis method should expect to be called both in the context of restoring\nthe Cache during application rehydration after SSR **AND** at unknown\ntimes during the lifetime of an already booted application when it is\ndesired to bulk-load additional information into the cache. This latter\nbehavior supports optimizing pre/fetching of data for route transitions\nvia data-only SSR modes.",
      "itemtype": "method",
      "name": "hydrate",
      "params": [
        {
          "name": "stream",
          "description": "",
          "type": "ReadableStream"
        }
      ],
      "return": {
        "description": "",
        "type": "Promise<void>"
      },
      "access": "public",
      "tagname": "",
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 306,
      "description": "[LIFECYCLE] Signal to the cache that a new record has been instantiated on the client\n\nIt returns properties from options that should be set on the record during the create\nprocess. This return value behavior is deprecated.",
      "itemtype": "method",
      "name": "clientDidCreate",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "createArgs",
          "description": ""
        }
      ],
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 319,
      "description": "[LIFECYCLE] Signals to the cache that a resource\nwill be part of a save transaction.",
      "itemtype": "method",
      "name": "willCommit",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 329,
      "description": "[LIFECYCLE] Signals to the cache that a resource\nwas successfully updated as part of a save transaction.",
      "itemtype": "method",
      "name": "didCommit",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "- the primary identifier that was operated on"
        },
        {
          "name": "data",
          "description": "- a document in the cache format containing any updated data"
        }
      ],
      "return": {
        "description": "",
        "type": "SingleResourceDataDocument"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 341,
      "description": "[LIFECYCLE] Signals to the cache that a resource\nwas update via a save transaction failed.",
      "itemtype": "method",
      "name": "commitWasRejected",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "errors",
          "description": ""
        }
      ],
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 352,
      "description": "[LIFECYCLE] Signals to the cache that all data for a resource\nshould be cleared.\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "unloadRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 367,
      "description": "Retrieve the data for an attribute from the cache",
      "itemtype": "method",
      "name": "getAttr",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "field",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Unknown"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 378,
      "description": "Retrieve remote state without any local changes for a specific attribute",
      "itemtype": "method",
      "name": "getRemoteAttr",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "field",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Unknown"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 389,
      "description": "Mutate the data for an attribute in the cache\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "setAttr",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "field",
          "description": ""
        },
        {
          "name": "value",
          "description": ""
        }
      ],
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 402,
      "description": "Query the cache for the changed attributes of a resource.\n\nReturns a map of field names to tuples of [old, new] values\n\n```\n{ <field>: [<old>, <new>] }\n```",
      "itemtype": "method",
      "name": "changedAttrs",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "{ <field>: [<old>, <new>] }",
        "type": "Record<string, [unknown, unknown]>"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 418,
      "description": "Query the cache for whether any mutated attributes exist",
      "itemtype": "method",
      "name": "hasChangedAttrs",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 428,
      "description": "Tell the cache to discard any uncommitted mutations to attributes\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "rollbackAttrs",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "the names of fields that were restored",
        "type": "String[]"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 440,
      "description": "Query the cache for the changes to relationships of a resource.\n\nReturns a map of relationship names to RelationshipDiff objects.\n\n```ts\ntype RelationshipDiff =\n | {\n     kind: 'collection';\n     remoteState: StableRecordIdentifier[];\n     additions: Set<StableRecordIdentifier>;\n     removals: Set<StableRecordIdentifier>;\n     localState: StableRecordIdentifier[];\n     reordered: boolean;\n   }\n | {\n     kind: 'resource';\n     remoteState: StableRecordIdentifier | null;\n     localState: StableRecordIdentifier | null;\n   };\n   ```",
      "itemtype": "method",
      "name": "changedRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "",
        "type": "Map<string, RelationshipDiff>"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 469,
      "description": "Query the cache for whether any mutated attributes exist",
      "itemtype": "method",
      "name": "hasChangedRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 479,
      "description": "Tell the cache to discard any uncommitted mutations to relationships.\n\nThis will also discard the change on any appropriate inverses.\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "rollbackRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "the names of relationships that were restored",
        "type": "String[]"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 493,
      "description": "Query the cache for the current state of a relationship property",
      "itemtype": "method",
      "name": "getRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        },
        {
          "name": "field",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "resource relationship object"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 508,
      "description": "Query the cache for the server state of a relationship property without any local changes",
      "itemtype": "method",
      "name": "getRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        },
        {
          "name": "field",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "resource relationship object"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 526,
      "description": "Update the cache state for the given resource to be marked\nas locally deleted, or remove such a mark.\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "setIsDeleted",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "isDeleted",
          "description": "",
          "type": "Boolean"
        }
      ],
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 539,
      "description": "Query the cache for any validation errors applicable to the given resource.",
      "itemtype": "method",
      "name": "getErrors",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "JsonApiError[]"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 549,
      "description": "Query the cache for whether a given resource has any available data",
      "itemtype": "method",
      "name": "isEmpty",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 559,
      "description": "Query the cache for whether a given resource was created locally and not\nyet persisted.",
      "itemtype": "method",
      "name": "isNew",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 570,
      "description": "Query the cache for whether a given resource is marked as deleted (but not\nnecessarily persisted yet).",
      "itemtype": "method",
      "name": "isDeleted",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/cache.ts",
      "line": 581,
      "description": "Query the cache for whether a given resource has been deleted and that deletion\nhas also been persisted.",
      "itemtype": "method",
      "name": "isDeletionCommitted",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> Cache",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/core-types/src/identifier.ts",
      "line": 110,
      "description": "A string representing a unique identity.",
      "itemtype": "property",
      "name": "lid",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "StableRecordIdentifier",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/core-types/src/identifier.ts",
      "line": 116,
      "description": "the primary resource `type` or `modelName` this identity belongs to.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "StableRecordIdentifier",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/core-types/src/identifier.ts",
      "line": 122,
      "description": "the primary id for the record this identity belongs to. `null`\nif not yet assigned an id.",
      "itemtype": "property",
      "name": "id",
      "type": "String | null",
      "access": "public",
      "tagname": "",
      "class": "StableRecordIdentifier",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 160,
      "description": "Specifies how records can be filtered based on the state of the record\nRecords returned will need to have a `filterValues`\nproperty with a key for every name in the returned array",
      "itemtype": "method",
      "name": "getFilters",
      "access": "private",
      "tagname": "",
      "return": {
        "description": "List of objects defining filters\n The object should have a `name` and `desc` property",
        "type": "Array"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 182,
      "description": "Fetch the model types and observe them for changes.\nMaintains the list of model types without needing the Model package for detection.",
      "itemtype": "method",
      "name": "watchModelTypes",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "typesAdded",
          "description": "Callback to call to add types.\nTakes an array of objects containing wrapped types (returned from `wrapModelType`).",
          "type": "Function"
        },
        {
          "name": "typesUpdated",
          "description": "Callback to call when a type has changed.\nTakes an array of objects containing wrapped types.",
          "type": "Function"
        }
      ],
      "return": {
        "description": "Method to call to remove all observers",
        "type": "Function"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 233,
      "description": "Loop over the discovered types and use the callbacks from watchModelTypes to notify\nthe consumer of this adapter about the mdoels.",
      "itemtype": "method",
      "name": "watchTypeIfUnseen",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "discoveredTypes",
          "description": "",
          "type": "Map"
        },
        {
          "name": "type",
          "description": "",
          "type": "String"
        },
        {
          "name": "typesAdded",
          "description": "",
          "type": "Function"
        },
        {
          "name": "typesUpdated",
          "description": "",
          "type": "Function"
        },
        {
          "name": "releaseMethods",
          "description": "",
          "type": "Array"
        }
      ],
      "access": "private",
      "tagname": "",
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 264,
      "description": "Creates a human readable string used for column headers",
      "itemtype": "method",
      "name": "columnNameToDesc",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "name",
          "description": "The attribute name",
          "type": "String"
        }
      ],
      "return": {
        "description": "Human readable string based on the attribute name",
        "type": "String"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 276,
      "description": "Get the columns for a given model type",
      "itemtype": "method",
      "name": "columnsForType",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "typeClass",
          "description": "",
          "type": "Model"
        }
      ],
      "return": {
        "description": "An array of columns of the following format:\n name: {String} The name of the column\n desc: {String} Humanized description (what would show in a table column name)",
        "type": "Array"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 304,
      "description": "Fetches all loaded records for a given type",
      "itemtype": "method",
      "name": "getRecords",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "modelClass",
          "description": "of the record",
          "type": "Model"
        },
        {
          "name": "modelName",
          "description": "of the record",
          "type": "String"
        }
      ],
      "return": {
        "description": "An array of Model records\n This array will be observed for changes,\n so it should update when new records are added/removed",
        "type": "Array"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 330,
      "description": "Gets the values for each column\nThis is the attribute values for a given record",
      "itemtype": "method",
      "name": "getRecordColumnValues",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "record",
          "description": "to get values from",
          "type": "Model"
        }
      ],
      "return": {
        "description": "Keys should match column names defined by the model type",
        "type": "Object"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 352,
      "description": "Returns keywords to match when searching records",
      "itemtype": "method",
      "name": "getRecordKeywords",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "record",
          "description": "",
          "type": "Model"
        }
      ],
      "return": {
        "description": "Relevant keywords for search based on the record's attribute values",
        "type": "Array"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 372,
      "description": "Returns the values of filters defined by `getFilters`\nThese reflect the state of the record",
      "itemtype": "method",
      "name": "getRecordFilterValues",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "record",
          "description": "",
          "type": "Model"
        }
      ],
      "return": {
        "description": "The record state filter values",
        "type": "Object"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 389,
      "description": "Returns a color that represents the record's state\nPossible colors: black, blue, green",
      "itemtype": "method",
      "name": "getRecordColor",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "record",
          "description": "",
          "type": "Model"
        }
      ],
      "return": {
        "description": "The record color",
        "type": "String"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/debug/src/data-adapter.ts",
      "line": 408,
      "description": "Observes all relevant properties and re-sends the wrapped record\nwhen a change occurs",
      "itemtype": "method",
      "name": "observeRecord",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "record",
          "description": "",
          "type": "Model"
        },
        {
          "name": "recordUpdated",
          "description": "Callback used to notify changes",
          "type": "Function"
        }
      ],
      "return": {
        "description": "The function to call to remove all observers",
        "type": "Function"
      },
      "class": "InspectorDataAdapter",
      "module": "@ember-data/debug"
    },
    {
      "file": "../packages/ember/src/-private/promise-state.ts",
      "line": 81,
      "description": "Returns a reactive state-machine for the provided promise or awaitable.\n\nRepeat calls to `getPromiseState` with the same promise will return the same state object\nmaking is safe and easy to use in templates and JavaScript code to produce reactive\nbehaviors around promises.\n\n`getPromiseState` can be used in both JavaScript and Template contexts.\n\n```ts\nimport { getPromiseState } from '@warp-drive/ember';\n\nconst state = getPromiseState(promise);\n```\n\nFor instance, we could write a getter on a component that updates whenever\nthe promise state advances or the promise changes, by combining the function\nwith the use of `@cached`\n\n```ts\nclass Component {\n  @cached\n  get title() {\n    const state = getPromiseState(this.args.request);\n    if (state.isPending) {\n      return 'loading...';\n    }\n    if (state.isError) { return null; }\n    return state.result.title;\n  }\n}\n```\n\nOr in a template as a helper:\n\n```gjs\nimport { getPromiseState } from '@warp-drive/ember';\n\n<template>\n  {{#let (getPromiseState @request) as |state|}}\n    {{#if state.isPending}} <Spinner />\n    {{else if state.isError}} <ErrorForm @error={{state.error}} />\n    {{else}}\n      <h1>{{state.result.title}}</h1>\n    {{/if}}\n  {{/let}}\n</template>\n```\n\nIf looking to use in a template, consider also the `<Await />` component.",
      "itemtype": "method",
      "name": "getPromiseState",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "promise",
          "description": "",
          "type": "Promise<T> | Awaitable<T, E>"
        }
      ],
      "return": {
        "description": "",
        "type": "PromiseState<T, E>"
      },
      "class": "@warp-drive/ember",
      "module": "@warp-drive/ember"
    },
    {
      "file": "../packages/ember/src/-private/request-state.ts",
      "line": 323,
      "description": "`getRequestState` can be used in both JavaScript and Template contexts.\n\n ```ts\n import { getRequestState } from '@warp-drive/ember';\n\n const state = getRequestState(future);\n ```\n\n For instance, we could write a getter on a component that updates whenever\n the request state advances or the future changes, by combining the function\n with the use of `@cached`\n\n ```ts\n class Component {\n   @cached\n   get title() {\n     const state = getRequestState(this.args.request);\n     if (state.isPending) {\n       return 'loading...';\n     }\n     if (state.isError) { return null; }\n     return state.result.title;\n   }\n }\n ```\n\n Or in a template as a helper:\n\n ```gjs\n import { getRequestState } from '@warp-drive/ember';\n\n <template>\n   {{#let (getRequestState @request) as |state|}}\n     {{#if state.isPending}}\n       <Spinner />\n     {{else if state.isError}}\n       <ErrorForm @error={{state.error}} />\n     {{else}}\n       <h1>{{state.result.title}}</h1>\n     {{/if}}\n   {{/let}}\n </template>\n ```\n\n If looking to use in a template, consider also the `<Request />` component\n which offers a numbe of additional capabilities for requests *beyond* what\n `RequestState` provides.",
      "itemtype": "method",
      "name": "getRequestState",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "future",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "RequestState"
      },
      "class": "@warp-drive/ember",
      "module": "@warp-drive/ember"
    },
    {
      "file": "../packages/json-api/src/-private/builders/-utils.ts",
      "line": 25,
      "description": "Allows setting extensions and profiles to be used in the `Accept` header.\n\nExtensions and profiles are keyed by their namespace with the value being\ntheir URI.\n\nExample:\n\n```ts\nsetBuildURLConfig({\n  extensions: {\n    atomic: 'https://jsonapi.org/ext/atomic'\n  },\n  profiles: {\n    pagination: 'https://jsonapi.org/profiles/ethanresnick/cursor-pagination'\n  }\n});\n```\n\nThis also sets the global configuration for `buildBaseURL`\nfor host and namespace values for the application\nin the `@ember-data/request-utils` package.\n\nThese values may still be overridden by passing\nthem to buildBaseURL directly.\n\nThis method may be called as many times as needed\n\n```ts\ntype BuildURLConfig = {\n  host: string;\n  namespace: string'\n}\n```",
      "itemtype": "method",
      "name": "setBuildURLConfig",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "config",
          "description": "",
          "type": "BuildURLConfig"
        }
      ],
      "return": {
        "description": "void"
      },
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/builders/-utils.ts",
      "line": 164,
      "description": "Sorts query params by both key and value, returning a query params string\n\nTreats `included` specially, splicing it into an array if it is a string and sorting the array.\n  - If `included` is an object we build paths dynamically for you\nTreats `fields` specially, building JSON:API partial fields params from an object\nTreats `page` specially, building cursor-pagination profile page params from an object\n\n```ts\nconst params = buildQueryParams({\n include: {\n   company: {\n     locations: 'address'\n   }\n },\n  fields: {\n    company: ['name', 'ticker'],\n    person: 'name'\n  },\n  page: {\n    size: 10,\n    after: 'abc',\n  }\n});\n\n// => 'fields[company]=name,ticker&fields[person]=name&include=company.locations,company.locations.address&page[after]=abc&page[size]=10'\n```\n\nOptions:\n- arrayFormat: 'bracket' | 'indices' | 'repeat' | 'comma'\n\n'bracket': appends [] to the key for every value e.g. `ids[]=1&ids[]=2`\n'indices': appends [i] to the key for every value e.g. `ids[0]=1&ids[1]=2`\n'repeat': appends the key for every value e.g. `ids=1&ids=2`\n'comma' (default): appends the key once with a comma separated list of values e.g. `ids=1,2`",
      "itemtype": "method",
      "name": "buildQueryParams",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "params",
          "description": "",
          "type": "URLSearchParams | object"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object",
          "optional": true
        }
      ],
      "return": {
        "description": "A sorted query params string without the leading `?`",
        "type": "String"
      },
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/builders/find-record.ts",
      "line": 16,
      "description": "Builds request options to fetch a single resource by a known id or identifier\nconfigured for the url and header expectations of most JSON:API APIs.\n\n**Basic Usage**\n\n```ts\nimport { findRecord } from '@ember-data/json-api/request';\n\nconst data = await store.request(findRecord('person', '1'));\n```\n\n**With Options**\n\n```ts\nimport { findRecord } from '@ember-data/json-api/request';\n\nconst options = findRecord('person', '1', { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**With an Identifier**\n\n```ts\nimport { findRecord } from '@ember-data/json-api/request';\n\nconst options = findRecord({ type: 'person', id: '1' }, { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { findRecord } from '@ember-data/json-api/request';\n\nconst options = findRecord('person', '1', { include: ['pets', 'friends'] }, { namespace: 'api/v2' });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "findRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/builders/query.ts",
      "line": 18,
      "description": "Builds request options to query for resources, usually by a primary\ntype, configured for the url and header expectations of most JSON:API APIs.\n\nThe key difference between this and `postQuery` is that this method will send the query\nas query params in the url of a \"GET\" request instead of as the JSON body of a \"POST\"\nrequest.\n\n**Basic Usage**\n\n```ts\nimport { query } from '@ember-data/json-api/request';\n\nconst data = await store.request(query('person'));\n```\n\n**With Query Params**\n\n```ts\nimport { query } from '@ember-data/json-api/request';\n\nconst options = query('person', { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { query } from '@ember-data/json-api/request';\n\nconst options = query('person', { include: ['pets', 'friends'] }, { reload: true });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "query",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "query",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/builders/query.ts",
      "line": 111,
      "description": "Builds request options to query for resources, usually by a primary\ntype, configured for the url and header expectations of most JSON:API APIs.\n\nThe key difference between this and `query` is that this method will send the query\nas the JSON body of a \"POST\" request instead of as query params in the url of a \"GET\"\nrequest.\n\nA CacheKey is generated from the url and query params, and used to cache the response\nin the store.\n\n```ts\nimport { postQuery } from '@ember-data/json-api/request';\n\nconst options = postQuery('person', { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { postQuery } from '@ember-data/json-api/request';\n\nconst options = postQuery('person', { include: ['pets', 'friends'] }, { reload: true });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "postQuery",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "query",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/builders/save-record.ts",
      "line": 26,
      "description": "Builds request options to delete record for resources,\nconfigured for the url, method and header expectations of most JSON:API APIs.\n\n**Basic Usage**\n\n```ts\nimport { deleteRecord } from '@ember-data/json-api/request';\n\nconst person = store.peekRecord('person', '1');\n\n// mark record as deleted\nstore.deleteRecord(person);\n\n// persist deletion\nconst data = await store.request(deleteRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { deleteRecord } from '@ember-data/json-api/request';\n\nconst person = store.peekRecord('person', '1');\n\n// mark record as deleted\nstore.deleteRecord(person);\n\n// persist deletion\nconst options = deleteRecord(person, { namespace: 'api/v1' });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "deleteRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/builders/save-record.ts",
      "line": 109,
      "description": "Builds request options to create new record for resources,\nconfigured for the url, method and header expectations of most JSON:API APIs.\n\n**Basic Usage**\n\n```ts\nimport { createRecord } from '@ember-data/json-api/request';\n\nconst person = store.createRecord('person', { name: 'Ted' });\nconst data = await store.request(createRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { createRecord } from '@ember-data/json-api/request';\n\nconst person = store.createRecord('person', { name: 'Ted' });\nconst options = createRecord(person, { namespace: 'api/v1' });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "createRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/builders/save-record.ts",
      "line": 181,
      "description": "Builds request options to update existing record for resources,\nconfigured for the url, method and header expectations of most JSON:API APIs.\n\n**Basic Usage**\n\n```ts\nimport { updateRecord } from '@ember-data/json-api/request';\n\nconst person = store.peekRecord('person', '1');\nperson.name = 'Chris';\nconst data = await store.request(updateRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `patch` - Allows caller to specify whether to use a PATCH request instead of a PUT request, defaults to `false`.\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { updateRecord } from '@ember-data/json-api/request';\n\nconst person = store.peekRecord('person', '1');\nperson.name = 'Chris';\nconst options = updateRecord(person, { patch: true });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "updateRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/builders/save-record.ts",
      "line": 266,
      "description": "Builds request options to update existing record for resources,\nconfigured for the url and header expectations of most JSON:API APIs\nfor a PATCH request.\n\nNote: This is a convenience method that calls `updateRecord` with the\nsupplied request with the `patch` option set to `true`.\n\n**Basic Usage**\n\n```ts\nimport { patchRecord } from '@ember-data/json-api/request';\n\nconst person = store.peekRecord('person', '1');\nperson.name = 'Chris';\nconst data = await store.request(patchRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { patchRecord } from '@ember-data/json-api/request';\n\nconst person = store.peekRecord('person', '1');\nperson.name = 'Chris';\nconst options = patchRecord(person);\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "patchRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 150,
      "description": "The Cache Version that this implementation implements.",
      "type": "{'2'}",
      "access": "public",
      "tagname": "",
      "itemtype": "property",
      "name": "version",
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 176,
      "description": "Cache the response to a request\n\nImplements `Cache.put`.\n\nExpects a StructuredDocument whose `content` member is a JsonApiDocument.\n\n```js\ncache.put({\n  request: { url: 'https://api.example.com/v1/user/1' },\n  content: {\n    data: {\n      type: 'user',\n      id: '1',\n      attributes: {\n        name: 'Chris'\n      }\n    }\n  }\n})\n```\n\n> **Note**\n> The nested `content` and `data` members are not a mistake. This is because\n> there are two separate concepts involved here, the `StructuredDocument` which contains\n> the context of a given Request that has been issued with the returned contents as its\n> `content` property, and a `JSON:API Document` which is the json contents returned by\n> this endpoint and which uses its `data` property to signify which resources are the\n> primary resources associated with the request.\n\nStructuredDocument's with urls will be cached as full documents with\nassociated resource membership order and contents preserved but linked\ninto the cache.",
      "itemtype": "method",
      "name": "put",
      "params": [
        {
          "name": "doc",
          "description": "",
          "type": "StructuredDocument"
        }
      ],
      "return": {
        "description": "",
        "type": "ResourceDocument"
      },
      "access": "public",
      "tagname": "",
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 400,
      "description": "Update the \"remote\" or \"canonical\" (persisted) state of the Cache\nby merging new information into the existing state.",
      "itemtype": "method",
      "name": "patch",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "op",
          "description": "the operation or list of operations to perform",
          "type": "Operation|Operation[]"
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 431,
      "description": "Update the \"local\" or \"current\" (unpersisted) state of the Cache",
      "itemtype": "method",
      "name": "mutate",
      "params": [
        {
          "name": "mutation",
          "description": "",
          "type": "Mutation"
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "access": "public",
      "tagname": "",
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 459,
      "description": "Peek resource data from the Cache.\n\nIn development, if the return value\nis JSON the return value\nwill be deep-cloned and deep-frozen\nto prevent mutation thereby enforcing cache\nImmutability.\n\nThis form of peek is useful for implementations\nthat want to feed raw-data from cache to the UI\nor which want to interact with a blob of data\ndirectly from the presentation cache.\n\nAn implementation might want to do this because\nde-referencing records which read from their own\nblob is generally safer because the record does\nnot require retainining connections to the Store\nand Cache to present data on a per-field basis.\n\nThis generally takes the place of `getAttr` as\nan API and may even take the place of `getRelationship`\ndepending on implementation specifics, though this\nlatter usage is less recommended due to the advantages\nof the Graph handling necessary entanglements and\nnotifications for relational data.",
      "itemtype": "method",
      "name": "peek",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier | StableDocumentIdentifier"
        }
      ],
      "return": {
        "description": "the known resource data",
        "type": "ResourceDocument | ResourceObject | null"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 609,
      "description": "Peek the Cache for the existing request data associated with\na cacheable request.\n\nThis is effectively the reverse of `put` for a request in\nthat it will return the the request, response, and content\nwhereas `peek` will return just the `content`.",
      "itemtype": "method",
      "name": "peekRequest",
      "params": [
        {
          "name": "UNKNOWN",
          "description": "",
          "type": "StableDocumentIdentifier"
        }
      ],
      "return": {
        "description": "",
        "type": "StructuredDocument<ResourceDocument> | null"
      },
      "access": "public",
      "tagname": "",
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 626,
      "description": "Push resource data from a remote source into the cache for this identifier",
      "itemtype": "method",
      "name": "upsert",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "data",
          "description": ""
        },
        {
          "name": "hasRecord",
          "description": ""
        }
      ],
      "return": {
        "description": "if `hasRecord` is true then calculated key changes should be returned",
        "type": "Void | string[]"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 672,
      "description": "Merge a fork back into a parent Cache.\n\nApplications should typically not call this method themselves,\npreferring instead to merge at the Store level, which will\nutilize this method to merge the caches.",
      "itemtype": "method",
      "name": "merge",
      "params": [
        {
          "name": "cache",
          "description": "",
          "type": "Cache"
        }
      ],
      "access": "public",
      "tagname": "",
      "return": {
        "description": "Promise<void>"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 688,
      "description": "Generate the list of changes applied to all\nrecord in the store.\n\nEach individual resource or document that has\nbeen mutated should be described as an individual\n`Change` entry in the returned array.\n\nA `Change` is described by an object containing up to\nthree properties: (1) the `identifier` of the entity that\nchanged; (2) the `op` code of that change being one of\n`upsert` or `remove`, and if the op is `upsert` a `patch`\ncontaining the data to merge into the cache for the given\nentity.\n\nThis `patch` is opaque to the Store but should be understood\nby the Cache and may expect to be utilized by an Adapter\nwhen generating data during a `save` operation.\n\nIt is generally recommended that the `patch` contain only\nthe updated state, ignoring fields that are unchanged\n\n```ts\ninterface Change {\n identifier: StableRecordIdentifier | StableDocumentIdentifier;\n op: 'upsert' | 'remove';\n patch?: unknown;\n}\n```",
      "itemtype": "method",
      "name": "diff",
      "access": "public",
      "tagname": "",
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 728,
      "description": "Serialize the entire contents of the Cache into a Stream\nwhich may be fed back into a new instance of the same Cache\nvia `cache.hydrate`.",
      "itemtype": "method",
      "name": "dump",
      "return": {
        "description": "",
        "type": "Promise<ReadableStream>"
      },
      "access": "public",
      "tagname": "",
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 741,
      "description": "hydrate a Cache from a Stream with content previously serialized\nfrom another instance of the same Cache, resolving when hydration\nis complete.\n\nThis method should expect to be called both in the context of restoring\nthe Cache during application rehydration after SSR **AND** at unknown\ntimes during the lifetime of an already booted application when it is\ndesired to bulk-load additional information into the cache. This latter\nbehavior supports optimizing pre/fetching of data for route transitions\nvia data-only SSR modes.",
      "itemtype": "method",
      "name": "hydrate",
      "params": [
        {
          "name": "stream",
          "description": "",
          "type": "ReadableStream"
        }
      ],
      "return": {
        "description": "",
        "type": "Promise<void>"
      },
      "access": "public",
      "tagname": "",
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 765,
      "description": "[LIFECYCLE] Signal to the cache that a new record has been instantiated on the client\n\nIt returns properties from options that should be set on the record during the create\nprocess. This return value behavior is deprecated.",
      "itemtype": "method",
      "name": "clientDidCreate",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "createArgs",
          "description": ""
        }
      ],
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 848,
      "description": "[LIFECYCLE] Signals to the cache that a resource\nwill be part of a save transaction.",
      "itemtype": "method",
      "name": "willCommit",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 910,
      "description": "[LIFECYCLE] Signals to the cache that a resource\nwas successfully updated as part of a save transaction.",
      "itemtype": "method",
      "name": "didCommit",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "data",
          "description": ""
        }
      ],
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1055,
      "description": "[LIFECYCLE] Signals to the cache that a resource\nwas update via a save transaction failed.",
      "itemtype": "method",
      "name": "commitWasRejected",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "errors",
          "description": ""
        }
      ],
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1085,
      "description": "[LIFECYCLE] Signals to the cache that all data for a resource\nshould be cleared.\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "unloadRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1169,
      "description": "Retrieve the data for an attribute from the cache",
      "itemtype": "method",
      "name": "getAttr",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "field",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Unknown"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1302,
      "description": "Mutate the data for an attribute in the cache\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "setAttr",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "field",
          "description": ""
        },
        {
          "name": "value",
          "description": ""
        }
      ],
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1423,
      "description": "Query the cache for the changed attributes of a resource.",
      "itemtype": "method",
      "name": "changedAttrs",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "{ <field>: [<old>, <new>] }",
        "type": "ChangedAttributesHash"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1448,
      "description": "Query the cache for whether any mutated attributes exist",
      "itemtype": "method",
      "name": "hasChangedAttrs",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1475,
      "description": "Tell the cache to discard any uncommitted mutations to attributes\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "rollbackAttrs",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "the names of fields that were restored",
        "type": "String[]"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1520,
      "description": "Query the cache for the changes to relationships of a resource.\n\nReturns a map of relationship names to RelationshipDiff objects.\n\n```ts\ntype RelationshipDiff =\n   | {\n       kind: 'collection';\n       remoteState: StableRecordIdentifier[];\n       additions: Set<StableRecordIdentifier>;\n       removals: Set<StableRecordIdentifier>;\n       localState: StableRecordIdentifier[];\n       reordered: boolean;\n     }\n   | {\n       kind: 'resource';\n       remoteState: StableRecordIdentifier | null;\n       localState: StableRecordIdentifier | null;\n     };\n     ```",
      "itemtype": "method",
      "name": "changedRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "",
        "type": "Map<string, RelationshipDiff>"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1551,
      "description": "Query the cache for whether any mutated relationships exist",
      "itemtype": "method",
      "name": "hasChangedRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1563,
      "description": "Tell the cache to discard any uncommitted mutations to relationships.\n\nThis will also discard the change on any appropriate inverses.\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "rollbackRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "the names of relationships that were restored",
        "type": "String[]"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1584,
      "description": "Query the cache for the current state of a relationship property",
      "itemtype": "method",
      "name": "getRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "field",
          "description": ""
        }
      ],
      "return": {
        "description": "resource relationship object"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1607,
      "description": "Update the cache state for the given resource to be marked\nas locally deleted, or remove such a mark.\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "setIsDeleted",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "isDeleted",
          "description": "",
          "type": "Boolean"
        }
      ],
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1625,
      "description": "Query the cache for any validation errors applicable to the given resource.",
      "itemtype": "method",
      "name": "getErrors",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "JsonApiError[]"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1637,
      "description": "Query the cache for whether a given resource has any available data",
      "itemtype": "method",
      "name": "isEmpty",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1650,
      "description": "Query the cache for whether a given resource was created locally and not\nyet persisted.",
      "itemtype": "method",
      "name": "isNew",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1664,
      "description": "Query the cache for whether a given resource is marked as deleted (but not\nnecessarily persisted yet).",
      "itemtype": "method",
      "name": "isDeleted",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/cache.ts",
      "line": 1678,
      "description": "Query the cache for whether a given resource has been deleted and that deletion\nhas also been persisted.",
      "itemtype": "method",
      "name": "isDeletionCommitted",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "Cache",
      "module": "@ember-data/json-api"
    },
    {
      "file": "../packages/json-api/src/-private/serialize.ts",
      "line": 28,
      "description": "Serializes the current state of a resource or array of resources for use with POST or PUT requests.",
      "itemtype": "method",
      "name": "serializeResources",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "cache}",
          "description": "",
          "type": "Cache"
        },
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "An object with a `data` property containing the serialized resource patch",
        "type": "Object"
      },
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/json-api/src/-private/serialize.ts",
      "line": 111,
      "description": "Serializes changes to a resource for use with PATCH requests.\n\nOnly attributes which are changed are serialized.\nOnly relationships which are changed are serialized.\n\nCollection relationships serialize the collection as a whole.\n\nIf you would like to serialize updates to a collection more granularly\n(for instance, as operations) request the diff from the store and\nserialize as desired:\n\n```ts\nconst relationshipDiffMap = cache.changedRelationships(identifier);\n```",
      "itemtype": "method",
      "name": "serializePatch",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "cache}",
          "description": "",
          "type": "Cache"
        },
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "An object with a `data` property containing the serialized resource patch",
        "type": "Object"
      },
      "class": "@ember-data/json-api/request",
      "module": "@ember-data/json-api/request"
    },
    {
      "file": "../packages/legacy-compat/src/builders/find-all.ts",
      "line": 24,
      "description": "This function builds a request config to perform a `findAll` request for the given type.\nWhen passed to `store.request`, this config will result in the same behavior as a `store.findAll` request.\nAdditionally, it takes the same options as `store.findAll`.\n\nAll `@ember-data/legacy-compat` builders exist to enable you to migrate your codebase to using the correct syntax for `store.request` while temporarily preserving legacy behaviors.\nThis is useful for quickly upgrading an entire app to a unified syntax while a longer incremental migration is made to shift off of adapters and serializers.\nTo that end, these builders are deprecated and will be removed in a future version of Ember Data.",
      "itemtype": "method",
      "name": "findAll",
      "deprecated": true,
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "type",
          "description": "the name of the resource",
          "type": "String"
        },
        {
          "name": "query",
          "description": "a query to be used by the adapter",
          "type": "Object"
        },
        {
          "name": "options",
          "description": "optional, may include `adapterOptions` hash which will be passed to adapter.findAll",
          "type": "FindAllBuilderOptions",
          "optional": true
        }
      ],
      "return": {
        "description": "request config",
        "type": "FindAllRequestInput"
      },
      "class": "@ember-data/legacy-compat/builders",
      "module": "@ember-data/legacy-compat/builders"
    },
    {
      "file": "../packages/legacy-compat/src/builders/find-record.ts",
      "line": 26,
      "description": "This function builds a request config to find the record for a given identifier or type and id combination.\nWhen passed to `store.request`, this config will result in the same behavior as a `store.findRecord` request.\nAdditionally, it takes the same options as `store.findRecord`, with the exception of `preload` (which is unsupported).\n\n**Example 1**\n\n```ts\nimport { findRecord } from '@ember-data/legacy-compat/builders';\nconst { content: post } = await store.request<Post>(findRecord<Post>('post', '1'));\n```\n\n**Example 2**\n\n`findRecord` can be called with a single identifier argument instead of the combination\nof `type` (modelName) and `id` as separate arguments. You may recognize this combo as\nthe typical pairing from [JSON:API](https://jsonapi.org/format/#document-resource-object-identification)\n\n```ts\nimport { findRecord } from '@ember-data/legacy-compat/builders';\nconst { content: post } = await store.request<Post>(findRecord<Post>({ type: 'post', id }));\n```\n\nAll `@ember-data/legacy-compat` builders exist to enable you to migrate your codebase to using the correct syntax for `store.request` while temporarily preserving legacy behaviors.\nThis is useful for quickly upgrading an entire app to a unified syntax while a longer incremental migration is made to shift off of adapters and serializers.\nTo that end, these builders are deprecated and will be removed in a future version of Ember Data.",
      "itemtype": "method",
      "name": "findRecord",
      "deprecated": true,
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "resource",
          "description": "- either a string representing the name of the resource or a ResourceIdentifier object containing both the type (a string) and the id (a string) for the record or an lid (a string) of an existing record",
          "type": "String|object"
        },
        {
          "name": "id",
          "description": "- optional object with options for the request only if the first param is a ResourceIdentifier, else the string id of the record to be retrieved",
          "type": "String|number|object"
        },
        {
          "name": "options",
          "description": "- if the first param is a string this will be the optional options for the request. See examples for available options.",
          "type": "FindRecordBuilderOptions",
          "optional": true
        }
      ],
      "return": {
        "description": "request config",
        "type": "FindRecordRequestInput"
      },
      "class": "@ember-data/legacy-compat/builders",
      "module": "@ember-data/legacy-compat/builders"
    },
    {
      "file": "../packages/legacy-compat/src/builders/query.ts",
      "line": 25,
      "description": "This function builds a request config for a given type and query object.\nWhen passed to `store.request`, this config will result in the same behavior as a `store.query` request.\nAdditionally, it takes the same options as `store.query`.\n\nAll `@ember-data/legacy-compat` builders exist to enable you to migrate your codebase to using the correct syntax for `store.request` while temporarily preserving legacy behaviors.\nThis is useful for quickly upgrading an entire app to a unified syntax while a longer incremental migration is made to shift off of adapters and serializers.\nTo that end, these builders are deprecated and will be removed in a future version of Ember Data.",
      "itemtype": "method",
      "name": "query",
      "deprecated": true,
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "type",
          "description": "the name of the resource",
          "type": "String"
        },
        {
          "name": "query",
          "description": "a query to be used by the adapter",
          "type": "Object"
        },
        {
          "name": "options",
          "description": "optional, may include `adapterOptions` hash which will be passed to adapter.query",
          "type": "QueryBuilderOptions",
          "optional": true
        }
      ],
      "return": {
        "description": "request config",
        "type": "QueryRequestInput"
      },
      "class": "@ember-data/legacy-compat/builders",
      "module": "@ember-data/legacy-compat/builders"
    },
    {
      "file": "../packages/legacy-compat/src/builders/query.ts",
      "line": 87,
      "description": "This function builds a request config for a given type and query object.\nWhen passed to `store.request`, this config will result in the same behavior as a `store.queryRecord` request.\nAdditionally, it takes the same options as `store.queryRecord`.\n\nAll `@ember-data/legacy-compat` builders exist to enable you to migrate your codebase to using the correct syntax for `store.request` while temporarily preserving legacy behaviors.\nThis is useful for quickly upgrading an entire app to a unified syntax while a longer incremental migration is made to shift off of adapters and serializers.\nTo that end, these builders are deprecated and will be removed in a future version of Ember Data.",
      "itemtype": "method",
      "name": "queryRecord",
      "deprecated": true,
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "type",
          "description": "the name of the resource",
          "type": "String"
        },
        {
          "name": "query",
          "description": "a query to be used by the adapter",
          "type": "Object"
        },
        {
          "name": "options",
          "description": "optional, may include `adapterOptions` hash which will be passed to adapter.query",
          "type": "QueryBuilderOptions",
          "optional": true
        }
      ],
      "return": {
        "description": "request config",
        "type": "QueryRecordRequestInput"
      },
      "class": "@ember-data/legacy-compat/builders",
      "module": "@ember-data/legacy-compat/builders"
    },
    {
      "file": "../packages/legacy-compat/src/builders/save-record.ts",
      "line": 34,
      "description": "This function builds a request config for saving the given record (e.g. creating, updating, or deleting the record).\nWhen passed to `store.request`, this config will result in the same behavior as a legacy `store.saveRecord` request.\nAdditionally, it takes the same options as `store.saveRecord`.\n\nAll `@ember-data/legacy-compat` builders exist to enable you to migrate your codebase to using the correct syntax for `store.request` while temporarily preserving legacy behaviors.\nThis is useful for quickly upgrading an entire app to a unified syntax while a longer incremental migration is made to shift off of adapters and serializers.\nTo that end, these builders are deprecated and will be removed in a future version of Ember Data.",
      "itemtype": "method",
      "name": "saveRecord",
      "deprecated": true,
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": "a record to save",
          "type": "Object"
        },
        {
          "name": "options",
          "description": "optional, may include `adapterOptions` hash which will be passed to adapter.saveRecord",
          "type": "SaveRecordBuilderOptions"
        }
      ],
      "return": {
        "description": "request config",
        "type": "SaveRecordRequestInput"
      },
      "class": "@ember-data/legacy-compat/builders",
      "module": "@ember-data/legacy-compat/builders"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 39,
      "description": "`adapter.findRecord` takes a request for a resource of a given `type` and `id` combination\nand should return a `Promise` which fulfills with data for a single resource matching that\n`type` and `id`.\n\nThe response will be fed to the associated serializer's `normalizeResponse` method with the\n`requestType` set to `findRecord`, which should return a `JSON:API` document.\n\nThe final result after normalization to `JSON:API` will be added to store via `store.push` where\nit will merge with any existing data for the record.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.\n\n`adapter.findRecord` is called whenever the `store` needs to load, reload, or backgroundReload\nthe resource data for a given `type` and `id`.",
      "itemtype": "method",
      "name": "findRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "id",
          "description": "",
          "type": "String"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "a promise resolving with resource data to feed to the associated serializer",
        "type": "Promise"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 68,
      "description": "`adapter.findAll` takes a request for resources of a given `type` and should return\n a `Promise` which fulfills with a collection of resource data matching that `type`.\n\nThe response will be fed to the associated serializer's `normalizeResponse` method\n with the `requestType` set to `findAll`, which should return a `JSON:API` document.\n\nThe final result after normalization to `JSON:API` will be added to store via `store.push` where\nit will merge with any existing records for `type`. Existing records for the `type` will not be removed.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.\n\n`adapter.findAll` is called whenever `store.findAll` is asked to reload or backgroundReload.\nThe records in the response are merged with the contents of the store. Existing records for\nthe `type` will not be removed.\n\nSee also `shouldReloadAll` and `shouldBackgroundReloadAll`",
      "itemtype": "method",
      "name": "findAll",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "sinceToken",
          "description": "This parameter is no longer used and will always be null.",
          "type": "Null"
        },
        {
          "name": "snapshotRecordArray",
          "description": "an object containing any passed in options,\n adapterOptions, and the ability to access a snapshot for each existing record of the type.",
          "type": "SnapshotRecordArray"
        }
      ],
      "return": {
        "description": "a promise resolving with resource data to feed to the associated serializer",
        "type": "Promise"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 105,
      "description": "`adapter.query` takes a request for resources of a given `type` and should return\n a `Promise` which fulfills with a collection of resource data matching that `type`.\n\nThe response will be fed to the associated serializer's `normalizeResponse` method\n with the `requestType` set to `query`, which should return a `JSON:API` document.\n\nAs with `findAll`, the final result after normalization to `JSON:API` will be added to\nstore via `store.push` where it will merge with any existing records for `type`.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.\n\n`adapter.query` is called whenever `store.query` is called or a previous query result is\nasked to reload.\n\nExisting records for the `type` will not be removed. The key difference is in the result\nreturned by the `store`. For `findAll` the result is all known records of the `type`,\nwhile for `query` it will only be the records returned from `adapter.query`.",
      "itemtype": "method",
      "name": "query",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "query",
          "description": "",
          "type": "Object"
        },
        {
          "name": "recordArray",
          "description": "",
          "type": "CollectionRecordArray"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "a promise resolving with resource data to feed to the associated serializer",
        "type": "Promise"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 144,
      "description": "`adapter.queryRecord` takes a request for resource of a given `type` and should return\n a `Promise` which fulfills with data for a single resource matching that `type`.\n\nThe response will be fed to the associated serializer's `normalizeResponse` method\n with the `requestType` set to `queryRecord`, which should return a `JSON:API` document.\n\nThe final result after normalization to `JSON:API` will be added to store via `store.push` where\nit will merge with any existing data for the returned record.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.",
      "itemtype": "method",
      "name": "queryRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "query",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "return": {
        "description": "a promise resolving with resource data to feed to the associated serializer",
        "type": "Promise"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 174,
      "description": "`adapter.createRecord` takes a request to create a resource of a given `type` and should\nreturn a `Promise` which fulfills with data for the newly created resource.\n\nThe response will be fed to the associated serializer's `normalizeResponse` method\n with the `requestType` set to `createRecord`, which should return a `JSON:API` document.\n\nThe final result after normalization to `JSON:API` will be added to store via `store.push` where\nit will merge with any existing data for the record.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.\n\nIf the adapter rejects or throws an error the record will enter an error state and the attributes\nthat had attempted to be saved will still be considered dirty.\n\n### InvalidErrors\n\nWhen rejecting a `createRecord` request due to validation issues during save (typically a 422 status code),\nyou may throw an `InvalidError`.\n\nThrowing an `InvalidError` makes per-attribute errors available for records to use in the UI as needed.\nRecords can also use this information to mark themselves as being in an `invalid` state.\nFor more reading [see the RecordData Errors RFC](https://emberjs.github.io/rfcs/0465-record-data-errors.html)\n\n```js\nlet error = new Error(errorMessage);\n\n// these two properties combined\n// alert EmberData to this error being for\n// invalid properties on the record during\n// the request\nerror.isAdapterError = true;\nerror.code = 'InvalidError';\n\n// A JSON:API formatted array of errors\n// See https://jsonapi.org/format/#errors\nerror.errors = [];\n\nthrow error;\n```",
      "itemtype": "method",
      "name": "createRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "a promise resolving with resource data to feed to the associated serializer",
        "type": "Promise"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 227,
      "description": "`adapter.updateRecord` takes a request to update a resource of a given `type` and should\nreturn a `Promise` which fulfills with the updated data for the resource.\n\nThe response will be fed to the associated serializer's `normalizeResponse` method\n with the `requestType` set to `updateRecord`, which should return a `JSON:API` document.\n\nThe final result after normalization to `JSON:API` will be added to store via `store.push` where\nit will merge with any existing data for the record.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.\n\nIf the adapter rejects or throws an error the record will enter an error state and the attributes\nthat had attempted to be saved will still be considered dirty.\n\n### InvalidErrors\n\nWhen rejecting a `createRecord` request due to validation issues during save (typically a 422 status code),\nyou may throw an `InvalidError`.\n\nThrowing an `InvalidError` makes per-attribute errors available for records to use in the UI as needed.\nRecords can also use this information to mark themselves as being in an `invalid` state.\nFor more reading [see the RecordData Errors RFC](https://emberjs.github.io/rfcs/0465-record-data-errors.html)\n\n```js\nlet error = new Error(errorMessage);\n\n// these two properties combined\n// alert EmberData to this error being for\n// invalid properties on the record during\n// the request\nerror.isAdapterError = true;\nerror.code = 'InvalidError';\n\n// A JSON:API formatted array of errors\n// See https://jsonapi.org/format/#errors\nerror.errors = [];\n\nthrow error;\n```",
      "itemtype": "method",
      "name": "updateRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        }
      ],
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 279,
      "description": "`adapter.deleteRecord` takes a request to delete a resource of a given `type` and\nshould return a `Promise` which resolves when that deletion is complete.\n\nUsually the response will be empty, but you may include additional updates in the\nresponse. The response will be fed to the associated serializer's `normalizeResponse` method\nwith the `requestType` set to `deleteRecord`, which should return a `JSON:API` document.\n\nThe final result after normalization to `JSON:API` will be added to store via `store.push` where\nit will merge with any existing data.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.\n\nIf the adapter rejects or errors the record will need to be saved again once the reason\nfor the error is addressed in order to persist the deleted state.",
      "itemtype": "method",
      "name": "deleteRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "snapshot",
          "description": "A Snapshot containing the record's current data",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": ""
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 307,
      "description": "`adapter.findBelongsTo` takes a request to fetch a related resource located at a\n`relatedLink` and should return a `Promise` which fulfills with data for a single\n resource.\n\n‚ö†Ô∏è This method is only called if the store previously received relationship information for a resource\ncontaining a [related link](https://jsonapi.org/format/#document-resource-object-related-resource-links).\n\nIf the cache does not have a `link` for the relationship then `findRecord` will be used if a `type` and `id`\nfor the related resource is known.\n\nThe response will be fed to the associated serializer's `normalizeResponse` method\n with the `requestType` set to `findBelongsTo`, which should return a `JSON:API` document.\n\nThe final result after normalization to `JSON:API` will be added to store via `store.push` where\nit will merge with any existing data.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.",
      "itemtype": "method",
      "name": "findBelongsTo [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "snapshot",
          "description": "A Snapshot containing the parent record's current data",
          "type": "Snapshot"
        },
        {
          "name": "relatedLink",
          "description": "The link at which the associated resource might be found",
          "type": "String"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "RelationshipSchema"
        }
      ],
      "return": {
        "description": "a promise resolving with resource data to feed to the associated serializer",
        "type": "Promise"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 344,
      "description": "`adapter.findHasMany` takes a request to fetch a related resource collection located\n at a `relatedLink` and should return a `Promise` which fulfills with data for that\n collection.\n\n‚ö†Ô∏è This method is only called if the store previously received relationship information for a resource\ncontaining a [related link](https://jsonapi.org/format/#document-resource-object-related-resource-links).\n\nIf the cache does not have a `link` for the relationship but the `type` and `id` of\nrelated resources are known then `findRecord` will be used for each individual related\nresource.\n\nThe response will be fed to the associated serializer's `normalizeResponse` method\n with the `requestType` set to `findHasMany`, which should return a `JSON:API` document.\n\nThe final result after normalization to `JSON:API` will be added to store via `store.push` where\nit will merge with any existing data.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.",
      "itemtype": "method",
      "name": "findhasMany [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "snapshot",
          "description": "A Snapshot containing the parent record's current data",
          "type": "Snapshot"
        },
        {
          "name": "relatedLink",
          "description": "The link at which the associated resource collection might be found",
          "type": "String"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "RelationshipSchema"
        }
      ],
      "return": {
        "description": "a promise resolving with resource data to feed to the associated serializer",
        "type": "Promise"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 382,
      "description": "‚ö†Ô∏è This Method is only called if `coalesceFindRequests` is `true`. The array passed to it is determined\nby the adapter's `groupRecordsForFindMany` method, and will be called once per group returned.\n\n`adapter.findMany` takes a request to fetch a collection of resources and should return a\n`Promise` which fulfills with data for that collection.\n\nThe response will be fed to the associated serializer's `normalizeResponse` method\n with the `requestType` set to `findMany`, which should return a `JSON:API` document.\n\nThe final result after normalization to `JSON:API` will be added to store via `store.push` where\nit will merge with any existing data.\n\n‚ö†Ô∏è If the adapter's response resolves to a false-y value, the associated `serializer.normalizeResponse`\ncall will NOT be made. In this scenario you may need to do at least a minimum amount of response\nprocessing within the adapter.\n\nSee also `groupRecordsForFindMany` and `coalesceFindRequests`",
      "itemtype": "method",
      "name": "findMany [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "ids",
          "description": "An array of the ids of the resources to fetch",
          "type": "Array<string>"
        },
        {
          "name": "snapshots",
          "description": "An array of snapshots of the available data for the resources to fetch",
          "type": "Array<Snapshot>"
        }
      ],
      "return": {
        "description": "a promise resolving with resource data to feed to the associated serializer",
        "type": "Promise"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 413,
      "description": "This method provides the ability to generate an ID to assign to a new record whenever `store.createRecord`\nis called if no `id` was provided.\n\nAlternatively you can pass an id into the call to `store.createRecord` directly.\n\n```js\nlet id = generateNewId(type);\nlet newRecord = store.createRecord(type, { id });\n```",
      "itemtype": "method",
      "name": "generateIdForRecord [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "The type (or modelName) of record being created",
          "type": "String"
        },
        {
          "name": "properties",
          "description": "the properties passed as the second arg to `store.createRecord`"
        }
      ],
      "return": {
        "description": "a string ID that should be unique (no other models of `type` in the cache should have this `id`)",
        "type": "String"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 434,
      "description": "If your adapter implements `findMany`, setting this to `true` will cause `findRecord`\nrequests triggered within the same `runloop` to be coalesced into one or more calls\nto `adapter.findMany`. The number of calls made and the records contained in each call\ncan be tuned by your adapter's `groupRecordsForHasMany` method.\n\nImplementing coalescing using this flag and the associated methods does not always offer\nthe right level of correctness, timing control or granularity. If your application would\nbe better suited coalescing across multiple types, coalescing for longer than a single runloop,\nor with a more custom request structure, coalescing within your application adapter may prove\nmore effective.",
      "itemtype": "property",
      "name": "coalesceFindRequests [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "type": "{boolean} true if the requests to find individual records should be coalesced, false otherwise",
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 453,
      "description": "‚ö†Ô∏è This Method is only called if `coalesceFindRequests` is `true`.\n\nThis method allows for you to split pending requests for records into multiple `findMany`\nrequests. It receives an array of snapshots where each snapshot represents a unique record\nrequested via `store.findRecord` during the most recent `runloop` that was not found in the\ncache or needs to be reloaded. It should return an array of groups.\n\nA group is an array of snapshots meant to be fetched together by a single `findMany` request.\n\nBy default if this method is not implemented EmberData will call `findMany` once with all\nrequested records as a single group when `coalesceFindRequests` is `true`.\n\nSee also `findMany` and `coalesceFindRequests`",
      "itemtype": "method",
      "name": "groupRecordsForFindMany [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "snapshots",
          "description": "An array of snapshots",
          "type": "Array<Snapshot>"
        }
      ],
      "return": {
        "description": "An array of Snapshot arrays",
        "type": "Array<Array<Snapshot>>"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 477,
      "description": "When a record is already available in the store and is requested again via `store.findRecord`,\nand `reload` is not specified as an option in the request, this method is called to determine\nwhether the record should be reloaded prior to returning the result.\n\nIf `reload` is specified as an option in the request (`true` or `false`) this method will not\nbe called.\n\n```js\nstore.findRecord('user', '1', { reload: false })\n```\n\nThe default behavior if this method is not implemented and the option is not specified is to\nnot reload, the same as a return of `false`.\n\nSee also the documentation for `shouldBackgroundReloadRecord` which defaults to `true`.",
      "itemtype": "method",
      "name": "shouldReloadRecord [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "snapshot",
          "description": "A Snapshot containing the record's current data",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "true if the record should be reloaded immediately, false otherwise",
        "type": "Boolean"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 503,
      "description": "When `store.findAll(<type>)` is called without a `reload` option, the adapter\nis presented the opportunity to trigger a new request for records of that type.\n\nIf `reload` is specified as an option in the request (`true` or `false`) this method will not\nbe called.\n\n```js\nstore.findAll('user', { reload: false })\n```\n\nThe default behavior if this method is not implemented and the option is not specified is to\nnot reload, the same as a return of `false`.\n\nNote: the Promise returned by `store.findAll` resolves to the same LiveArray instance\nreturned by `store.peekAll` for that type, and will include all records in the store for\nthe given type, including any previously existing records not returned by the reload request.",
      "itemtype": "method",
      "name": "shouldReloadAll [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "snapshotArray",
          "description": "",
          "type": "SnapshotRecordArray"
        }
      ],
      "return": {
        "description": "true if the a new request for all records of the type in SnapshotRecordArray should be made immediately, false otherwise",
        "type": "Boolean"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 530,
      "description": "When a record is already available in the store and is requested again via `store.findRecord`,\nand the record does not need to be reloaded prior to return, this method provides the ability\nto specify whether a refresh of the data for the reload should be scheduled to occur in the background.\n\nUsers may explicitly declare a record should/should not be background reloaded by passing\n`backgroundReload: true` or `backgroundReload: false` as an option to the request respectively.\n\n```js\nstore.findRecord('user', '1', { backgroundReload: false })\n```\n\nIf the `backgroundReload` option is not present, this method will be called to determine whether\na backgroundReload should be performed.\n\nThe default behavior if this method is not implemented and the option was not specified is to\nbackground reload, the same as a return of `true`.",
      "itemtype": "method",
      "name": "shouldBackgroundReloadRecord [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "snapshot",
          "description": "A Snapshot containing the record's current data",
          "type": "Snapshot"
        }
      ],
      "return": {
        "description": "true if the record should be reloaded in the background, false otherwise",
        "type": "Boolean"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 557,
      "description": "When `store.findAll(<type>)` is called and a `reload` is not initiated, the adapter\nis presented the opportunity to trigger a new non-blocking (background) request for\nrecords of that type\n\nUsers may explicitly declare that this background request should/should not occur by passing\n`backgroundReload: true` or `backgroundReload: false` as an option to the request respectively.\n\n```js\nstore.findAll('user', { backgroundReload: false })\n```\n\nThe default behavior if this method is not implemented and the option is not specified is to\nperform a reload, the same as a return of `true`.",
      "itemtype": "method",
      "name": "shouldBackgroundReloadAll [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "snapshotArray",
          "description": "",
          "type": "SnapshotRecordArray"
        }
      ],
      "return": {
        "description": "true if the a new request for all records of the type in SnapshotRecordArray should be made in the background, false otherwise",
        "type": "Boolean"
      },
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-adapter-interface.ts",
      "line": 581,
      "description": "In some situations the adapter may need to perform cleanup when destroyed,\nthat cleanup can be done in `destroy`.\n\nIf not implemented, the store does not inform the adapter of destruction.",
      "itemtype": "method",
      "name": "destroy [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "class": "<Interface> Adapter",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts",
      "line": 44,
      "description": "This method is responsible for normalizing the value resolved from the promise returned\nby an Adapter request into the format expected by the `Store`.\n\nThe output should be a [JSON:API Document](https://jsonapi.org/format/#document-structure)\nwith the following additional restrictions:\n\n- `type` should be formatted in the `singular` `dasherized` `lowercase` form\n- `members` (the property names of attributes and relationships) should be formatted\n   to match their definition in the corresponding `Model` definition. Typically this\n   will be `camelCase`.\n- [`lid`](https://github.com/emberjs/rfcs/blob/main/text/0403-ember-data-identifiers.md) is\n   a valid optional sibling to `id` and `type` in both [Resources](https://jsonapi.org/format/#document-resource-objects)\n   and [Resource Identifier Objects](https://jsonapi.org/format/#document-resource-identifier-objects)",
      "itemtype": "method",
      "name": "normalizeResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "rawPayload",
          "description": "The raw JSON response data returned from an API request.\n This correlates to the value the promise returned by the adapter method that performed\n the request resolved to.",
          "type": "JSONObject"
        },
        {
          "name": "id",
          "description": "For a findRecord request, this is the id initially provided\n in the call to store.findRecord. Else this value is null.",
          "type": "String|null"
        },
        {
          "name": "requestType",
          "description": "The\n type of request the Adapter had been asked to perform.",
          "type": "'findRecord' | 'queryRecord' | 'findAll' | 'findBelongsTo' | 'findHasMany' | 'findMany' | 'query' | 'createRecord' | 'deleteRecord' | 'updateRecord'"
        }
      ],
      "return": {
        "description": "a document following the structure of a JSON:API Document.",
        "type": "JsonApiDocument"
      },
      "class": "<Interface> Serializer",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts",
      "line": 92,
      "description": "This method is responsible for serializing an individual record\nvia a [Snapshot](Snapshot) into the format expected by the API.\n\nThis method is called by `snapshot.serialize()`.\n\nWhen using `Model`, this method is called by `record.serialize()`.\n\nWhen using `JSONAPIAdapter` or `RESTAdapter` this method is called\nby `updateRecord` and `createRecord` if `Serializer.serializeIntoHash`\nis not implemented.",
      "itemtype": "method",
      "name": "serialize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "A Snapshot for the record to serialize",
          "type": "Snapshot"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object",
          "optional": true
        }
      ],
      "class": "<Interface> Serializer",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts",
      "line": 111,
      "description": "This method is intended to normalize data into a [JSON:API Document](https://jsonapi.org/format/#document-structure)\nwith a data member containing a single [Resource](https://jsonapi.org/format/#document-resource-objects).\n\n- `type` should be formatted in the singular, dasherized and lowercase form\n- `members` (the property names of attributes and relationships) should be formatted\n   to match their definition in the corresponding `Model` definition. Typically this\n   will be `camelCase`.\n- [`lid`](https://github.com/emberjs/rfcs/blob/main/text/0403-ember-data-identifiers.md) is\n   a valid optional sibling to `id` and `type` in both [Resources](https://jsonapi.org/format/#document-resource-objects)\n   and [Resource Identifier Objects](https://jsonapi.org/format/#document-resource-identifier-objects)\n\nThis method is called by the `Store` when `store.normalize(modelName, payload)` is\ncalled. It is recommended to use `store.serializerFor(modelName).normalizeResponse`\nover `store.normalize`.\n\nThis method may be called when also using the `RESTSerializer`\nwhen `serializer.pushPayload` is called by `store.pushPayload`.\nHowever, it is recommended to use `store.push` over `store.pushPayload` after normalizing\nthe payload directly.\n\nExample:\n```js\nfunction pushPayload(store, modelName, rawPayload) {\n  const ModelClass = store.modelFor(modelName);\n  const serializer = store.serializerFor(modelName);\n  const jsonApiPayload = serializer.normalizeResponse(store, ModelClass, rawPayload, null, 'query');\n\n  return store.push(jsonApiPayload);\n}\n```\n\nThis method may be called when also using the `JSONAPISerializer`\nwhen normalizing included records. If mixing serializer usage in this way\nwe recommend implementing this method, but caution that it may lead\nto unexpected mixing of formats.\n\nThis method may also be called when normalizing embedded relationships when\nusing the `EmbeddedRecordsMixin`. If using this mixin in a serializer in\nyour application we recommend implementing this method, but caution that\nit may lead to unexpected mixing of formats.",
      "itemtype": "method",
      "name": "normalize [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "rawPayload",
          "description": "Some raw JSON data to be normalized into a JSON:API Resource.",
          "type": "JSONObject"
        },
        {
          "name": "prop",
          "description": "When called by the EmbeddedRecordsMixin this param will be the\n property at which the object provided as rawPayload was found.",
          "type": "String",
          "optional": true
        }
      ],
      "return": {
        "description": "A JSON:API Document\n containing a single JSON:API Resource\n as its primary data.",
        "type": "SingleResourceDocument"
      },
      "class": "<Interface> Serializer",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts",
      "line": 167,
      "description": "When using `JSONAPIAdapter` or `RESTAdapter` this method is called\nby `adapter.updateRecord` and `adapter.createRecord` if `serializer.serializeIntoHash`\nis implemented. If this method is not implemented, `serializer.serialize`\nwill be called in this case.\n\nYou can use this method to customize the root keys serialized into the payload.\nThe hash property should be modified by reference.\n\nFor instance, your API may expect resources to be keyed by underscored type in the payload:\n\n```js\n{\n  _user: {\n    type: 'user',\n    id: '1'\n  }\n}\n```\n\nWhich when using these adapters can be achieved by implementing this method similar\nto the following:\n\n```js\nserializeIntoHash(hash, ModelClass, snapshot, options) {\n  hash[`_${snapshot.modelName}`] = this.serialize(snapshot, options).data;\n}\n```",
      "itemtype": "method",
      "name": "serializeIntoHash [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "hash",
          "description": "A top most object of the request payload onto\n which to append the serialized record"
        },
        {
          "name": "schema",
          "description": "An object with methods for accessing information about\n the type, attributes and relationships of the primary type associated with the request.",
          "type": "ModelSchema"
        },
        {
          "name": "snapshot",
          "description": "A Snapshot for the record to serialize",
          "type": "Snapshot"
        },
        {
          "name": "options",
          "description": "",
          "optional": true
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "class": "<Interface> Serializer",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts",
      "line": 209,
      "description": "This method allows for normalization of data when `store.pushPayload` is called\nand should be implemented if you want to use that method.\n\nThe method is responsible for pushing new data to the store using `store.push`\nonce any necessary normalization has occurred, and no data in the store will be\nupdated unless it does so.\n\nThe normalized form pushed to the store should be a [JSON:API Document](https://jsonapi.org/format/#document-structure)\nwith the following additional restrictions:\n\n- `type` should be formatted in the singular, dasherized and lowercase form\n- `members` (the property names of attributes and relationships) should be formatted\n   to match their definition in the corresponding `Model` definition. Typically this\n   will be `camelCase`.\n- [`lid`](https://github.com/emberjs/rfcs/blob/main/text/0403-ember-data-identifiers.md) is\n   a valid optional sibling to `id` and `type` in both [Resources](https://jsonapi.org/format/#document-resource-objects)\n   and [Resource Identifier Objects](https://jsonapi.org/format/#document-resource-identifier-objects)\n\nIf you need better control over normalization or want access to the records being added or updated\nin the store, we recommended using `store.push` over `store.pushPayload` after normalizing\nthe payload directly. This can even take advantage of an existing serializer for the format\nthe data is in, for example:\n\n```js\nfunction pushPayload(store, modelName, rawPayload) {\n  const ModelClass = store.modelFor(modelName);\n  const serializer = store.serializerFor(modelName);\n  const jsonApiPayload = serializer.normalizeResponse(store, ModelClass, rawPayload, null, 'query');\n\n  return store.push(jsonApiPayload);\n}\n```",
      "itemtype": "method",
      "name": "pushPayload [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "params": [
        {
          "name": "store",
          "description": "The store service that initiated the request being normalized",
          "type": "Store"
        },
        {
          "name": "rawPayload",
          "description": "The raw JSON response data returned from an API request.\n This JSON should be in the API format expected by the serializer.",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "class": "<Interface> Serializer",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/minimum-serializer-interface.ts",
      "line": 253,
      "description": "In some situations the serializer may need to perform cleanup when destroyed,\nthat cleanup can be done in `destroy`.\n\nIf not implemented, the store does not inform the serializer of destruction.",
      "itemtype": "method",
      "name": "destroy [OPTIONAL]",
      "access": "public",
      "tagname": "",
      "optional": 1,
      "class": "<Interface> Serializer",
      "module": "@ember-data/experimental-preview-types"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 29,
      "description": "SnapshotRecordArray is not directly instantiable.\nInstances are provided to consuming application's\nadapters and serializers for certain requests.",
      "itemtype": "method",
      "name": "constructor",
      "access": "private",
      "tagname": "",
      "is_constructor": 1,
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "type",
          "description": "",
          "type": "String"
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "SnapshotRecordArray",
      "module": "@ember-data/legacy-compat"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 43,
      "description": "An array of snapshots",
      "access": "private",
      "tagname": "",
      "itemtype": "property",
      "name": "_snapshots",
      "type": "{Array}",
      "class": "SnapshotRecordArray",
      "module": "@ember-data/legacy-compat"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 51,
      "description": "The modelName of the underlying records for the snapshots in the array, as a Model",
      "itemtype": "property",
      "name": "modelName",
      "access": "public",
      "tagname": "",
      "type": "{Model}",
      "class": "SnapshotRecordArray",
      "module": "@ember-data/legacy-compat"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 59,
      "description": "A hash of adapter options passed into the store method for this request.\n\nExample\n\n```app/adapters/post.js\nimport MyCustomAdapter from './custom-adapter';\n\nexport default class PostAdapter extends MyCustomAdapter {\n  findAll(store, type, sinceToken, snapshotRecordArray) {\n    if (snapshotRecordArray.adapterOptions.subscribe) {\n      // ...\n    }\n    // ...\n  }\n}\n```",
      "itemtype": "property",
      "name": "adapterOptions",
      "access": "public",
      "tagname": "",
      "type": "{Object}",
      "class": "SnapshotRecordArray",
      "module": "@ember-data/legacy-compat"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 83,
      "description": "The relationships to include for this request.\n\nExample\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\n\nexport default class ApplicationAdapter extends Adapter {\n  findAll(store, type, snapshotRecordArray) {\n    let url = `/${type.modelName}?include=${encodeURIComponent(snapshotRecordArray.include)}`;\n\n    return fetch(url).then((response) => response.json())\n  }\n}\n```",
      "itemtype": "property",
      "name": "include",
      "access": "public",
      "tagname": "",
      "type": "{String|Array}",
      "class": "SnapshotRecordArray",
      "module": "@ember-data/legacy-compat"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 107,
      "description": "An array of records",
      "itemtype": "property",
      "name": "_recordArray",
      "access": "private",
      "tagname": "",
      "type": "{Array}",
      "class": "SnapshotRecordArray",
      "module": "@ember-data/legacy-compat"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 118,
      "description": "Number of records in the array\n\nExample\n\n```app/adapters/post.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class PostAdapter extends JSONAPIAdapter {\n  shouldReloadAll(store, snapshotRecordArray) {\n    return !snapshotRecordArray.length;\n  }\n});\n```",
      "itemtype": "property",
      "name": "length",
      "access": "public",
      "tagname": "",
      "type": "{Number}",
      "class": "SnapshotRecordArray",
      "module": "@ember-data/legacy-compat"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot-record-array.ts",
      "line": 141,
      "description": "Get snapshots of the underlying record array\n\nExample\n\n```app/adapters/post.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class PostAdapter extends JSONAPIAdapter {\n  shouldReloadAll(store, snapshotArray) {\n    let snapshots = snapshotArray.snapshots();\n\n    return snapshots.any(function(ticketSnapshot) {\n      let timeDiff = moment().diff(ticketSnapshot.attr('lastAccessedAt'), 'minutes');\n      if (timeDiff > 20) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n  }\n}\n```",
      "itemtype": "method",
      "name": "snapshots",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "Array of snapshots",
        "type": "Array"
      },
      "class": "SnapshotRecordArray",
      "module": "@ember-data/legacy-compat"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 49,
      "itemtype": "method",
      "name": "constructor",
      "is_constructor": 1,
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": ""
        },
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "_store",
          "description": ""
        }
      ],
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 73,
      "description": "The unique RecordIdentifier associated with this Snapshot.",
      "itemtype": "property",
      "name": "identifier",
      "access": "public",
      "tagname": "",
      "type": "{StableRecordIdentifier}",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 94,
      "description": "The id of the snapshot's underlying record\n\nExample\n\n```javascript\n// store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\npostSnapshot.id; // => '1'\n```",
      "itemtype": "property",
      "name": "id",
      "type": "{String}",
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 110,
      "description": "A hash of adapter options",
      "itemtype": "property",
      "name": "adapterOptions",
      "type": "{Object}",
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 118,
      "description": "If `include` was passed to the options hash for the request, the value\nwould be available here.",
      "itemtype": "property",
      "name": "include",
      "type": "{String|Array}",
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 128,
      "description": "The name of the type of the underlying record for this snapshot, as a string.",
      "itemtype": "property",
      "name": "modelName",
      "type": "{String}",
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 142,
      "description": "The underlying record for this snapshot. Can be used to access methods and\nproperties defined on the record.\n\nExample\n\n```javascript\nlet json = snapshot.record.toJSON();\n```",
      "itemtype": "property",
      "name": "record",
      "type": "{Model}",
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 188,
      "description": "Returns the value of an attribute.\n\nExample\n\n```javascript\n// store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\npostSnapshot.attr('author'); // => 'Tomster'\npostSnapshot.attr('title'); // => 'Ember.js rocks'\n```\n\nNote: Values are loaded eagerly and cached when the snapshot is created.",
      "itemtype": "method",
      "name": "attr",
      "params": [
        {
          "name": "keyName",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "The attribute value or undefined",
        "type": "Object"
      },
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 213,
      "description": "Returns all attributes and their corresponding values.\n\nExample\n\n```javascript\n// store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\npostSnapshot.attributes(); // => { author: 'Tomster', title: 'Ember.js rocks' }\n```",
      "itemtype": "method",
      "name": "attributes",
      "return": {
        "description": "All attributes of the current snapshot",
        "type": "Object"
      },
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 231,
      "description": "Returns all changed attributes and their old and new values.\n\nExample\n\n```javascript\n// store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\npostModel.set('title', 'Ember.js rocks!');\npostSnapshot.changedAttributes(); // => { title: ['Ember.js rocks', 'Ember.js rocks!'] }\n```",
      "itemtype": "method",
      "name": "changedAttributes",
      "return": {
        "description": "All changed attributes of the current snapshot",
        "type": "Object"
      },
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 262,
      "description": "Returns the current value of a belongsTo relationship.\n\n`belongsTo` takes an optional hash of options as a second parameter,\ncurrently supported options are:\n\n- `id`: set to `true` if you only want the ID of the related record to be\nreturned.\n\nExample\n\n```javascript\n// store.push('post', { id: 1, title: 'Hello World' });\n// store.createRecord('comment', { body: 'Lorem ipsum', post: post });\ncommentSnapshot.belongsTo('post'); // => Snapshot\ncommentSnapshot.belongsTo('post', { id: true }); // => '1'\n\n// store.push('comment', { id: 1, body: 'Lorem ipsum' });\ncommentSnapshot.belongsTo('post'); // => undefined\n```\n\nCalling `belongsTo` will return a new Snapshot as long as there's any known\ndata for the relationship available, such as an ID. If the relationship is\nknown but unset, `belongsTo` will return `null`. If the contents of the\nrelationship is unknown `belongsTo` will return `undefined`.\n\nNote: Relationships are loaded lazily and cached upon first access.",
      "itemtype": "method",
      "name": "belongsTo",
      "params": [
        {
          "name": "keyName",
          "description": "",
          "type": "String"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object",
          "optional": true
        }
      ],
      "access": "public",
      "tagname": "",
      "return": {
        "description": "A snapshot or ID of a known\nrelationship or null if the relationship is known but unset. undefined\nwill be returned if the contents of the relationship is unknown.",
        "type": "(Snapshot|String|null|undefined)"
      },
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 370,
      "description": "Returns the current value of a hasMany relationship.\n\n`hasMany` takes an optional hash of options as a second parameter,\ncurrently supported options are:\n\n- `ids`: set to `true` if you only want the IDs of the related records to be\nreturned.\n\nExample\n\n```javascript\n// store.push('post', { id: 1, title: 'Hello World', comments: [2, 3] });\npostSnapshot.hasMany('comments'); // => [Snapshot, Snapshot]\npostSnapshot.hasMany('comments', { ids: true }); // => ['2', '3']\n\n// store.push('post', { id: 1, title: 'Hello World' });\npostSnapshot.hasMany('comments'); // => undefined\n```\n\nNote: Relationships are loaded lazily and cached upon first access.",
      "itemtype": "method",
      "name": "hasMany",
      "params": [
        {
          "name": "keyName",
          "description": "",
          "type": "String"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object",
          "optional": true
        }
      ],
      "access": "public",
      "tagname": "",
      "return": {
        "description": "An array of snapshots or IDs of a known\nrelationship or an empty array if the relationship is known but unset.\nundefined will be returned if the contents of the relationship is unknown.",
        "type": "(Array|undefined)"
      },
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 479,
      "description": "Iterates through all the attributes of the model, calling the passed\nfunction on each attribute.\n\nExample\n\n```javascript\nsnapshot.eachAttribute(function(name, meta) {\n  // ...\n});\n```",
      "itemtype": "method",
      "name": "eachAttribute",
      "params": [
        {
          "name": "callback",
          "description": "the callback to execute",
          "type": "Function"
        },
        {
          "name": "binding",
          "description": "the value to which the callback's `this` should be bound",
          "type": "Object",
          "optional": true
        }
      ],
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 505,
      "description": "Iterates through all the relationships of the model, calling the passed\nfunction on each relationship.\n\nExample\n\n```javascript\nsnapshot.eachRelationship(function(name, relationship) {\n  // ...\n});\n```",
      "itemtype": "method",
      "name": "eachRelationship",
      "params": [
        {
          "name": "callback",
          "description": "the callback to execute",
          "type": "Function"
        },
        {
          "name": "binding",
          "description": "the value to which the callback's `this` should be bound",
          "type": "Object",
          "optional": true
        }
      ],
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/legacy-network-handler/snapshot.ts",
      "line": 531,
      "description": "Serializes the snapshot using the serializer for the model.\n\nExample\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\n\nexport default Adapter.extend({\n  createRecord(store, type, snapshot) {\n    let data = snapshot.serialize({ includeId: true });\n    let url = `/${type.modelName}`;\n\n    return fetch(url, {\n      method: 'POST',\n      body: data,\n    }).then((response) => response.json())\n  }\n});\n```",
      "itemtype": "method",
      "name": "serialize",
      "params": [
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "an object whose values are primitive JSON values only",
        "type": "Object"
      },
      "access": "public",
      "tagname": "",
      "class": "Snapshot",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/index.ts",
      "line": 41,
      "description": "Returns an instance of the adapter for a given type. For\nexample, `adapterFor('person')` will return an instance of\nthe adapter located at `app/adapters/person.js`\n\nIf no `person` adapter is found, this method will look\nfor an `application` adapter (the default adapter for\nyour entire application).",
      "itemtype": "method",
      "name": "adapterFor",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "Adapter"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/index.ts",
      "line": 102,
      "description": "Returns an instance of the serializer for a given type. For\nexample, `serializerFor('person')` will return an instance of\n`App.PersonSerializer`.\n\nIf no `App.PersonSerializer` is found, this method will look\nfor an `App.ApplicationSerializer` (the default serializer for\nyour entire application).\n\nIf a serializer cannot be found on the adapter, it will fall back\nto an instance of `JSONSerializer`.",
      "itemtype": "method",
      "name": "serializerFor",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "the record to serialize",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "Serializer"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/index.ts",
      "line": 161,
      "description": "`normalize` converts a json payload into the normalized form that\n[push](../methods/push?anchor=push) expects.\n\nExample\n\n```js\nsocket.on('message', function(message) {\n  let modelName = message.model;\n  let data = message.data;\n  store.push(store.normalize(modelName, data));\n});\n```",
      "itemtype": "method",
      "name": "normalize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "The name of the model type for this payload",
          "type": "String"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "The normalized payload",
        "type": "Object"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/index.ts",
      "line": 203,
      "description": "Push some raw data into the store.\n\nThis method can be used both to push in brand new\nrecords, as well as to update existing records. You\ncan push in more than one type of object at once.\nAll objects should be in the format expected by the\nserializer.\n\n```app/serializers/application.js\nimport RESTSerializer from '@ember-data/serializer/rest';\n\nexport default class ApplicationSerializer extends RESTSerializer;\n```\n\n```js\nlet pushData = {\n  posts: [\n    { id: 1, postTitle: \"Great post\", commentIds: [2] }\n  ],\n  comments: [\n    { id: 2, commentBody: \"Insightful comment\" }\n  ]\n}\n\nstore.pushPayload(pushData);\n```\n\nBy default, the data will be deserialized using a default\nserializer (the application serializer if it exists).\n\nAlternatively, `pushPayload` will accept a model type which\nwill determine which serializer will process the payload.\n\n```app/serializers/application.js\nimport RESTSerializer from '@ember-data/serializer/rest';\n\n export default class ApplicationSerializer extends RESTSerializer;\n```\n\n```app/serializers/post.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default JSONSerializer;\n```\n\n```js\nstore.pushPayload(pushData); // Will use the application serializer\nstore.pushPayload('post', pushData); // Will use the post serializer\n```",
      "itemtype": "method",
      "name": "pushPayload",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "Optionally, a model type used to determine which serializer will be used",
          "type": "String"
        },
        {
          "name": "inputPayload",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/legacy-compat/src/utils.ts",
      "line": 35,
      "description": "Configure a function to be called when an id or type\nchanges during normalization. This is useful for instrumenting\nto discover places where usage in the app is not consistent.",
      "itemtype": "method",
      "name": "configureMismatchReporter",
      "params": [
        {
          "name": "method",
          "description": "a function which takes a mismatch-type ('formatted-id' | 'formatted-type'), actual, and expected value"
        }
      ],
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/legacy-compat/utils",
      "module": "@ember-data/legacy-compat/utils"
    },
    {
      "file": "../packages/legacy-compat/src/utils.ts",
      "line": 50,
      "description": "Configure a function to be called when an id or type\nfails validation. This is useful for instrumenting\nto discover places where usage in the app is not consistent.",
      "itemtype": "method",
      "name": "configureAssertFn",
      "params": [
        {
          "name": "method",
          "description": "a function which takes a message and a condition"
        }
      ],
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/legacy-compat/utils",
      "module": "@ember-data/legacy-compat/utils"
    },
    {
      "file": "../packages/legacy-compat/src/utils.ts",
      "line": 65,
      "description": "Configure a function to be called to normalize\na resource type string. Used by both formattedType\nand isEquivType to ensure consistent normalization\nduring comparison.\n\nIf validation fails or the type turns out be unnormalized\nthe configured mismatch reporter and assert functions will\nbe called.",
      "itemtype": "method",
      "name": "configureTypeNormalization",
      "params": [
        {
          "name": "method",
          "description": "a function which takes a string and returns a string"
        }
      ],
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/legacy-compat/utils",
      "module": "@ember-data/legacy-compat/utils"
    },
    {
      "file": "../packages/legacy-compat/src/utils.ts",
      "line": 87,
      "description": "Converts a potentially unnormalized type into the format expected\nby our EmberData Cache. Currently this is singular-dasherized.\n\nyou should not rely on this function to give you an exact format\nfor display purposes. Formatting for display should be handled\ndifferently if the exact format matters.\n\nAsserts invalid types (undefined, null, '') in dev.\n\n**Usage**\n\n```js\nimport formattedType from 'soxhub-client/helpers/formatted-type';\n\nformattedType('post'); // => 'post'\nformattedType('posts'); // => 'post'\nformattedType('Posts'); // => 'post'\nformattedType('post-comment'); // => 'post-comment'\nformattedType('post-comments'); // => 'post-comment'\nformattedType('post_comment'); // => 'post-comment'\nformattedType('postComment'); // => 'post-comment'\nformattedType('PostComment'); // => 'post-comment'\n```",
      "itemtype": "method",
      "name": "formattedType",
      "params": [
        {
          "name": "type",
          "description": "the potentially un-normalized type",
          "type": "String"
        }
      ],
      "return": {
        "description": "the normalized type",
        "type": "String"
      },
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/legacy-compat/utils",
      "module": "@ember-data/legacy-compat/utils"
    },
    {
      "file": "../packages/legacy-compat/src/utils.ts",
      "line": 138,
      "description": "Format an id to the format expected by the EmberData Cache.\nCurrently this means that id should be `string | null`.\n\nAsserts invalid IDs (undefined, '', 0, '0') in dev.\n\n**Usage**\n\n```js\nimport formattedId from 'client/utils/formatted-id';\n\nformattedId('1'); // => '1'\nformattedId(1); // => '1'\nformattedId(null); // => null\n\t```",
      "itemtype": "method",
      "name": "formattedId",
      "params": [
        {
          "name": "id",
          "description": "the potentially un-normalized id",
          "type": "String | number | null"
        }
      ],
      "return": {
        "description": "the normalized id",
        "type": "String | null"
      },
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/legacy-compat/utils",
      "module": "@ember-data/legacy-compat/utils"
    },
    {
      "file": "../packages/legacy-compat/src/utils.ts",
      "line": 191,
      "description": "Compares two types for strict equality, converting them to\nthe format expected by the EmberData Cache to ensure\ndifferences in format are accounted for in the comparison.\n\nAsserts when expected or actual are invalid types in dev.\nExpected may never be null.\n\n```js\nisEquivType('posts', 'post'); // true\nisEquivType('post', 'post'); // true\nisEquivType('posts', 'posts'); // true\nisEquivType('post-comment', 'postComment'); // true\nisEquivType('post-comment', 'PostComment'); // true\nisEquivType('post-comment', 'post_comment'); // true\nisEquivType('post-comment', 'post-comment'); // true\nisEquivType('post-comment', 'post'); // false\nisEquivType('posts', null); // false\n```",
      "itemtype": "method",
      "name": "isEquivType",
      "params": [
        {
          "name": "expected",
          "description": "a potentially unnormalized type to match against",
          "type": "String"
        },
        {
          "name": "actual",
          "description": "a potentially unnormalized type to match against",
          "type": "String"
        }
      ],
      "return": {
        "description": "true if the types are equivalent",
        "type": "Boolean"
      },
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/legacy-compat/utils",
      "module": "@ember-data/legacy-compat/utils"
    },
    {
      "file": "../packages/legacy-compat/src/utils.ts",
      "line": 233,
      "description": "Compares two IDs for strict equality, converting them to\nthe format expected by the EmberData Cache to ensure\ndifferences in format are accounted for in the comparison.\n\nAsserts when expected or actual are invalid IDs in dev.\nExpected may never be null.\n\n```js\nisEquivId('1', 1); // true\nisEquivId('2', '2'); // true\nisEquivId(3, '3'); // true\nisEquivId(4, '3'); // false\nisEquivId(1, null); // false\n```",
      "itemtype": "method",
      "name": "isEquivId",
      "params": [
        {
          "name": "expected",
          "description": "a potentially un-normalized id to match against",
          "type": "String | number"
        },
        {
          "name": "actual",
          "description": "a potentially un-normalized id to match against",
          "type": "String | number"
        }
      ],
      "return": {
        "description": "true if the ids are equivalent",
        "type": "Boolean"
      },
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/legacy-compat/utils",
      "module": "@ember-data/legacy-compat/utils"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 78,
      "description": "The field name on the parent record for this has-many relationship.",
      "itemtype": "property",
      "name": "key",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 86,
      "description": "The type of resource this relationship will contain.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 139,
      "description": "The identifier of the record that this reference refers to.\n`null` if no related record is known.",
      "itemtype": "property",
      "name": "identifier",
      "type": "StableRecordIdentifier | null",
      "access": "public",
      "tagname": "",
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 172,
      "description": "The `id` of the record that this reference refers to. Together, the\n`type()` and `id()` methods form a composite key for the identity\nmap. This can be used to access the id of an async relationship\nwithout triggering a fetch that would normally happen if you\nattempted to use `record.relationship.id`.\n\nExample\n\n```javascript\n// models/blog.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n @belongsTo('user', { async: true, inverse: null }) user;\n}\n\nlet blog = store.push({\n   data: {\n     type: 'blog',\n     id: 1,\n     relationships: {\n       user: {\n         data: { type: 'user', id: 1 }\n       }\n     }\n   }\n });\nlet userRef = blog.belongsTo('user');\n\n// get the identifier of the reference\nif (userRef.remoteType() === \"id\") {\n   let id = userRef.id();\n }\n```",
      "itemtype": "method",
      "name": "id",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The id of the record in this belongsTo relationship.",
        "type": "String"
      },
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 216,
      "description": "The link Ember Data will use to fetch or reload this belongs-to\nrelationship. By default it uses only the \"related\" resource linkage.\n\nExample\n\n```javascript\n// models/blog.js\nimport Model, { belongsTo } from '@ember-data/model';\nexport default Model.extend({\n   user: belongsTo('user', { async: true, inverse: null })\n });\n\nlet blog = store.push({\n   data: {\n     type: 'blog',\n     id: 1,\n     relationships: {\n       user: {\n         links: {\n           related: '/articles/1/author'\n         }\n       }\n     }\n   }\n });\nlet userRef = blog.belongsTo('user');\n\n// get the identifier of the reference\nif (userRef.remoteType() === \"link\") {\n   let link = userRef.link();\n }\n```",
      "itemtype": "method",
      "name": "link",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The link Ember Data will use to fetch or reload this belongs-to relationship.",
        "type": "String"
      },
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 266,
      "description": "any links that have been received for this relationship",
      "itemtype": "method",
      "name": "links",
      "access": "public",
      "tagname": "",
      "return": {
        "description": ""
      },
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 279,
      "description": "The meta data for the belongs-to relationship.\n\nExample\n\n```javascript\n// models/blog.js\nimport Model, { belongsTo } from '@ember-data/model';\nexport default Model.extend({\n   user: belongsTo('user', { async: true, inverse: null })\n });\n\nlet blog = store.push({\n   data: {\n     type: 'blog',\n     id: 1,\n     relationships: {\n       user: {\n         links: {\n           related: {\n             href: '/articles/1/author'\n           },\n         },\n         meta: {\n           lastUpdated: 1458014400000\n         }\n       }\n     }\n   }\n });\n\nlet userRef = blog.belongsTo('user');\n\nuserRef.meta() // { lastUpdated: 1458014400000 }\n```",
      "itemtype": "method",
      "name": "meta",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The meta information for the belongs-to relationship.",
        "type": "Object"
      },
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 337,
      "description": "This returns a string that represents how the reference will be\nlooked up when it is loaded. If the relationship has a link it will\nuse the \"link\" otherwise it defaults to \"id\".\n\nExample\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment', { async: true, inverse: null }) comments;\n}\n```\n\n```javascript\nlet post = store.push({\n  data: {\n    type: 'post',\n    id: 1,\n    relationships: {\n      comments: {\n        data: [{ type: 'comment', id: 1 }]\n      }\n    }\n  }\n});\n\nlet commentsRef = post.hasMany('comments');\n\n// get the identifier of the reference\nif (commentsRef.remoteType() === \"ids\") {\n  let ids = commentsRef.ids();\n} else if (commentsRef.remoteType() === \"link\") {\n  let link = commentsRef.link();\n}\n```",
      "itemtype": "method",
      "name": "remoteType",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The name of the remote type. This should either be `link` or `id`",
        "type": "String"
      },
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 387,
      "description": "`push` can be used to update the data in the relationship and EmberData\nwill treat the new data as the canonical value of this relationship on\nthe backend. A value of `null` (e.g. `{ data: null }`) can be passed to\nclear the relationship.\n\nExample model\n\n```app/models/blog.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n   @belongsTo('user', { async: true, inverse: null }) user;\n }\n```\n\nSetup some initial state, note we haven't loaded the user yet:\n\n```js\nconst blog = store.push({\n   data: {\n     type: 'blog',\n     id: '1',\n     relationships: {\n       user: {\n         data: { type: 'user', id: '1' }\n       }\n     }\n   }\n});\n\nconst userRef = blog.belongsTo('user');\nuserRef.id(); // '1'\n```\n\nUpdate the state using `push`, note we can do this even without\nhaving loaded the user yet by providing a resource-identifier.\n\nBoth full a resource and a resource-identifier are supported.\n\n```js\nawait userRef.push({\n   data: {\n     type: 'user',\n     id: '2',\n   }\n });\n\n userRef.id(); // '2'\n```\n\nYou may also pass in links and meta fore the relationship, and sideload\nadditional resources that might be required.\n\n```js\n await userRef.push({\n     data: {\n       type: 'user',\n       id: '2',\n     },\n     links: {\n       related: '/articles/1/author'\n     },\n     meta: {\n       lastUpdated: Date.now()\n     },\n     included: [\n       {\n         type: 'user-preview',\n         id: '2',\n         attributes: {\n           username: '@runspired'\n         }\n       }\n     ]\n   });\n ```\n\nBy default, the store will attempt to fetch the record if it is not loaded or its\nresource data is not included in the call to `push` before resolving the returned\npromise with the new state..\n\nAlternatively, pass `true` as the second argument to avoid fetching unloaded records\nand instead the promise will resolve with void without attempting to fetch. This is\nparticularly useful if you want to update the state of the relationship without\nforcing the load of all of the associated record.",
      "itemtype": "method",
      "name": "push",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "doc",
          "description": "a JSONAPI document object describing the new value of this relationship.",
          "type": "Object"
        },
        {
          "name": "skipFetch",
          "description": "if `true`, do not attempt to fetch unloaded records",
          "type": "Boolean",
          "optional": true
        }
      ],
      "return": {
        "description": "",
        "type": "Promise<OpaqueRecordInstance | null | void>"
      },
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 520,
      "description": "`value()` synchronously returns the current value of the belongs-to\nrelationship. Unlike `record.relationshipName`, calling\n`value()` on a reference does not trigger a fetch if the async\nrelationship is not yet loaded. If the relationship is not loaded\nit will always return `null`.\n\nExample\n\n```javascript\n// models/blog.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n  @belongsTo('user', { async: true, inverse: null }) user;\n}\n\nlet blog = store.push({\n   data: {\n     type: 'blog',\n     id: 1,\n     relationships: {\n       user: {\n         data: { type: 'user', id: 1 }\n       }\n     }\n   }\n });\nlet userRef = blog.belongsTo('user');\n\nuserRef.value(); // null\n\n// provide data for reference\nuserRef.push({\n   data: {\n     type: 'user',\n     id: 1,\n     attributes: {\n       username: \"@user\"\n     }\n   }\n }).then(function(user) {\n   userRef.value(); // user\n });\n```",
      "itemtype": "method",
      "name": "value",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "the record in this relationship",
        "type": "Model"
      },
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 575,
      "description": "Loads a record in a belongs-to relationship if it is not already\nloaded. If the relationship is already loaded this method does not\ntrigger a new load.\n\nExample\n\n```javascript\n// models/blog.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n  @belongsTo('user', { async: true, inverse: null }) user;\n}\n\nlet blog = store.push({\n   data: {\n     type: 'blog',\n     id: 1,\n     relationships: {\n       user: {\n         data: { type: 'user', id: 1 }\n       }\n     }\n   }\n });\nlet userRef = blog.belongsTo('user');\n\nuserRef.value(); // null\n\nuserRef.load().then(function(user) {\n   userRef.value() === user\n });\n```\n\nYou may also pass in an options object whose properties will be\nfed forward. This enables you to pass `adapterOptions` into the\nrequest given to the adapter via the reference.\n\nExample\n\n```javascript\nuserRef.load({ adapterOptions: { isPrivate: true } }).then(function(user) {\n  userRef.value() === user;\n});\n```\n```app/adapters/user.js\nimport Adapter from '@ember-data/adapter';\n\nexport default class UserAdapter extends Adapter {\n  findRecord(store, type, id, snapshot) {\n    // In the adapter you will have access to adapterOptions.\n    let adapterOptions = snapshot.adapterOptions;\n  }\n});\n```",
      "itemtype": "method",
      "name": "load",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "the options to pass in.",
          "type": "Object"
        }
      ],
      "return": {
        "description": "a promise that resolves with the record in this belongs-to relationship.",
        "type": "Promise"
      },
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/belongs-to.ts",
      "line": 650,
      "description": "Triggers a reload of the value in this relationship. If the\nremoteType is `\"link\"` Ember Data will use the relationship link to\nreload the relationship. Otherwise it will reload the record by its\nid.\n\nExample\n\n```javascript\n// models/blog.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n  @belongsTo('user', { async: true, inverse: null }) user;\n}\n\nlet blog = store.push({\n   data: {\n     type: 'blog',\n     id: 1,\n     relationships: {\n       user: {\n         data: { type: 'user', id: 1 }\n       }\n     }\n   }\n });\nlet userRef = blog.belongsTo('user');\n\nuserRef.reload().then(function(user) {\n   userRef.value() === user\n });\n```\n\nYou may also pass in an options object whose properties will be\nfed forward. This enables you to pass `adapterOptions` into the\nrequest given to the adapter via the reference. A full example\ncan be found in the `load` method.\n\nExample\n\n```javascript\nuserRef.reload({ adapterOptions: { isPrivate: true } })\n```",
      "itemtype": "method",
      "name": "reload",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "the options to pass in.",
          "type": "Object"
        }
      ],
      "return": {
        "description": "a promise that resolves with the record in this belongs-to relationship after the reload has completed.",
        "type": "Promise"
      },
      "class": "BelongsToReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 81,
      "description": "The field name on the parent record for this has-many relationship.",
      "itemtype": "property",
      "name": "key",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 89,
      "description": "The type of resource this relationship will contain.",
      "itemtype": "property",
      "name": "type",
      "type": "String",
      "access": "public",
      "tagname": "",
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 143,
      "description": "An array of identifiers for the records that this reference refers to.",
      "itemtype": "property",
      "name": "identifiers",
      "type": "StableRecordIdentifier[]",
      "access": "public",
      "tagname": "",
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 197,
      "description": "This returns a string that represents how the reference will be\nlooked up when it is loaded. If the relationship has a link it will\nuse the \"link\" otherwise it defaults to \"id\".\n\nExample\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment', { async: true, inverse: null }) comments;\n}\n```\n\n```javascript\nlet post = store.push({\n  data: {\n    type: 'post',\n    id: 1,\n    relationships: {\n      comments: {\n        data: [{ type: 'comment', id: 1 }]\n      }\n    }\n  }\n});\n\nlet commentsRef = post.hasMany('comments');\n\n// get the identifier of the reference\nif (commentsRef.remoteType() === \"ids\") {\n  let ids = commentsRef.ids();\n} else if (commentsRef.remoteType() === \"link\") {\n  let link = commentsRef.link();\n}\n```",
      "itemtype": "method",
      "name": "remoteType",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The name of the remote type. This should either be `link` or `ids`",
        "type": "String"
      },
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 248,
      "description": "`ids()` returns an array of the record IDs in this relationship.\n\nExample\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment', { async: true, inverse: null }) comments;\n}\n```\n\n```javascript\nlet post = store.push({\n  data: {\n    type: 'post',\n    id: 1,\n    relationships: {\n      comments: {\n        data: [{ type: 'comment', id: 1 }]\n      }\n    }\n  }\n});\n\nlet commentsRef = post.hasMany('comments');\n\ncommentsRef.ids(); // ['1']\n```",
      "itemtype": "method",
      "name": "ids",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The ids in this has-many relationship",
        "type": "Array"
      },
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 287,
      "description": "The link Ember Data will use to fetch or reload this belongs-to\nrelationship. By default it uses only the \"related\" resource linkage.\n\nExample\n\n```javascript\n// models/blog.js\nimport Model, { belongsTo } from '@ember-data/model';\nexport default Model.extend({\n   user: belongsTo('user', { async: true, inverse: null })\n });\n\nlet blog = store.push({\n   data: {\n     type: 'blog',\n     id: 1,\n     relationships: {\n       user: {\n         links: {\n           related: '/articles/1/author'\n         }\n       }\n     }\n   }\n });\nlet userRef = blog.belongsTo('user');\n\n// get the identifier of the reference\nif (userRef.remoteType() === \"link\") {\n   let link = userRef.link();\n }\n```",
      "itemtype": "method",
      "name": "link",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The link Ember Data will use to fetch or reload this belongs-to relationship.",
        "type": "String"
      },
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 337,
      "description": "any links that have been received for this relationship",
      "itemtype": "method",
      "name": "links",
      "access": "public",
      "tagname": "",
      "return": {
        "description": ""
      },
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 350,
      "description": "The meta data for the has-many relationship.\n\nExample\n\n```javascript\n// models/blog.js\nimport Model, { hasMany } from '@ember-data/model';\nexport default Model.extend({\n   users: hasMany('user', { async: true, inverse: null })\n });\n\nlet blog = store.push({\n   data: {\n     type: 'blog',\n     id: 1,\n     relationships: {\n       users: {\n         links: {\n           related: {\n             href: '/articles/1/authors'\n           },\n         },\n         meta: {\n           lastUpdated: 1458014400000\n         }\n       }\n     }\n   }\n });\n\nlet usersRef = blog.hasMany('user');\n\nusersRef.meta() // { lastUpdated: 1458014400000 }\n```",
      "itemtype": "method",
      "name": "meta",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The meta information for the belongs-to relationship.",
        "type": "Object|null"
      },
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 399,
      "description": "`push` can be used to update the data in the relationship and EmberData\nwill treat the new data as the canonical value of this relationship on\nthe backend. An empty array will signify the canonical value should be\nempty.\n\nExample model\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment', { async: true, inverse: null }) comments;\n}\n```\n\nSetup some initial state, note we haven't loaded the comments yet:\n\n```js\nconst post = store.push({\n  data: {\n    type: 'post',\n    id: '1',\n    relationships: {\n      comments: {\n        data: [{ type: 'comment', id: '1' }]\n      }\n    }\n  }\n});\n\nconst commentsRef = post.hasMany('comments');\ncommentsRef.ids(); // ['1']\n```\n\nUpdate the state using `push`, note we can do this even without\nhaving loaded these comments yet by providing resource identifiers.\n\nBoth full resources and resource identifiers are supported.\n\n```js\nawait commentsRef.push({\n data: [\n  { type: 'comment', id: '2' },\n  { type: 'comment', id: '3' },\n ]\n});\n\ncommentsRef.ids(); // ['2', '3']\n```\n\nFor convenience, you can also pass in an array of resources or resource identifiers\nwithout wrapping them in the `data` property:\n\n```js\nawait commentsRef.push([\n  { type: 'comment', id: '4' },\n  { type: 'comment', id: '5' },\n]);\n\ncommentsRef.ids(); // ['4', '5']\n```\n\nWhen using the `data` property, you may also include other resource data via included,\nas well as provide new links and meta to the relationship.\n\n```js\nawait commentsRef.push({\n  links: {\n    related: '/posts/1/comments'\n  },\n  meta: {\n    total: 2\n  },\n  data: [\n    { type: 'comment', id: '4' },\n    { type: 'comment', id: '5' },\n  ],\n  included: [\n    { type: 'other-thing', id: '1', attributes: { foo: 'bar' },\n  ]\n});\n```\n\nBy default, the store will attempt to fetch any unloaded records before resolving\nthe returned promise with the ManyArray.\n\nAlternatively, pass `true` as the second argument to avoid fetching unloaded records\nand instead the promise will resolve with void without attempting to fetch. This is\nparticularly useful if you want to update the state of the relationship without\nforcing the load of all of the associated records.",
      "itemtype": "method",
      "name": "push",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "doc",
          "description": "a JSONAPI document object describing the new value of this relationship.",
          "type": "Array|Object"
        },
        {
          "name": "skipFetch",
          "description": "if `true`, do not attempt to fetch unloaded records",
          "type": "Boolean",
          "optional": true
        }
      ],
      "return": {
        "description": "",
        "type": "Promise<ManyArray | void>"
      },
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 562,
      "description": "`value()` synchronously returns the current value of the has-many\nrelationship. Unlike `record.relationshipName`, calling\n`value()` on a reference does not trigger a fetch if the async\nrelationship is not yet loaded. If the relationship is not loaded\nit will always return `null`.\n\nExample\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment', { async: true, inverse: null }) comments;\n}\n```\n\n```javascript\nlet post = store.push({\n  data: {\n    type: 'post',\n    id: 1,\n    relationships: {\n      comments: {\n        data: [{ type: 'comment', id: 1 }]\n      }\n    }\n  }\n});\n\nlet commentsRef = post.hasMany('comments');\n\npost.comments.then(function(comments) {\n  commentsRef.value() === comments\n})\n```",
      "itemtype": "method",
      "name": "value",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "",
        "type": "ManyArray"
      },
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 617,
      "description": "Loads the relationship if it is not already loaded.  If the\nrelationship is already loaded this method does not trigger a new\nload. This causes a request to the specified\nrelationship link or reloads all items currently in the relationship.\n\nExample\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment', { async: true, inverse: null }) comments;\n}\n```\n\n```javascript\nlet post = store.push({\n  data: {\n    type: 'post',\n    id: 1,\n    relationships: {\n      comments: {\n        data: [{ type: 'comment', id: 1 }]\n      }\n    }\n  }\n});\n\nlet commentsRef = post.hasMany('comments');\n\ncommentsRef.load().then(function(comments) {\n  //...\n});\n```\n\nYou may also pass in an options object whose properties will be\nfed forward. This enables you to pass `adapterOptions` into the\nrequest given to the adapter via the reference.\n\nExample\n\n```javascript\ncommentsRef.load({ adapterOptions: { isPrivate: true } })\n  .then(function(comments) {\n    //...\n  });\n```\n\n```app/adapters/comment.js\nexport default ApplicationAdapter.extend({\n  findMany(store, type, id, snapshots) {\n    // In the adapter you will have access to adapterOptions.\n    let adapterOptions = snapshots[0].adapterOptions;\n  }\n});\n```",
      "itemtype": "method",
      "name": "load",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "the options to pass in.",
          "type": "Object"
        }
      ],
      "return": {
        "description": "a promise that resolves with the ManyArray in\nthis has-many relationship.",
        "type": "Promise"
      },
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/references/has-many.ts",
      "line": 694,
      "description": "Reloads this has-many relationship. This causes a request to the specified\nrelationship link or reloads all items currently in the relationship.\n\nExample\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment', { async: true, inverse: null }) comments;\n}\n```\n\n```javascript\nlet post = store.push({\n  data: {\n    type: 'post',\n    id: 1,\n    relationships: {\n      comments: {\n        data: [{ type: 'comment', id: 1 }]\n      }\n    }\n  }\n});\n\nlet commentsRef = post.hasMany('comments');\n\ncommentsRef.reload().then(function(comments) {\n  //...\n});\n```\n\nYou may also pass in an options object whose properties will be\nfed forward. This enables you to pass `adapterOptions` into the\nrequest given to the adapter via the reference. A full example\ncan be found in the `load` method.\n\nExample\n\n```javascript\ncommentsRef.reload({ adapterOptions: { isPrivate: true } })\n```",
      "itemtype": "method",
      "name": "reload",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "the options to pass in.",
          "type": "Object"
        }
      ],
      "return": {
        "description": "a promise that resolves with the ManyArray in this has-many relationship.",
        "type": "Promise"
      },
      "class": "HasManyReference",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/attr.ts",
      "line": 190,
      "description": "`attr` defines an attribute on a [Model](/ember-data/release/classes/Model).\nBy default, attributes are passed through as-is, however you can specify an\noptional type to have the value automatically transformed.\nEmberData ships with four basic transform types: `string`, `number`,\n`boolean` and `date`. You can define your own transforms by subclassing\n[Transform](/ember-data/release/classes/Transform).\n\nNote that you cannot use `attr` to define an attribute of `id`.\n\n`attr` takes an optional hash as a second parameter, currently\nsupported options are:\n\n- `defaultValue`: Pass a string or a function to be called to set the attribute\nto a default value if and only if the key is absent from the payload response.\n\nExample\n\n```app/models/user.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('string') username;\n  @attr('string') email;\n  @attr('boolean', { defaultValue: false }) verified;\n}\n```\n\nDefault value can also be a function. This is useful it you want to return\na new object for each attribute.\n\n```app/models/user.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('string') username;\n  @attr('string') email;\n\n  @attr({\n    defaultValue() {\n      return {};\n    }\n  })\n  settings;\n}\n```\n\nThe `options` hash is passed as second argument to a transforms'\n`serialize` and `deserialize` method. This allows to configure a\ntransformation and adapt the corresponding value, based on the config:\n\n```app/models/post.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @attr('text', {\n    uppercase: true\n  })\n  text;\n}\n```\n\n```app/transforms/text.js\nexport default class TextTransform {\n  serialize(value, options) {\n    if (options.uppercase) {\n      return value.toUpperCase();\n    }\n\n    return value;\n  }\n\n  deserialize(value) {\n    return value;\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```",
      "itemtype": "method",
      "name": "attr",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "type",
          "description": "the attribute type",
          "type": "String|Object"
        },
        {
          "name": "options",
          "description": "a hash of options",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Attribute"
      },
      "class": "@ember-data/model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/belongs-to.ts",
      "line": 114,
      "description": "`belongsTo` is used to define One-To-One and One-To-Many, and One-To-None\nrelationships on a [Model](/ember-data/release/classes/Model).\n\n`belongsTo` takes a configuration hash as a second parameter, currently\nsupported options are:\n\n- `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n- `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n- `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n- `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n### Examples\n\nTo declare a **one-to-many** (or many-to-many) relationship, use\n`belongsTo` in combination with `hasMany`:\n\n```js\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('post', { async: false, inverse: 'comments' }) post;\n}\n\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'post' }) comments;\n}\n```\n\nTo declare a **one-to-one** relationship with managed inverses, use `belongsTo` for both sides:\n\n```js\n// app/models/author.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Author extends Model {\n  @belongsTo('address', { async: true, inverse: 'owner' }) address;\n}\n\n// app/models/address.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Address extends Model {\n  @belongsTo('author', { async: true, inverse: 'address' }) owner;\n}\n```\n\nTo declare a **one-to-one** relationship without managed inverses, use `belongsTo` for both sides\nwith `null` as the inverse:\n\n```js\n// app/models/author.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Author extends Model {\n  @belongsTo('address', { async: true, inverse: null }) address;\n}\n\n// app/models/address.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Address extends Model {\n  @belongsTo('author', { async: true, inverse: null }) owner;\n}\n```\n\nTo declare a one-to-none relationship between two models, use\n`belongsTo` with inverse set to `null` on just one side::\n\n```js\n// app/models/person.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Person extends Model {\n  @belongsTo('person', { async: false, inverse: null }) bestFriend;\n}\n```\n\n#### Sync vs Async Relationships\n\nEmberData fulfills relationships using resource data available in\nthe cache.\n\nSync relationships point directly to the known related resources.\n\nWhen a relationship is declared as async, if any of the known related\nresources have not been loaded, they will be fetched. The property\non the record when accessed provides a promise that resolves once\nall resources are loaded.\n\nAsync relationships may take advantage of links. On access, if the related\nlink has not been loaded, or if any known resources are not available in\nthe cache, the fresh state will be fetched using the link.\n\nIn contrast to async relationship, accessing a sync relationship\nwill error on access when any of the known related resources have\nnot been loaded.\n\nIf you are using `links` with sync relationships, you have to use\nthe BelongsTo reference API to fetch or refresh related resources\nthat aren't loaded. For instance, for a `bestFriend` relationship:\n\n```js\nperson.belongsTo('bestFriend').reload();\n```\n\n#### Polymorphic Relationships\n\nTo declare a polymorphic relationship, use `hasMany` with the `polymorphic`\noption set to `true`:\n\n```js\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n}\n```\n\n`'commentable'` here is referred to as the \"abstract type\" for the polymorphic\nrelationship.\n\nPolymorphic relationships with `inverse: null` will accept any type of record as their content.\nPolymorphic relationships with `inverse` set to a string will only accept records with a matching\ninverse relationships declaring itself as satisfying the abstract type.\n\nBelow, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\nfor this relationship.\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n}\n```\n\nNote: every Model that declares an inverse to a polymorphic relationship must\ndeclare itself exactly the same. This is because polymorphism is based on structural\ntraits.\n\nPolymorphic to polymorphic relationships are supported. Both sides of the relationship\nmust be declared as polymorphic, and the `as` option must be used to declare the abstract\ntype each record satisfies on both sides.",
      "itemtype": "method",
      "name": "belongsTo",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "type",
          "description": "(optional) the name of the related resource",
          "type": "String"
        },
        {
          "name": "options",
          "description": "(optional) a hash of options",
          "type": "Object"
        }
      ],
      "return": {
        "description": "relationship",
        "type": "PropertyDescriptor"
      },
      "class": "@ember-data/model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 106,
      "itemtype": "property",
      "name": "errorsByAttributeName",
      "type": "{MapWithDefault}",
      "access": "private",
      "tagname": "",
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 116,
      "description": "Returns errors for a given attribute\n\n```javascript\nlet user = store.createRecord('user', {\n  username: 'tomster',\n  email: 'invalidEmail'\n});\nuser.save().catch(function(){\n  user.errors.errorsFor('email'); // returns:\n  // [{attribute: \"email\", message: \"Doesn't look like a valid email.\"}]\n});\n```",
      "itemtype": "method",
      "name": "errorsFor",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "attribute",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "Array"
      },
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 154,
      "description": "An array containing all of the error messages for this\nrecord. This is useful for displaying all errors to the user.\n\n```handlebars\n{{#each @model.errors.messages as |message|}}\n  <div class=\"error\">\n    {{message}}\n  </div>\n{{/each}}\n```",
      "itemtype": "property",
      "name": "messages",
      "access": "public",
      "tagname": "",
      "type": "{Array}",
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 173,
      "itemtype": "property",
      "name": "content",
      "type": "{Array}",
      "access": "private",
      "tagname": "",
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 183,
      "itemtype": "method",
      "name": "unknownProperty",
      "access": "private",
      "tagname": "",
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 195,
      "description": "Total number of errors.",
      "itemtype": "property",
      "name": "length",
      "type": "{Number}",
      "access": "public",
      "tagname": "",
      "readonly": "",
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 204,
      "description": "`true` if we have no errors.",
      "itemtype": "property",
      "name": "isEmpty",
      "type": "{Boolean}",
      "access": "public",
      "tagname": "",
      "readonly": "",
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 215,
      "description": "Manually adds errors to the record. This will trigger the `becameInvalid` event/ lifecycle method on\n the record and transition the record into an `invalid` state.\n\nExample\n```javascript\n let errors = user.errors;\n\n // add multiple errors\n errors.add('password', [\n   'Must be at least 12 characters',\n   'Must contain at least one symbol',\n   'Cannot contain your name'\n ]);\n\n errors.errorsFor('password');\n // =>\n // [\n //   { attribute: 'password', message: 'Must be at least 12 characters' },\n //   { attribute: 'password', message: 'Must contain at least one symbol' },\n //   { attribute: 'password', message: 'Cannot contain your name' },\n // ]\n\n // add a single error\n errors.add('username', 'This field is required');\n\n errors.errorsFor('username');\n // =>\n // [\n //   { attribute: 'username', message: 'This field is required' },\n // ]\n```",
      "itemtype": "method",
      "name": "add",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "attribute",
          "description": "- the property name of an attribute or relationship",
          "type": "String"
        },
        {
          "name": "messages",
          "description": "- an error message or array of error messages for the attribute",
          "type": "String[]|string"
        }
      ],
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 262,
      "itemtype": "method",
      "name": "_findOrCreateMessages",
      "access": "private",
      "tagname": "",
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 287,
      "description": "Manually removes all errors for a given member from the record.\n  This will transition the record into a `valid` state, and\n triggers the `becameValid` event and lifecycle method.\n\nExample:\n\n```javascript\n let errors = user.errors;\n errors.add('phone', ['error-1', 'error-2']);\n\n errors.errorsFor('phone');\n // =>\n // [\n //   { attribute: 'phone', message: 'error-1' },\n //   { attribute: 'phone', message: 'error-2' },\n // ]\n\n errors.remove('phone');\n\n errors.errorsFor('phone');\n // => undefined\n```",
      "itemtype": "method",
      "name": "remove",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "member",
          "description": "- the property name of an attribute or relationship",
          "type": "String"
        }
      ],
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 338,
      "description": "Manually clears all errors for the record.\n  This will transition the record into a `valid` state, and\n  will trigger the `becameValid` event and lifecycle method.\n\n  Example:\n\n```javascript\nlet errors = user.errors;\nerrors.add('username', ['error-a']);\nerrors.add('phone', ['error-1', 'error-2']);\n\nerrors.errorsFor('username');\n// =>\n// [\n//   { attribute: 'username', message: 'error-a' },\n// ]\n\nerrors.errorsFor('phone');\n// =>\n// [\n//   { attribute: 'phone', message: 'error-1' },\n//   { attribute: 'phone', message: 'error-2' },\n// ]\n\nerrors.clear();\n\nerrors.errorsFor('username');\n// => undefined\n\nerrors.errorsFor('phone');\n// => undefined\n\nerrors.messages\n// => []\n```",
      "itemtype": "method",
      "name": "clear",
      "access": "public",
      "tagname": "",
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/errors.ts",
      "line": 398,
      "description": "Checks if there are error messages for the given attribute.\n\n```app/controllers/user/edit.js\nexport default class UserEditController extends Controller {\n  @action\n  save(user) {\n    if (user.errors.has('email')) {\n      return alert('Please update your email before attempting to save.');\n    }\n    user.save();\n  }\n}\n```",
      "itemtype": "method",
      "name": "has",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "attribute",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "true if there some errors on given attribute",
        "type": "Boolean"
      },
      "class": "Errors",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/has-many.ts",
      "line": 94,
      "description": "`hasMany` is used to define Many-To-One and Many-To-Many, and Many-To-None\nrelationships on a [Model](/ember-data/release/classes/Model).\n\n`hasMany` takes a configuration hash as a second parameter, currently\nsupported options are:\n\n- `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n- `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n- `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n- `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n### Examples\n\nTo declare a **many-to-one** (or one-to-many) relationship, use\n`belongsTo` in combination with `hasMany`:\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'post' }) comments;\n}\n\n\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('post', { async: false, inverse: 'comments' }) post;\n}\n```\n\nTo declare a **many-to-many** relationship with managed inverses, use `hasMany` for both sides:\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('tag', { async: true, inverse: 'posts' }) tags;\n}\n\n// app/models/tag.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Tag extends Model {\n  @hasMany('post', { async: true, inverse: 'tags' }) posts;\n}\n```\n\nTo declare a **many-to-many** relationship without managed inverses, use `hasMany` for both sides\nwith `null` as the inverse:\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('tag', { async: true, inverse: null }) tags;\n}\n\n// app/models/tag.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Tag extends Model {\n  @hasMany('post', { async: true, inverse: null }) posts;\n}\n```\n\nTo declare a many-to-none relationship between two models, use\n`hasMany` with inverse set to `null` on just one side::\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('category', { async: true, inverse: null }) categories;\n}\n```\n\n#### Sync vs Async Relationships\n\nEmberData fulfills relationships using resource data available in\nthe cache.\n\nSync relationships point directly to the known related resources.\n\nWhen a relationship is declared as async, if any of the known related\nresources have not been loaded, they will be fetched. The property\non the record when accessed provides a promise that resolves once\nall resources are loaded.\n\nAsync relationships may take advantage of links. On access, if the related\nlink has not been loaded, or if any known resources are not available in\nthe cache, the fresh state will be fetched using the link.\n\nIn contrast to async relationship, accessing a sync relationship\nwill error on access when any of the known related resources have\nnot been loaded.\n\nIf you are using `links` with sync relationships, you have to use\nthe HasMany reference API to fetch or refresh related resources\nthat aren't loaded. For instance, for a `comments` relationship:\n\n```js\npost.hasMany('comments').reload();\n```\n\n#### Polymorphic Relationships\n\nTo declare a polymorphic relationship, use `hasMany` with the `polymorphic`\noption set to `true`:\n\n```js\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n}\n```\n\n`'commentable'` here is referred to as the \"abstract type\" for the polymorphic\nrelationship.\n\nPolymorphic relationships with `inverse: null` will accept any type of record as their content.\nPolymorphic relationships with `inverse` set to a string will only accept records with a matching\ninverse relationships declaring itself as satisfying the abstract type.\n\nBelow, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\nfor this relationship.\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n}\n```\n\nNote: every Model that declares an inverse to a polymorphic relationship must\ndeclare itself exactly the same. This is because polymorphism is based on structural\ntraits.\n\nPolymorphic to polymorphic relationships are supported. Both sides of the relationship\nmust be declared as polymorphic, and the `as` option must be used to declare the abstract\ntype each record satisfies on both sides.",
      "itemtype": "method",
      "name": "hasMany",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "type",
          "description": "(optional) the name of the related resource",
          "type": "String"
        },
        {
          "name": "options",
          "description": "(optional) a hash of options",
          "type": "Object"
        }
      ],
      "return": {
        "description": "relationship",
        "type": "PropertyDescriptor"
      },
      "class": "@ember-data/model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 203,
      "description": "If this property is `true` the record is in the `empty`\nstate. Empty is the first state all records enter after they have\nbeen created. Most records created by the store will quickly\ntransition to the `loading` state if data needs to be fetched from\nthe server or the `created` state if the record is created on the\nclient. A record can also enter the empty state if the adapter is\nunable to locate the record.",
      "itemtype": "property",
      "name": "isEmpty",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 222,
      "description": "If this property is `true` the record is in the `loading` state. A\nrecord enters this state when the store asks the adapter for its\ndata. It remains in this state until the adapter provides the\nrequested data.",
      "itemtype": "property",
      "name": "isLoading",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 238,
      "description": "If this property is `true` the record is in the `loaded` state. A\nrecord enters this state when its data is populated. Most of a\nrecord's lifecycle is spent inside substates of the `loaded`\nstate.\n\nExample\n\n```javascript\nlet record = store.createRecord('model');\nrecord.isLoaded; // true\n\nconst { content: { data: model } } = await store.request(findRecord({ type: 'model', id: '1' }));\nmodel.isLoaded;\n```",
      "itemtype": "property",
      "name": "isLoaded",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 264,
      "description": "If this property is `true` the record is in the `dirty` state. The\nrecord has local changes that have not yet been saved by the\nadapter. This includes records that have been created (but not yet\nsaved) or deleted.\n\nExample\n\n```javascript\nlet record = store.createRecord('model');\nrecord.hasDirtyAttributes; // true\n\nconst { content: { data: model } } = await store.request(findRecord({ type: 'model', id: '1' }));\n\nmodel.hasDirtyAttributes; // false\nmodel.foo = 'some value';\nmodel.hasDirtyAttributes; // true\n```",
      "since": "1.13.0",
      "itemtype": "property",
      "name": "hasDirtyAttributes",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 294,
      "description": "If this property is `true` the record is in the `saving` state. A\nrecord enters the saving state when `save` is called, but the\nadapter has not yet acknowledged that the changes have been\npersisted to the backend.\n\nExample\n\n```javascript\nlet record = store.createRecord('model');\nrecord.isSaving; // false\nlet promise = record.save();\nrecord.isSaving; // true\npromise.then(function() {\n  record.isSaving; // false\n});\n```",
      "itemtype": "property",
      "name": "isSaving",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 322,
      "description": "If this property is `true` the record is in the `deleted` state\nand has been marked for deletion. When `isDeleted` is true and\n`hasDirtyAttributes` is true, the record is deleted locally but the deletion\nwas not yet persisted. When `isSaving` is true, the change is\nin-flight. When both `hasDirtyAttributes` and `isSaving` are false, the\nchange has persisted.\n\nExample\n\n```javascript\nlet record = store.createRecord('model');\nrecord.isDeleted;    // false\nrecord.deleteRecord();\n\n// Locally deleted\nrecord.isDeleted;           // true\nrecord.hasDirtyAttributes;  // true\nrecord.isSaving;            // false\n\n// Persisting the deletion\nlet promise = record.save();\nrecord.isDeleted;    // true\nrecord.isSaving;     // true\n\n// Deletion Persisted\npromise.then(function() {\n  record.isDeleted;          // true\n  record.isSaving;           // false\n  record.hasDirtyAttributes; // false\n});\n```",
      "itemtype": "property",
      "name": "isDeleted",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 365,
      "description": "If this property is `true` the record is in the `new` state. A\nrecord will be in the `new` state when it has been created on the\nclient and the adapter has not yet report that it was successfully\nsaved.\n\nExample\n\n```javascript\nlet record = store.createRecord('model');\nrecord.isNew; // true\n\nrecord.save().then(function(model) {\n  model.isNew; // false\n});\n```",
      "itemtype": "property",
      "name": "isNew",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 392,
      "description": "If this property is `true` the record is in the `valid` state.\n\nA record will be in the `valid` state when the adapter did not report any\nserver-side validation failures.",
      "itemtype": "property",
      "name": "isValid",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 408,
      "description": "If the record is in the dirty state this property will report what\nkind of change has caused it to move into the dirty\nstate. Possible values are:\n\n- `created` The record has been created by the client and not yet saved to the adapter.\n- `updated` The record has been updated by the client and not yet saved to the adapter.\n- `deleted` The record has been deleted by the client and not yet saved to the adapter.\n\nExample\n\n```javascript\nlet record = store.createRecord('model');\nrecord.dirtyType; // 'created'\n```",
      "itemtype": "property",
      "name": "dirtyType",
      "access": "public",
      "tagname": "",
      "type": "{String}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 434,
      "description": "If `true` the adapter reported that it was unable to save local\nchanges to the backend for any reason other than a server-side\nvalidation error.\n\nExample\n\n```javascript\nrecord.isError; // false\nrecord.set('foo', 'valid value');\nrecord.save().then(null, function() {\n  record.isError; // true\n});\n```",
      "itemtype": "property",
      "name": "isError",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 464,
      "description": "If `true` the store is attempting to reload the record from the adapter.\n\nExample\n\n```javascript\nrecord.isReloading; // false\nrecord.reload();\nrecord.isReloading; // true\n```",
      "itemtype": "property",
      "name": "isReloading",
      "access": "public",
      "tagname": "",
      "type": "{Boolean}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 482,
      "description": "All ember models have an id property. This is an identifier\nmanaged by an external source. These are always coerced to be\nstrings before being used internally. Note when declaring the\nattributes for a model it is an error to declare an id\nattribute.\n\n```javascript\nlet record = store.createRecord('model');\nrecord.id; // null\n\nconst { content: { data: model } } = await store.request(findRecord({ type: 'model', id: '1' }));\nmodel.id; // '1'\n```",
      "itemtype": "property",
      "name": "id",
      "access": "public",
      "tagname": "",
      "type": "{String}",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 534,
      "itemtype": "property",
      "name": "currentState",
      "access": "private",
      "tagname": "",
      "type": "{Object}",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 558,
      "description": "The store service instance which created this record instance",
      "itemtype": "property",
      "name": "store",
      "access": "public",
      "tagname": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 565,
      "description": "When the record is in the `invalid` state this object will contain\nany errors returned by the adapter. When present the errors hash\ncontains keys corresponding to the invalid property names\nand values which are arrays of Javascript objects with two keys:\n\n- `message` A string containing the error message from the backend\n- `attribute` The name of the property associated with this error message\n\n```javascript\nrecord.errors.length; // 0\nrecord.set('foo', 'invalid value');\nrecord.save().catch(function() {\n  record.errors.foo;\n  // [{message: 'foo should be a number.', attribute: 'foo'}]\n});\n```\n\nThe `errors` property is useful for displaying error messages to\nthe user.\n\n```handlebars\n<label>Username: <Input @value={{@model.username}} /> </label>\n{{#each @model.errors.username as |error|}}\n  <div class=\"error\">\n    {{error.message}}\n  </div>\n{{/each}}\n<label>Email: <Input @value={{@model.email}} /> </label>\n{{#each @model.errors.email as |error|}}\n  <div class=\"error\">\n    {{error.message}}\n  </div>\n{{/each}}\n```\n\n\nYou can also access the special `messages` property on the error\nobject to get an array of all the error strings.\n\n```handlebars\n{{#each @model.errors.messages as |message|}}\n  <div class=\"error\">\n    {{message}}\n  </div>\n{{/each}}\n```",
      "itemtype": "property",
      "name": "errors",
      "access": "public",
      "tagname": "",
      "type": "{Errors}",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 624,
      "description": "This property holds the `AdapterError` object with which\nlast adapter operation was rejected.",
      "itemtype": "property",
      "name": "adapterError",
      "access": "public",
      "tagname": "",
      "type": "{AdapterError}",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 640,
      "description": "Create a JSON representation of the record, using the serialization\nstrategy of the store's adapter.\n\n   `serialize` takes an optional hash as a parameter, currently\nsupported options are:\n\n   - `includeId`: `true` if the record's ID should be included in the\n  JSON representation.",
      "itemtype": "method",
      "name": "serialize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "an object whose values are primitive JSON values only",
        "type": "Object"
      },
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 669,
      "description": "Marks the record as deleted but does not save it. You must call\n`save` afterwards if you want to persist it. You might use this\nmethod if you want to allow the user to still `rollbackAttributes()`\nafter a delete was made.\n\nExample\n\n```js\nimport Component from '@glimmer/component';\n\nexport default class extends Component {\n  softDelete = () => {\n    this.args.model.deleteRecord();\n  }\n\n  confirm = () => {\n    this.args.model.save();\n  }\n\n  undo = () => {\n    this.args.model.rollbackAttributes();\n  }\n}\n```",
      "itemtype": "method",
      "name": "deleteRecord",
      "access": "public",
      "tagname": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 699,
      "description": "Same as `deleteRecord`, but saves the record immediately.\n\nExample\n\n```js\nimport Component from '@glimmer/component';\n\nexport default class extends Component {\n  delete = () => {\n    this.args.model.destroyRecord().then(function() {\n      this.transitionToRoute('model.index');\n    });\n  }\n}\n```\n\nIf you pass an object on the `adapterOptions` property of the options\nargument it will be passed to your adapter via the snapshot\n\n```js\nrecord.destroyRecord({ adapterOptions: { subscribe: false } });\n```\n\n```app/adapters/post.js\nimport MyCustomAdapter from './custom-adapter';\n\nexport default class PostAdapter extends MyCustomAdapter {\n  deleteRecord(store, type, snapshot) {\n    if (snapshot.adapterOptions.subscribe) {\n      // ...\n    }\n    // ...\n  }\n}\n```",
      "itemtype": "method",
      "name": "destroyRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "a promise that will be resolved when the adapter returns\nsuccessfully or rejected if the adapter returns with an error.",
        "type": "Promise"
      },
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 743,
      "description": "Unloads the record from the store. This will not send a delete request\nto your server, it just unloads the record from memory.",
      "itemtype": "method",
      "name": "unloadRecord",
      "access": "public",
      "tagname": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 751,
      "description": "Returns an object, whose keys are changed properties, and value is\nan [oldProp, newProp] array.\n\nThe array represents the diff of the canonical state with the local state\nof the model. Note: if the model is created locally, the canonical state is\nempty since the adapter hasn't acknowledged the attributes yet:\n\nExample\n\n```app/models/mascot.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class MascotModel extends Model {\n  @attr('string') name;\n  @attr('boolean', {\n    defaultValue: false\n  })\n  isAdmin;\n}\n```\n\n```javascript\nlet mascot = store.createRecord('mascot');\n\nmascot.changedAttributes(); // {}\n\nmascot.set('name', 'Tomster');\nmascot.changedAttributes(); // { name: [undefined, 'Tomster'] }\n\nmascot.set('isAdmin', true);\nmascot.changedAttributes(); // { isAdmin: [undefined, true], name: [undefined, 'Tomster'] }\n\nmascot.save().then(function() {\n  mascot.changedAttributes(); // {}\n\n  mascot.set('isAdmin', false);\n  mascot.changedAttributes(); // { isAdmin: [true, false] }\n});\n```",
      "itemtype": "method",
      "name": "changedAttributes",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "an object, whose keys are changed properties,\n  and value is an [oldProp, newProp] array.",
        "type": "Object"
      },
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 798,
      "description": "If the model `hasDirtyAttributes` this function will discard any unsaved\nchanges. If the model `isNew` it will be removed from the store.\n\nExample\n\n```javascript\nrecord.name; // 'Untitled Document'\nrecord.set('name', 'Doc 1');\nrecord.name; // 'Doc 1'\nrecord.rollbackAttributes();\nrecord.name; // 'Untitled Document'\n```",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "rollbackAttributes",
      "access": "public",
      "tagname": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 817,
      "itemtype": "method",
      "name": "_createSnapshot",
      "access": "private",
      "tagname": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 823,
      "description": "Save the record and persist any changes to the record to an\nexternal source via the adapter.\n\nExample\n\n```javascript\nrecord.set('name', 'Tomster');\nrecord.save().then(function() {\n  // Success callback\n}, function() {\n  // Error callback\n});\n```\n\n   If you pass an object using the `adapterOptions` property of the options\n   argument it will be passed to your adapter via the snapshot.\n\n```js\nrecord.save({ adapterOptions: { subscribe: false } });\n```\n\n```app/adapters/post.js\nimport MyCustomAdapter from './custom-adapter';\n\nexport default class PostAdapter extends MyCustomAdapter {\n  updateRecord(store, type, snapshot) {\n    if (snapshot.adapterOptions.subscribe) {\n      // ...\n    }\n    // ...\n  }\n}\n```",
      "itemtype": "method",
      "name": "save",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "a promise that will be resolved when the adapter returns\nsuccessfully or rejected if the adapter returns with an error.",
        "type": "Promise"
      },
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 865,
      "description": "Reload the record from the adapter.\n\nThis will only work if the record has already finished loading.\n\nExample\n\n```js\nimport Component from '@glimmer/component';\n\nexport default class extends Component {\n  async reload = () => {\n    await this.args.model.reload();\n    // do something with the reloaded model\n  }\n}\n```",
      "itemtype": "method",
      "name": "reload",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "optional, may include `adapterOptions` hash which will be passed to adapter request",
          "type": "Object"
        }
      ],
      "return": {
        "description": "a promise that will be resolved with the record when the\nadapter returns successfully or rejected if the adapter returns\nwith an error.",
        "type": "Promise"
      },
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 899,
      "description": "Get the reference for the specified belongsTo relationship.\n\nFor instance, given the following model\n\n```app/models/blog-post.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class BlogPost extends Model {\n  @belongsTo('user', { async: true, inverse: null }) author;\n}\n```\n\nThen the reference for the author relationship would be\nretrieved from a record instance like so:\n\n```js\nblogPost.belongsTo('author');\n```\n\nA `BelongsToReference` is a low-level API that allows access\nand manipulation of a belongsTo relationship.\n\nIt is especially useful when you're dealing with `async` relationships\nas it allows synchronous access to the relationship data if loaded, as\nwell as APIs for loading, reloading the data or accessing available\ninformation without triggering a load.\n\nIt may also be useful when using `sync` relationships that need to be\nloaded/reloaded with more precise timing than marking the\nrelationship as `async` and relying on autofetch would have allowed.\n\nHowever,keep in mind that marking a relationship as `async: false` will introduce\nbugs into your application if the data is not always guaranteed to be available\nby the time the relationship is accessed. Ergo, it is recommended when using this\napproach to utilize `links` for unloaded relationship state instead of identifiers.\n\nReference APIs are entangled with the relationship's underlying state,\nthus any getters or cached properties that utilize these will properly\ninvalidate if the relationship state changes.\n\nReferences are \"stable\", meaning that multiple calls to retrieve the reference\nfor a given relationship will always return the same HasManyReference.",
      "itemtype": "method",
      "name": "belongsTo",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "name",
          "description": "of the relationship",
          "type": "String"
        }
      ],
      "since": "2.5.0",
      "return": {
        "description": "reference for this relationship",
        "type": "BelongsToReference"
      },
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 950,
      "description": "Get the reference for the specified hasMany relationship.\n\nFor instance, given the following model\n\n```app/models/blog-post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class BlogPost extends Model {\n  @hasMany('comment', { async: true, inverse: null }) comments;\n}\n```\n\nThen the reference for the comments relationship would be\nretrieved from a record instance like so:\n\n```js\nblogPost.hasMany('comments');\n```\n\nA `HasManyReference` is a low-level API that allows access\nand manipulation of a hasMany relationship.\n\nIt is especially useful when you are dealing with `async` relationships\nas it allows synchronous access to the relationship data if loaded, as\nwell as APIs for loading, reloading the data or accessing available\ninformation without triggering a load.\n\nIt may also be useful when using `sync` relationships with `@ember-data/model`\nthat need to be loaded/reloaded with more precise timing than marking the\nrelationship as `async` and relying on autofetch would have allowed.\n\nHowever,keep in mind that marking a relationship as `async: false` will introduce\nbugs into your application if the data is not always guaranteed to be available\nby the time the relationship is accessed. Ergo, it is recommended when using this\napproach to utilize `links` for unloaded relationship state instead of identifiers.\n\nReference APIs are entangled with the relationship's underlying state,\nthus any getters or cached properties that utilize these will properly\ninvalidate if the relationship state changes.\n\nReferences are \"stable\", meaning that multiple calls to retrieve the reference\nfor a given relationship will always return the same HasManyReference.",
      "itemtype": "method",
      "name": "hasMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "name",
          "description": "of the relationship",
          "type": "String"
        }
      ],
      "since": "2.5.0",
      "return": {
        "description": "reference for this relationship",
        "type": "HasManyReference"
      },
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1001,
      "description": "Given a callback, iterates over each of the relationships in the model,\ninvoking the callback with the name of each relationship and its relationship\ndescriptor.\n\n\nThe callback method you provide should have the following signature (all\nparameters are optional):\n\n```javascript\nfunction(name, descriptor);\n```\n\n- `name` the name of the current property in the iteration\n- `descriptor` the meta object that describes this relationship\n\nThe relationship descriptor argument is an object with the following properties.\n\n- **name** <span class=\"type\">String</span> the name of this relationship on the Model\n- **kind** <span class=\"type\">String</span> \"hasMany\" or \"belongsTo\"\n- **options** <span class=\"type\">Object</span> the original options hash passed when the relationship was declared\n- **parentType** <span class=\"type\">Model</span> the type of the Model that owns this relationship\n- **type** <span class=\"type\">String</span> the type name of the related Model\n\nNote that in addition to a callback, you can also pass an optional target\nobject that will be set as `this` on the context.\n\nExample\n\n```app/serializers/application.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class ApplicationSerializer extends JSONSerializer {\n   serialize(record, options) {\n   let json = {};\n\n   record.eachRelationship(function(name, descriptor) {\n     if (descriptor.kind === 'hasMany') {\n       let serializedHasManyName = name.toUpperCase() + '_IDS';\n       json[serializedHasManyName] = record.get(name).map(r => r.id);\n     }\n   });\n\n   return json;\n }\n  }\n```",
      "itemtype": "method",
      "name": "eachRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "callback",
          "description": "the callback to invoke",
          "type": "Function"
        },
        {
          "name": "binding",
          "description": "the value to which the callback's `this` should be bound",
          "type": "Any"
        }
      ],
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1082,
      "description": "Create should only ever be called by the store. To create an instance of a\n`Model` in a dirty state use `store.createRecord`.\n\n   To create instances of `Model` in a clean state, use `store.push`",
      "itemtype": "method",
      "name": "create",
      "access": "private",
      "tagname": "",
      "static": 1,
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1093,
      "description": "Represents the model's class name as a string. This can be used to look up the model's class name through\n`Store`'s modelFor method.\n\n`modelName` is generated for you by EmberData. It will be a lowercased, dasherized string.\nFor example:\n\n```javascript\nstore.modelFor('post').modelName; // 'post'\nstore.modelFor('blog-post').modelName; // 'blog-post'\n```\n\nThe most common place you'll want to access `modelName` is in your serializer's `payloadKeyFromModelName` method. For example, to change payload\nkeys to underscore (instead of dasherized), you might use the following code:\n\n```javascript\nimport RESTSerializer from '@ember-data/serializer/rest';\nimport { underscore } from '<app-name>/utils/string-utils';\n\nexport default const PostSerializer = RESTSerializer.extend({\n  payloadKeyFromModelName(modelName) {\n    return underscore(modelName);\n  }\n});\n```",
      "itemtype": "property",
      "name": "modelName",
      "access": "public",
      "tagname": "",
      "type": "String",
      "readonly": "",
      "static": 1,
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1143,
      "description": "For a given relationship name, returns the model type of the relationship.\n\nFor example, if you define a model like this:\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment') comments;\n}\n```\n\nCalling `store.modelFor('post').typeForRelationship('comments', store)` will return `Comment`.",
      "itemtype": "method",
      "name": "typeForRelationship",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "name",
          "description": "the name of the relationship",
          "type": "String"
        },
        {
          "name": "store",
          "description": "an instance of Store",
          "type": "Store"
        }
      ],
      "return": {
        "description": "the type of the relationship, or undefined",
        "type": "Model"
      },
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1184,
      "description": "Find the relationship which is the inverse of the one asked for.\n\nFor example, if you define models like this:\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n   @hasMany('message') comments;\n }\n```\n\n```app/models/message.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class MessageModel extends Model {\n   @belongsTo('post') owner;\n }\n```\n\n``` js\nstore.modelFor('post').inverseFor('comments', store) // { type: 'message', name: 'owner', kind: 'belongsTo' }\nstore.modelFor('message').inverseFor('owner', store) // { type: 'post', name: 'comments', kind: 'hasMany' }\n```",
      "itemtype": "method",
      "name": "inverseFor",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "name",
          "description": "the name of the relationship",
          "type": "String"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        }
      ],
      "return": {
        "description": "the inverse relationship, or null",
        "type": "Object"
      },
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1276,
      "description": "The model's relationships as a map, keyed on the type of the\nrelationship. The value of each entry is an array containing a descriptor\nfor each relationship with that type, describing the name of the relationship\nas well as the type.\n\nFor example, given the following model definition:\n\n```app/models/blog.js\nimport Model, { belongsTo, hasMany } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n   @hasMany('user') users;\n   @belongsTo('user') owner;\n   @hasMany('post') posts;\n }\n```\n\nThis computed property would return a map describing these\nrelationships, like this:\n\n```javascript\nimport Blog from 'app/models/blog';\nimport User from 'app/models/user';\nimport Post from 'app/models/post';\n\nlet relationships = Blog.relationships;\nrelationships.user;\n//=> [ { name: 'users', kind: 'hasMany' },\n//     { name: 'owner', kind: 'belongsTo' } ]\nrelationships.post;\n//=> [ { name: 'posts', kind: 'hasMany' } ]\n```",
      "itemtype": "property",
      "name": "relationships",
      "access": "public",
      "tagname": "",
      "static": 1,
      "type": "Map",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1341,
      "description": "A hash containing lists of the model's relationships, grouped\nby the relationship kind. For example, given a model with this\ndefinition:\n\n```app/models/blog.js\nimport Model, { belongsTo, hasMany } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n   @hasMany('user') users;\n   @belongsTo('user') owner;\n\n   @hasMany('post') posts;\n }\n```\n\nThis property would contain the following:\n\n```javascript\nimport Blog from 'app/models/blog';\n\nlet relationshipNames = Blog.relationshipNames;\nrelationshipNames.hasMany;\n//=> ['users', 'posts']\nrelationshipNames.belongsTo;\n//=> ['owner']\n```",
      "itemtype": "property",
      "name": "relationshipNames",
      "access": "public",
      "tagname": "",
      "static": 1,
      "type": "Object",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1395,
      "description": "An array of types directly related to a model. Each type will be\nincluded once, regardless of the number of relationships it has with\nthe model.\n\nFor example, given a model with this definition:\n\n```app/models/blog.js\nimport Model, { belongsTo, hasMany } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n   @hasMany('user') users;\n   @belongsTo('user') owner;\n\n   @hasMany('post') posts;\n }\n```\n\nThis property would contain the following:\n\n```javascript\nimport Blog from 'app/models/blog';\n\nlet relatedTypes = Blog.relatedTypes');\n//=> ['user', 'post']\n```",
      "itemtype": "property",
      "name": "relatedTypes",
      "access": "public",
      "tagname": "",
      "static": 1,
      "type": "Array",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1455,
      "description": "A map whose keys are the relationships of a model and whose values are\nrelationship descriptors.\n\nFor example, given a model with this\ndefinition:\n\n```app/models/blog.js\nimport Model, { belongsTo, hasMany } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n   @hasMany('user') users;\n   @belongsTo('user') owner;\n\n   @hasMany('post') posts;\n }\n```\n\nThis property would contain the following:\n\n```javascript\nimport Blog from 'app/models/blog';\n\nlet relationshipsByName = Blog.relationshipsByName;\nrelationshipsByName.users;\n//=> { name: 'users', kind: 'hasMany', type: 'user', options: Object }\nrelationshipsByName.owner;\n//=> { name: 'owner', kind: 'belongsTo', type: 'user', options: Object }\n```",
      "itemtype": "property",
      "name": "relationshipsByName",
      "access": "public",
      "tagname": "",
      "static": 1,
      "type": "Map",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1538,
      "description": "A map whose keys are the fields of the model and whose values are strings\ndescribing the kind of the field. A model's fields are the union of all of its\nattributes and relationships.\n\nFor example:\n\n```app/models/blog.js\nimport Model, { attr, belongsTo, hasMany } from '@ember-data/model';\n\nexport default class BlogModel extends Model {\n   @hasMany('user') users;\n   @belongsTo('user') owner;\n\n   @hasMany('post') posts;\n\n   @attr('string') title;\n }\n```\n\n```js\nimport Blog from 'app/models/blog'\n\nlet fields = Blog.fields;\nfields.forEach(function(kind, field) {\n   // do thing\n });\n\n// prints:\n// users, hasMany\n// owner, belongsTo\n// posts, hasMany\n// title, attribute\n```",
      "itemtype": "property",
      "name": "fields",
      "access": "public",
      "tagname": "",
      "static": 1,
      "type": "Map",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1598,
      "description": "Given a callback, iterates over each of the relationships in the model,\ninvoking the callback with the name of each relationship and its relationship\ndescriptor.",
      "itemtype": "method",
      "name": "eachRelationship",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "callback",
          "description": "the callback to invoke",
          "type": "Function"
        },
        {
          "name": "binding",
          "description": "the value to which the callback's `this` should be bound",
          "type": "Any"
        }
      ],
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1627,
      "description": "Given a callback, iterates over each of the types related to a model,\ninvoking the callback with the related type's class. Each type will be\nreturned just once, regardless of how many different relationships it has\nwith a model.",
      "itemtype": "method",
      "name": "eachRelatedType",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "callback",
          "description": "the callback to invoke",
          "type": "Function"
        },
        {
          "name": "binding",
          "description": "the value to which the callback's `this` should be bound",
          "type": "Any"
        }
      ],
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1653,
      "itemtype": "method",
      "name": "determineRelationshipType",
      "access": "private",
      "tagname": "",
      "deprecated": true,
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1687,
      "description": "A map whose keys are the attributes of the model (properties\ndescribed by attr) and whose values are the meta object for the\nproperty.\n\nExample\n\n```app/models/person.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PersonModel extends Model {\n   @attr('string') firstName;\n   @attr('string') lastName;\n   @attr('date') birthday;\n }\n```\n\n```javascript\nimport Person from 'app/models/person'\n\nlet attributes = Person.attributes\n\nattributes.forEach(function(meta, name) {\n   // do thing\n });\n\n// prints:\n// firstName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"firstName\"}\n// lastName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"lastName\"}\n// birthday {type: \"date\", kind: 'attribute', options: Object, parentType: function, name: \"birthday\"}\n```",
      "itemtype": "property",
      "name": "attributes",
      "access": "public",
      "tagname": "",
      "static": 1,
      "type": "{Map}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1752,
      "description": "A map whose keys are the attributes of the model (properties\ndescribed by attr) and whose values are type of transformation\napplied to each attribute. This map does not include any\nattributes that do not have an transformation type.\n\nExample\n\n```app/models/person.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PersonModel extends Model {\n   @attr firstName;\n   @attr('string') lastName;\n   @attr('date') birthday;\n }\n```\n\n```javascript\nimport Person from 'app/models/person';\n\nlet transformedAttributes = Person.transformedAttributes\n\ntransformedAttributes.forEach(function(field, type) {\n   // do thing\n });\n\n// prints:\n// lastName string\n// birthday date\n```",
      "itemtype": "property",
      "name": "transformedAttributes",
      "access": "public",
      "tagname": "",
      "static": 1,
      "type": "{Map}",
      "readonly": "",
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1808,
      "description": "Iterates through the attributes of the model, calling the passed function on each\nattribute.\n\nThe callback method you provide should have the following signature (all\nparameters are optional):\n\n```javascript\nfunction(name, meta);\n```\n\n- `name` the name of the current property in the iteration\n- `meta` the meta object for the attribute property in the iteration\n\nNote that in addition to a callback, you can also pass an optional target\nobject that will be set as `this` on the context.\n\nExample\n\n```javascript\nimport Model, { attr } from '@ember-data/model';\n\nclass PersonModel extends Model {\n   @attr('string') firstName;\n   @attr('string') lastName;\n   @attr('date') birthday;\n }\n\nPersonModel.eachAttribute(function(name, meta) {\n   // do thing\n });\n\n// prints:\n// firstName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"firstName\"}\n// lastName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"lastName\"}\n// birthday {type: \"date\", kind: 'attribute', options: Object, parentType: function, name: \"birthday\"}\n```",
      "itemtype": "method",
      "name": "eachAttribute",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "callback",
          "description": "The callback to execute",
          "type": "Function"
        },
        {
          "name": "binding",
          "description": "the value to which the callback's `this` should be bound",
          "type": "Object",
          "optional": true
        }
      ],
      "static": 1,
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1866,
      "description": "Iterates through the transformedAttributes of the model, calling\nthe passed function on each attribute. Note the callback will not be\ncalled for any attributes that do not have an transformation type.\n\nThe callback method you provide should have the following signature (all\nparameters are optional):\n\n```javascript\nfunction(name, type);\n```\n\n- `name` the name of the current property in the iteration\n- `type` a string containing the name of the type of transformed\napplied to the attribute\n\nNote that in addition to a callback, you can also pass an optional target\nobject that will be set as `this` on the context.\n\nExample\n\n```javascript\nimport Model, { attr } from '@ember-data/model';\n\nlet Person = Model.extend({\n   firstName: attr(),\n   lastName: attr('string'),\n   birthday: attr('date')\n });\n\nPerson.eachTransformedAttribute(function(name, type) {\n   // do thing\n });\n\n// prints:\n// lastName string\n// birthday date\n```",
      "itemtype": "method",
      "name": "eachTransformedAttribute",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "callback",
          "description": "The callback to execute",
          "type": "Function"
        },
        {
          "name": "binding",
          "description": "the value to which the callback's `this` should be bound",
          "type": "Object",
          "optional": true
        }
      ],
      "static": 1,
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/model.ts",
      "line": 1925,
      "description": "Returns the name of the model class.",
      "itemtype": "method",
      "name": "toString",
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "Model",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 44,
      "description": "Retrieve the length of the content",
      "itemtype": "property",
      "name": "length",
      "access": "public",
      "tagname": "",
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 60,
      "description": "Iterate the proxied content. Called by the glimmer iterator in #each\nWe do not guarantee that forEach will always be available. This\nmay eventually be made to use Symbol.Iterator once glimmer supports it.",
      "itemtype": "method",
      "name": "forEach",
      "params": [
        {
          "name": "cb",
          "description": ""
        }
      ],
      "return": {
        "description": ""
      },
      "access": "private",
      "tagname": "",
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 76,
      "description": "Reload the relationship",
      "itemtype": "method",
      "name": "reload",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": ""
        }
      ],
      "return": {
        "description": ""
      },
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 91,
      "description": "Whether the loading promise is still pending",
      "itemtype": "property",
      "name": "isPending",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 98,
      "description": "Whether the loading promise rejected",
      "itemtype": "property",
      "name": "isRejected",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 105,
      "description": "Whether the loading promise succeeded",
      "itemtype": "property",
      "name": "isFulfilled",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 112,
      "description": "Whether the loading promise completed (resolved or rejected)",
      "itemtype": "property",
      "name": "isSettled",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 120,
      "description": "chain this promise",
      "itemtype": "method",
      "name": "then",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "success",
          "description": ""
        },
        {
          "name": "fail",
          "description": ""
        }
      ],
      "return": {
        "description": "Promise"
      },
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 133,
      "description": "catch errors thrown by this promise",
      "itemtype": "method",
      "name": "catch",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "callback",
          "description": ""
        }
      ],
      "return": {
        "description": "Promise"
      },
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 144,
      "description": "run cleanup after this promise completes",
      "itemtype": "method",
      "name": "finally",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "callback",
          "description": ""
        }
      ],
      "return": {
        "description": "Promise"
      },
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 166,
      "description": "Retrieve the links for this relationship",
      "itemtype": "property",
      "name": "links",
      "access": "public",
      "tagname": "",
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/model/src/-private/promise-many-array.ts",
      "line": 176,
      "description": "Retrieve the meta for this relationship",
      "itemtype": "property",
      "name": "meta",
      "access": "public",
      "tagname": "",
      "class": "PromiseManyArray",
      "module": "@ember-data/model"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 101,
      "description": "Sets the global configuration for `buildBaseURL`\nfor host and namespace values for the application.\n\nThese values may still be overridden by passing\nthem to buildBaseURL directly.\n\nThis method may be called as many times as needed.\nhost values of `''` or `'/'` are equivalent.\n\nExcept for the value of `/` as host, host should not\nend with `/`.\n\nnamespace should not start or end with a `/`.\n\n```ts\ntype BuildURLConfig = {\n  host: string;\n  namespace: string'\n}\n```\n\nExample:\n\n```ts\nimport { setBuildURLConfig } from '@ember-data/request-utils';\n\nsetBuildURLConfig({\n  host: 'https://api.example.com',\n  namespace: 'api/v1'\n});\n```",
      "itemtype": "method",
      "name": "setBuildURLConfig",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "config",
          "description": "",
          "type": "BuildURLConfig"
        }
      ],
      "return": {
        "description": "void"
      },
      "class": "@ember-data/request-utils",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 278,
      "description": "Builds a URL for a request based on the provided options.\nDoes not include support for building query params (see `buildQueryParams`)\nso that it may be composed cleanly with other query-params strategies.\n\nUsage:\n\n```ts\nimport { buildBaseURL } from '@ember-data/request-utils';\n\nconst url = buildBaseURL({\n  host: 'https://api.example.com',\n  namespace: 'api/v1',\n  resourcePath: 'emberDevelopers',\n  op: 'query',\n  identifier: { type: 'ember-developer' }\n});\n\n// => 'https://api.example.com/api/v1/emberDevelopers'\n```\n\nOn the surface this may seem like a lot of work to do something simple, but\nit is designed to be composable with other utilities and interfaces that the\naverage product engineer will never need to see or use.\n\nA few notes:\n\n- `resourcePath` is optional, but if it is not provided, `identifier.type` will be used.\n- `host` and `namespace` are optional, but if they are not provided, the values globally\n   configured via `setBuildURLConfig` will be used.\n- `op` is required and must be one of the following:\n  - 'findRecord' 'query' 'findMany' 'findRelatedCollection' 'findRelatedRecord'` 'createRecord' 'updateRecord' 'deleteRecord'\n- Depending on the value of `op`, `identifier` or `identifiers` will be required.",
      "itemtype": "method",
      "name": "buildBaseURL",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "urlOptions",
          "description": ""
        }
      ],
      "return": {
        "description": "string"
      },
      "class": "@ember-data/request-utils",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 435,
      "description": "filter out keys of an object that have falsy values or point to empty arrays\nreturning a new object with only those keys that have truthy values / non-empty arrays",
      "itemtype": "method",
      "name": "filterEmpty",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "source",
          "description": "object to filter keys with empty values from",
          "type": "Record<string, Serializable>"
        }
      ],
      "return": {
        "description": "A new object with the keys that contained empty values removed",
        "type": "Record<string, Serializable>"
      },
      "class": "@ember-data/request-utils",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 460,
      "description": "Sorts query params by both key and value returning a new URLSearchParams\nobject with the keys inserted in sorted order.\n\nTreats `included` specially, splicing it into an array if it is a string and sorting the array.\n\nOptions:\n- arrayFormat: 'bracket' | 'indices' | 'repeat' | 'comma'\n\n'bracket': appends [] to the key for every value e.g. `&ids[]=1&ids[]=2`\n'indices': appends [i] to the key for every value e.g. `&ids[0]=1&ids[1]=2`\n'repeat': appends the key for every value e.g. `&ids=1&ids=2`\n'comma' (default): appends the key once with a comma separated list of values e.g. `&ids=1,2`",
      "itemtype": "method",
      "name": "sortQueryParams",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "params",
          "description": "",
          "type": "URLSearchParams | object"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "A URLSearchParams with keys inserted in sorted order",
        "type": "URLSearchParams"
      },
      "class": "@ember-data/request-utils",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 542,
      "description": "Sorts query params by both key and value, returning a query params string\n\nTreats `included` specially, splicing it into an array if it is a string and sorting the array.\n\nOptions:\n- arrayFormat: 'bracket' | 'indices' | 'repeat' | 'comma'\n\n'bracket': appends [] to the key for every value e.g. `ids[]=1&ids[]=2`\n'indices': appends [i] to the key for every value e.g. `ids[0]=1&ids[1]=2`\n'repeat': appends the key for every value e.g. `ids=1&ids=2`\n'comma' (default): appends the key once with a comma separated list of values e.g. `ids=1,2`",
      "itemtype": "method",
      "name": "buildQueryParams",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "params",
          "description": "",
          "type": "URLSearchParams | object"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object",
          "optional": true
        }
      ],
      "return": {
        "description": "A sorted query params string without the leading `?`",
        "type": "String"
      },
      "class": "@ember-data/request-utils",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 587,
      "description": "Parses a string Cache-Control header value into an object with the following structure:\n\n ```ts\n interface CacheControlValue {\n immutable?: boolean;\n 'max-age'?: number;\n 'must-revalidate'?: boolean;\n 'must-understand'?: boolean;\n 'no-cache'?: boolean;\n 'no-store'?: boolean;\n 'no-transform'?: boolean;\n 'only-if-cached'?: boolean;\n private?: boolean;\n 'proxy-revalidate'?: boolean;\n public?: boolean;\n 's-maxage'?: number;\n 'stale-if-error'?: number;\n 'stale-while-revalidate'?: number;\n }\n ```",
      "itemtype": "method",
      "name": "parseCacheControl",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "header",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "CacheControlValue"
      },
      "class": "@ember-data/request-utils",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 774,
      "description": "Invalidate a request by its identifier for a given store instance.\n\nWhile the store argument may seem redundant, the CachePolicy\nis designed to be shared across multiple stores / forks\nof the store.\n\n```ts\nstore.lifetimes.invalidateRequest(store, identifier);\n```",
      "itemtype": "method",
      "name": "invalidateRequest",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableDocumentIdentifier"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        }
      ],
      "class": "CachePolicy",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 794,
      "description": "Invalidate all requests associated to a specific type\nfor a given store instance.\n\nWhile the store argument may seem redundant, the CachePolicy\nis designed to be shared across multiple stores / forks\nof the store.\n\nThis invalidation is done automatically when using this service\nfor both the CacheHandler and the LegacyNetworkHandler.\n\n```ts\nstore.lifetimes.invalidateRequestsForType(store, 'person');\n```",
      "itemtype": "method",
      "name": "invalidateRequestsForType",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "type",
          "description": "",
          "type": "String"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        }
      ],
      "class": "CachePolicy",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 828,
      "description": "Invoked when a request has been fulfilled from the configured request handlers.\nThis is invoked by the CacheHandler for both foreground and background requests\nonce the cache has been updated.\n\nNote, this is invoked by the CacheHandler regardless of whether\nthe request has a cache-key.\n\nThis method should not be invoked directly by consumers.",
      "itemtype": "method",
      "name": "didRequest",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "request",
          "description": "",
          "type": "ImmutableRequestInfo"
        },
        {
          "name": "response",
          "description": "",
          "type": "ImmutableResponse"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "identifier",
          "description": "",
          "type": "StableDocumentIdentifier | null"
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "class": "CachePolicy",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 883,
      "description": "Invoked to determine if the request may be fulfilled from cache\nif possible.\n\nNote, this is only invoked by the CacheHandler if the request has\na cache-key.\n\nIf no cache entry is found or the entry is hard expired,\nthe request will be fulfilled from the configured request handlers\nand the cache will be updated before returning the response.",
      "itemtype": "method",
      "name": "isHardExpired",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableDocumentIdentifier"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        }
      ],
      "return": {
        "description": "true if the request is considered hard expired",
        "type": "Boolean"
      },
      "class": "CachePolicy",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request-utils/src/index.ts",
      "line": 911,
      "description": "Invoked if `isHardExpired` is false to determine if the request\nshould be update behind the scenes if cache data is already available.\n\nNote, this is only invoked by the CacheHandler if the request has\na cache-key.\n\nIf true, the request will be fulfilled from cache while a backgrounded\nrequest is made to update the cache via the configured request handlers.",
      "itemtype": "method",
      "name": "isSoftExpired",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableDocumentIdentifier"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        }
      ],
      "return": {
        "description": "true if the request is considered soft expired",
        "type": "Boolean"
      },
      "class": "CachePolicy",
      "module": "@ember-data/request-utils"
    },
    {
      "file": "../packages/request/src/-private/manager.ts",
      "line": 536,
      "description": "Register a handler to use for primary cache intercept.\n\nOnly one such handler may exist. If using the same\nRequestManager as the Store instance the Store\nregisters itself as a Cache handler.",
      "itemtype": "method",
      "name": "useCache",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "cacheHandler",
          "description": "",
          "type": "Handler[]"
        }
      ],
      "return": {
        "description": "",
        "type": "ThisType"
      },
      "class": "RequestManager",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/request/src/-private/manager.ts",
      "line": 565,
      "description": "Register handler(s) to use when a request is issued.\n\nHandlers will be invoked in the order they are registered.\nEach Handler is given the opportunity to handle the request,\ncurry the request, or pass along a modified request.",
      "itemtype": "method",
      "name": "use",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "newHandlers",
          "description": "",
          "type": "Handler[]"
        }
      ],
      "return": {
        "description": "",
        "type": "ThisType"
      },
      "class": "RequestManager",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/request/src/-private/manager.ts",
      "line": 600,
      "description": "Issue a Request.\n\nReturns a Future that fulfills with a StructuredDocument",
      "itemtype": "method",
      "name": "request",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "request",
          "description": "",
          "type": "RequestInfo"
        }
      ],
      "return": {
        "description": "",
        "type": "Future"
      },
      "class": "RequestManager",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/request/src/-private/types.ts",
      "line": 49,
      "description": "Cancel this request by firing the AbortController's signal.",
      "itemtype": "method",
      "name": "abort",
      "params": [
        {
          "name": "reason",
          "description": "optional reason for aborting the request",
          "type": "String",
          "optional": true
        }
      ],
      "access": "public",
      "tagname": "",
      "return": {
        "description": "",
        "type": "Void"
      },
      "class": "Future",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/request/src/-private/types.ts",
      "line": 58,
      "description": "Get the response stream, if any, once made available.",
      "itemtype": "method",
      "name": "getStream",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "",
        "type": "Promise<ReadableStream | null>"
      },
      "class": "Future",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/request/src/-private/types.ts",
      "line": 67,
      "description": "Run a callback when this request completes. Use sparingly,\nmostly useful for instrumentation and infrastructure.",
      "itemtype": "method",
      "name": "onFinalize",
      "params": [
        {
          "name": "cb",
          "description": "the callback to run"
        }
      ],
      "access": "public",
      "tagname": "",
      "return": {
        "description": "void"
      },
      "class": "Future",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/request/src/-private/types.ts",
      "line": 78,
      "description": "The identifier of the associated request, if any, as\nassigned by the CacheHandler.",
      "itemtype": "property",
      "name": "lid",
      "type": "{StableDocumentIdentifier | null}",
      "access": "public",
      "tagname": "",
      "class": "Future",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/request/src/-private/types.ts",
      "line": 88,
      "description": "The id of the associated request, if any, as assigned\nby the RequestManager",
      "itemtype": "property",
      "name": "id",
      "type": "{number}",
      "access": "public",
      "tagname": "",
      "class": "Future",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/request/src/-private/types.ts",
      "line": 219,
      "description": "Method to implement to handle requests. Receives the request\ncontext and a nextFn to call to pass-along the request to\nother handlers.",
      "itemtype": "method",
      "name": "request",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "context",
          "description": ""
        },
        {
          "name": "next",
          "description": ""
        }
      ],
      "class": "<Interface> Handler",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/request/src/-private/types.ts",
      "line": 244,
      "description": "Method to implement to handle requests. Receives the request\ncontext and a nextFn to call to pass-along the request to\nother handlers.",
      "itemtype": "method",
      "name": "request",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "context",
          "description": ""
        },
        {
          "name": "next",
          "description": ""
        }
      ],
      "class": "<Interface> CacheHandler",
      "module": "@ember-data/request"
    },
    {
      "file": "../packages/rest/src/-private/builders/find-record.ts",
      "line": 16,
      "description": "Builds request options to fetch a single resource by a known id or identifier\nconfigured for the url and header expectations of most REST APIs.\n\n**Basic Usage**\n\n```ts\nimport { findRecord } from '@ember-data/rest/request';\n\nconst data = await store.request(findRecord('person', '1'));\n```\n\n**With Options**\n\n```ts\nimport { findRecord } from '@ember-data/rest/request';\n\nconst options = findRecord('person', '1', { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**With an Identifier**\n\n```ts\nimport { findRecord } from '@ember-data/rest/request';\n\nconst options = findRecord({ type: 'person', id: '1' }, { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing and camelCasing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { findRecord } from '@ember-data/rest/request';\n\nconst options = findRecord('person', '1', { include: ['pets', 'friends'] }, { namespace: 'api/v2' });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "findRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/rest/request",
      "module": "@ember-data/rest/request"
    },
    {
      "file": "../packages/rest/src/-private/builders/query.ts",
      "line": 13,
      "description": "Builds request options to query for resources, usually by a primary\ntype, configured for the url and header expectations of most REST APIs.\n\n**Basic Usage**\n\n```ts\nimport { query } from '@ember-data/rest/request';\n\nconst data = await store.request(query('person'));\n```\n\n**With Query Params**\n\n```ts\nimport { query } from '@ember-data/rest/request';\n\nconst options = query('person', { include: ['pets', 'friends'] });\nconst data = await store.request(options);\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing and camelCasing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSettings` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { query } from '@ember-data/rest/request';\n\nconst options = query('person', { include: ['pets', 'friends'] }, { reload: true });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "query",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "query",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/rest/request",
      "module": "@ember-data/rest/request"
    },
    {
      "file": "../packages/rest/src/-private/builders/save-record.ts",
      "line": 24,
      "description": "Builds request options to delete record for resources,\nconfigured for the url, method and header expectations of REST APIs.\n\n**Basic Usage**\n\n```ts\nimport { deleteRecord } from '@ember-data/rest/request';\n\nconst person = store.peekRecord('person', '1');\n\n// mark record as deleted\nstore.deleteRecord(person);\n\n// persist deletion\nconst data = await store.request(deleteRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { deleteRecord } from '@ember-data/rest/request';\n\nconst person = store.peekRecord('person', '1');\n\n// mark record as deleted\nstore.deleteRecord(person);\n\n// persist deletion\nconst options = deleteRecord(person, { namespace: 'api/v1' });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "deleteRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/rest/request",
      "module": "@ember-data/rest/request"
    },
    {
      "file": "../packages/rest/src/-private/builders/save-record.ts",
      "line": 107,
      "description": "Builds request options to create new record for resources,\nconfigured for the url, method and header expectations of most REST APIs.\n\n**Basic Usage**\n\n```ts\nimport { createRecord } from '@ember-data/rest/request';\n\nconst person = store.createRecord('person', { name: 'Ted' });\nconst data = await store.request(createRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { createRecord } from '@ember-data/rest/request';\n\nconst person = store.createRecord('person', { name: 'Ted' });\nconst options = createRecord(person, { namespace: 'api/v1' });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "createRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/rest/request",
      "module": "@ember-data/rest/request"
    },
    {
      "file": "../packages/rest/src/-private/builders/save-record.ts",
      "line": 179,
      "description": "Builds request options to update existing record for resources,\nconfigured for the url, method and header expectations of most REST APIs.\n\n**Basic Usage**\n\n```ts\nimport { updateRecord } from '@ember-data/rest/request';\n\nconst person = store.peekRecord('person', '1');\nperson.name = 'Chris';\nconst data = await store.request(updateRecord(person));\n```\n\n**Supplying Options to Modify the Request Behavior**\n\nThe following options are supported:\n\n- `patch` - Allows caller to specify whether to use a PATCH request instead of a PUT request, defaults to `false`.\n- `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n- `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n- `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n- `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n     option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n- `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n     promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n     defaulting to `false` if none is configured.\n- `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n\n```ts\nimport { updateRecord } from '@ember-data/rest/request';\n\nconst person = store.peekRecord('person', '1');\nperson.name = 'Chris';\nconst options = updateRecord(person, { patch: true });\nconst data = await store.request(options);\n```",
      "itemtype": "method",
      "name": "updateRecord",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "@ember-data/rest/request",
      "module": "@ember-data/rest/request"
    },
    {
      "file": "../packages/schema-record/src/-private/schema.ts",
      "line": 69,
      "description": "Utility for constructing a ResourceSchema with the recommended fields\nfor the Polaris experience.",
      "itemtype": "method",
      "name": "withDefaults",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "schema",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "ResourceSchema"
      },
      "class": "@warp-drive/schema-record",
      "module": "@warp-drive/schema-record"
    },
    {
      "file": "../packages/schema-record/src/-private/schema.ts",
      "line": 91,
      "description": "A derivation that computes its value from the\nrecord's identity.\n\nIt can be used via a derived field definition like:\n\n```ts\n{\n  kind: 'derived',\n  name: 'id',\n  type: '@identity',\n  options: { key: 'id' }\n}\n```\n\nValid keys are `'id'`, `'lid'`, `'type'`, and `'^'`.\n\n`^` returns the entire identifier object.",
      "itemtype": "method",
      "name": "fromIdentity",
      "static": 1,
      "access": "public",
      "tagname": "",
      "class": "@warp-drive/schema-record",
      "module": "@warp-drive/schema-record"
    },
    {
      "file": "../packages/schema-record/src/-private/schema.ts",
      "line": 135,
      "description": "Registers the default derivations for the SchemaRecord",
      "itemtype": "method",
      "name": "registerDerivations",
      "static": 1,
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "schema",
          "description": "",
          "type": "SchemaService"
        }
      ],
      "class": "@warp-drive/schema-record",
      "module": "@warp-drive/schema-record"
    },
    {
      "file": "../packages/serializer/src/-private/transforms/transform.ts",
      "line": 85,
      "description": "When given a deserialized value from a record attribute this\nmethod must return the serialized value.\n\nExample\n\n```javascript\nserialize(deserialized, options) {\n  return deserialized ? null : Number(deserialized);\n}\n```",
      "itemtype": "method",
      "name": "serialize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "deserialized",
          "description": "The deserialized value"
        },
        {
          "name": "options",
          "description": "hash of options passed to `attr`"
        }
      ],
      "return": {
        "description": "The serialized value"
      },
      "class": "Transform",
      "module": "@ember-data/serializer"
    },
    {
      "file": "../packages/serializer/src/-private/transforms/transform.ts",
      "line": 103,
      "description": "When given a serialized value from a JSON object this method must\nreturn the deserialized value for the record attribute.\n\nExample\n\n```javascript\ndeserialize(serialized, options) {\n  return empty(serialized) ? null : Number(serialized);\n}\n```",
      "itemtype": "method",
      "name": "deserialize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "serialized",
          "description": "The serialized value"
        },
        {
          "name": "options",
          "description": "hash of options passed to `attr`"
        }
      ],
      "return": {
        "description": "The deserialized value"
      },
      "class": "Transform",
      "module": "@ember-data/serializer"
    },
    {
      "file": "../packages/serializer/src/-private/embedded-records-mixin.js",
      "line": 105,
      "description": "Normalize the record and recursively normalize/extract all the embedded records\nwhile pushing them into the store as they are encountered\n\nA payload with an attr configured for embedded records needs to be extracted:\n\n```js\n{\n  \"post\": {\n    \"id\": \"1\"\n    \"title\": \"Rails is omakase\",\n    \"comments\": [{\n      \"id\": \"1\",\n      \"body\": \"Rails is unagi\"\n    }, {\n      \"id\": \"2\",\n      \"body\": \"Omakase O_o\"\n    }]\n  }\n}\n```",
      "itemtype": "method",
      "name": "normalize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "typeClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "hash",
          "description": "to be normalized",
          "type": "Object"
        },
        {
          "name": "prop",
          "description": "the hash has been referenced by",
          "type": "String"
        }
      ],
      "return": {
        "description": "the normalized hash",
        "type": "Object"
      },
      "class": "EmbeddedRecordsMixin",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/-private/embedded-records-mixin.js",
      "line": 149,
      "description": "Serialize `belongsTo` relationship when it is configured as an embedded object.\n\nThis example of an author model belongs to a post model:\n\n```js\nimport Model, { attr, belongsTo } from '@ember-data/model';\n\nPost = Model.extend({\n  title:    attr('string'),\n  body:     attr('string'),\n  author:   belongsTo('author')\n});\n\nAuthor = Model.extend({\n  name:     attr('string'),\n  post:     belongsTo('post')\n});\n```\n\nUse a custom (type) serializer for the post model to configure embedded author\n\n```app/serializers/post.js\nimport RESTSerializer, { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';\n\nexport default class PostSerializer extends RESTSerializer.extend(EmbeddedRecordsMixin) {\n  attrs = {\n    author: { embedded: 'always' }\n  }\n}\n```\n\nA payload with an attribute configured for embedded records can serialize\nthe records together under the root attribute's payload:\n\n```js\n{\n  \"post\": {\n    \"id\": \"1\"\n    \"title\": \"Rails is omakase\",\n    \"author\": {\n      \"id\": \"2\"\n      \"name\": \"dhh\"\n    }\n  }\n}\n```",
      "itemtype": "method",
      "name": "serializeBelongsTo",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "json",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "EmbeddedRecordsMixin",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/-private/embedded-records-mixin.js",
      "line": 253,
      "description": "Serializes `hasMany` relationships when it is configured as embedded objects.\n\nThis example of a post model has many comments:\n\n```js\nimport Model, { attr, belongsTo, hasMany } from '@ember-data/model';\n\nPost = Model.extend({\n  title:    attr('string'),\n  body:     attr('string'),\n  comments: hasMany('comment')\n});\n\nComment = Model.extend({\n  body:     attr('string'),\n  post:     belongsTo('post')\n});\n```\n\nUse a custom (type) serializer for the post model to configure embedded comments\n\n```app/serializers/post.js\nimport RESTSerializer, { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';\n\nexport default class PostSerializer extends RESTSerializer.extend(EmbeddedRecordsMixin) {\n  attrs = {\n    comments: { embedded: 'always' }\n  }\n}\n```\n\nA payload with an attribute configured for embedded records can serialize\nthe records together under the root attribute's payload:\n\n```js\n{\n  \"post\": {\n    \"id\": \"1\"\n    \"title\": \"Rails is omakase\",\n    \"body\": \"I want this for my ORM, I want that for my template language...\"\n    \"comments\": [{\n      \"id\": \"1\",\n      \"body\": \"Rails is unagi\"\n    }, {\n      \"id\": \"2\",\n      \"body\": \"Omakase O_o\"\n    }]\n  }\n}\n```\n\nThe attrs options object can use more specific instruction for extracting and\nserializing. When serializing, an option to embed `ids`, `ids-and-types` or `records` can be set.\nWhen extracting the only option is `records`.\n\nSo `{ embedded: 'always' }` is shorthand for:\n`{ serialize: 'records', deserialize: 'records' }`\n\nTo embed the `ids` for a related object (using a hasMany relationship):\n\n```app/serializers/post.js\nimport RESTSerializer, { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';\n\nexport default class PostSerializer extends RESTSerializer.extend(EmbeddedRecordsMixin) {\n  attrs = {\n    comments: { serialize: 'ids', deserialize: 'records' }\n  }\n}\n```\n\n```js\n{\n  \"post\": {\n    \"id\": \"1\"\n    \"title\": \"Rails is omakase\",\n    \"body\": \"I want this for my ORM, I want that for my template language...\"\n    \"comments\": [\"1\", \"2\"]\n  }\n}\n```\n\nTo embed the relationship as a collection of objects with `id` and `type` keys, set\n`ids-and-types` for the related object.\n\nThis is particularly useful for polymorphic relationships where records don't share\nthe same table and the `id` is not enough information.\n\nFor example having a user that has many pets:\n\n```js\nUser = Model.extend({\n  name: attr('string'),\n  pets: hasMany('pet', { polymorphic: true })\n});\n\nPet = Model.extend({\n  name: attr('string'),\n});\n\nCat = Pet.extend({\n  // ...\n});\n\nParrot = Pet.extend({\n  // ...\n});\n```\n\n```app/serializers/user.js\nimport RESTSerializer, { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';\n\nexport default class UserSerializer extends RESTSerializer.extend(EmbeddedRecordsMixin) {\n  attrs = {\n    pets: { serialize: 'ids-and-types', deserialize: 'records' }\n  }\n}\n```\n\n```js\n{\n  \"user\": {\n    \"id\": \"1\"\n    \"name\": \"Bertin Osborne\",\n    \"pets\": [\n      { \"id\": \"1\", \"type\": \"Cat\" },\n      { \"id\": \"1\", \"type\": \"Parrot\"}\n    ]\n  }\n}\n```",
      "itemtype": "method",
      "name": "serializeHasMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "json",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "EmbeddedRecordsMixin",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/-private/embedded-records-mixin.js",
      "line": 469,
      "description": "When serializing an embedded record, modify the property (in the `JSON` payload)\nthat refers to the parent record (foreign key for the relationship).\n\nSerializing a `belongsTo` relationship removes the property that refers to the\nparent record\n\nSerializing a `hasMany` relationship does not remove the property that refers to\nthe parent record.",
      "itemtype": "method",
      "name": "removeEmbeddedForeignKey",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "embeddedSnapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "Object"
        },
        {
          "name": "json",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "EmbeddedRecordsMixin",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/-private/embedded-records-mixin.js",
      "line": 548,
      "itemtype": "method",
      "name": "_extractEmbeddedRecords",
      "access": "private",
      "tagname": "",
      "class": "EmbeddedRecordsMixin",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/-private/embedded-records-mixin.js",
      "line": 566,
      "itemtype": "method",
      "name": "_extractEmbeddedHasMany",
      "access": "private",
      "tagname": "",
      "class": "EmbeddedRecordsMixin",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/-private/embedded-records-mixin.js",
      "line": 598,
      "itemtype": "method",
      "name": "_extractEmbeddedBelongsTo",
      "access": "private",
      "tagname": "",
      "class": "EmbeddedRecordsMixin",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/-private/embedded-records-mixin.js",
      "line": 625,
      "itemtype": "method",
      "name": "_normalizeEmbeddedRelationship",
      "access": "private",
      "tagname": "",
      "class": "EmbeddedRecordsMixin",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/index.ts",
      "line": 144,
      "description": "The `store` property is the application's `store` that contains\nall records. It can be used to look up serializers for other model\ntypes that may be nested inside the payload response.\n\nExample:\n\n```js\nSerializer.extend({\n  extractRelationship(relationshipModelName, relationshipHash) {\n    let modelClass = this.store.modelFor(relationshipModelName);\n    let relationshipSerializer = this.store.serializerFor(relationshipModelName);\n    return relationshipSerializer.normalize(modelClass, relationshipHash);\n  }\n});\n```",
      "itemtype": "property",
      "name": "store",
      "type": "{Store}",
      "access": "public",
      "tagname": "",
      "class": "Serializer",
      "module": "@ember-data/serializer"
    },
    {
      "file": "../packages/serializer/src/index.ts",
      "line": 166,
      "description": "The `normalizeResponse` method is used to normalize a payload from the\nserver to a JSON-API Document.\n\nhttp://jsonapi.org/format/#document-structure\n\nExample:\n\n```js\nSerializer.extend({\n  normalizeResponse(store, primaryModelClass, payload, id, requestType) {\n    if (requestType === 'findRecord') {\n      return this.normalize(primaryModelClass, payload);\n    } else {\n      return payload.reduce(function(documentHash, item) {\n        let { data, included } = this.normalize(primaryModelClass, item);\n        documentHash.included.push(...included);\n        documentHash.data.push(data);\n        return documentHash;\n      }, { data: [], included: [] })\n    }\n  }\n});\n```",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "Serializer",
      "module": "@ember-data/serializer"
    },
    {
      "file": "../packages/serializer/src/index.ts",
      "line": 202,
      "description": "The `serialize` method is used when a record is saved in order to convert\nthe record into the form that your external data source expects.\n\n`serialize` takes an optional `options` hash with a single option:\n\n- `includeId`: If this is `true`, `serialize` should include the ID\n  in the serialized object it builds.\n\nExample:\n\n```js\nSerializer.extend({\n  serialize(snapshot, options) {\n    let json = {\n      id: snapshot.id\n    };\n\n    snapshot.eachAttribute((key, attribute) => {\n      json[key] = snapshot.attr(key);\n    });\n\n    snapshot.eachRelationship((key, relationship) => {\n      if (relationship.kind === 'belongsTo') {\n        json[key] = snapshot.belongsTo(key, { id: true });\n      } else if (relationship.kind === 'hasMany') {\n        json[key] = snapshot.hasMany(key, { ids: true });\n      }\n    });\n\n    return json;\n  },\n});\n```",
      "itemtype": "method",
      "name": "serialize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object",
          "optional": true
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "Serializer",
      "module": "@ember-data/serializer"
    },
    {
      "file": "../packages/serializer/src/index.ts",
      "line": 244,
      "description": "The `normalize` method is used to convert a payload received from your\nexternal data source into the normalized form `store.push()` expects. You\nshould override this method, munge the hash and return the normalized\npayload.\n\nExample:\n\n```js\nSerializer.extend({\n  normalize(modelClass, resourceHash) {\n    let data = {\n      id:            resourceHash.id,\n      type:          modelClass.modelName,\n      attributes:    resourceHash\n    };\n    return { data: data };\n  }\n})\n```",
      "itemtype": "method",
      "name": "normalize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "typeClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "hash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "Serializer",
      "module": "@ember-data/serializer"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 138,
      "itemtype": "method",
      "name": "_normalizeDocumentHelper",
      "params": [
        {
          "name": "documentHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "access": "private",
      "tagname": "",
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 175,
      "itemtype": "method",
      "name": "_normalizeRelationshipDataHelper",
      "params": [
        {
          "name": "relationshipDataHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "access": "private",
      "tagname": "",
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 187,
      "itemtype": "method",
      "name": "_normalizeResourceHelper",
      "params": [
        {
          "name": "resourceHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "access": "private",
      "tagname": "",
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 213,
      "description": "Normalize some data and push it into the store.",
      "itemtype": "method",
      "name": "pushPayload",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 226,
      "itemtype": "method",
      "name": "_normalizeResponse",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        },
        {
          "name": "isSingle",
          "description": "",
          "type": "Boolean"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "access": "private",
      "tagname": "",
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 276,
      "description": "Returns a relationship formatted as a JSON-API \"relationship object\".\n\nhttp://jsonapi.org/format/#document-resource-object-relationships",
      "itemtype": "method",
      "name": "extractRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "relationshipHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 303,
      "description": "Returns the resource's relationships formatted as a JSON-API \"relationships object\".\n\nhttp://jsonapi.org/format/#document-resource-object-relationships",
      "itemtype": "method",
      "name": "extractRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelClass",
          "description": "",
          "type": "Object"
        },
        {
          "name": "resourceHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 341,
      "itemtype": "method",
      "name": "_extractType",
      "params": [
        {
          "name": "modelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "resourceHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "String"
      },
      "access": "private",
      "tagname": "",
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 352,
      "description": "Dasherizes and singularizes the model name in the payload to match\nthe format Ember Data uses internally for the model name.\n\nFor example the key `posts` would be converted to `post` and the\nkey `studentAssesments` would be converted to `student-assesment`.",
      "itemtype": "method",
      "name": "modelNameFromPayloadKey",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "the model's modelName",
        "type": "String"
      },
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 368,
      "description": "Converts the model name to a pluralized version of the model name.\n\nFor example `post` would be converted to `posts` and\n`student-assesment` would be converted to `student-assesments`.",
      "itemtype": "method",
      "name": "payloadKeyFromModelName",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "String"
      },
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 408,
      "description": "`keyForAttribute` can be used to define rules for how to convert an\nattribute name in your model to a key in your JSON.\nBy default `JSONAPISerializer` follows the format used on the examples of\nhttp://jsonapi.org/format and uses dashes as the word separator in the JSON\nattribute keys.\n\nThis behaviour can be easily customized by extending this method.\n\nExample\n\n```app/serializers/application.js\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\nimport { dasherize } from '<app-name>/utils/string-utils';\n\nexport default class ApplicationSerializer extends JSONAPISerializer {\n  keyForAttribute(attr, method) {\n    return dasherize(attr).toUpperCase();\n  }\n}\n```",
      "itemtype": "method",
      "name": "keyForAttribute",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        },
        {
          "name": "method",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "normalized key",
        "type": "String"
      },
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 440,
      "description": "`keyForRelationship` can be used to define a custom key when\nserializing and deserializing relationship properties.\nBy default `JSONAPISerializer` follows the format used on the examples of\nhttp://jsonapi.org/format and uses dashes as word separators in\nrelationship properties.\n\nThis behaviour can be easily customized by extending this method.\n\nExample\n\n ```app/serializers/post.js\n import JSONAPISerializer from '@ember-data/serializer/json-api';\n import { underscore } from '<app-name>/utils/string-utils';\n\n export default class ApplicationSerializer extends JSONAPISerializer {\n   keyForRelationship(key, relationship, method) {\n     return underscore(key);\n   }\n }\n ```",
      "itemtype": "method",
      "name": "keyForRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        },
        {
          "name": "typeClass",
          "description": "",
          "type": "String"
        },
        {
          "name": "method",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "normalized key",
        "type": "String"
      },
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json-api.js",
      "line": 472,
      "description": "Called when a record is saved in order to convert the\nrecord into JSON.\n\nFor example, consider this model:\n\n```app/models/comment.js\nimport Model, { attr, belongsTo } from '@ember-data/model';\n\nexport default class CommentModel extends Model {\n  @attr title;\n  @attr body;\n\n  @belongsTo('user', { async: false, inverse: null })\n  author;\n}\n```\n\nThe default serialization would create a JSON-API resource object like:\n\n```javascript\n{\n  \"data\": {\n    \"type\": \"comments\",\n    \"attributes\": {\n      \"title\": \"Rails is unagi\",\n      \"body\": \"Rails? Omakase? O_O\",\n    },\n    \"relationships\": {\n      \"author\": {\n        \"data\": {\n          \"id\": \"12\",\n          \"type\": \"users\"\n        }\n      }\n    }\n  }\n}\n```\n\nBy default, attributes are passed through as-is, unless\nyou specified an attribute type (`attr('date')`). If\nyou specify a transform, the JavaScript value will be\nserialized when inserted into the attributes hash.\n\nBelongs-to relationships are converted into JSON-API\nresource identifier objects.\n\n## IDs\n\n`serialize` takes an options hash with a single option:\n`includeId`. If this option is `true`, `serialize` will,\nby default include the ID in the JSON object it builds.\n\nThe JSONAPIAdapter passes in `includeId: true` when serializing a record\nfor `createRecord` or `updateRecord`.\n\n## Customization\n\nYour server may expect data in a different format than the\nbuilt-in serialization format.\n\nIn that case, you can implement `serialize` yourself and\nreturn data formatted to match your API's expectations, or override\nthe invoked adapter method and do the serialization in the adapter directly\nby using the provided snapshot.\n\nIf your API's format differs greatly from the JSON:API spec, you should\nconsider authoring your own adapter and serializer instead of extending\nthis class.\n\n```app/serializers/post.js\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class PostSerializer extends JSONAPISerializer {\n  serialize(snapshot, options) {\n    let json = {\n      POST_TTL: snapshot.attr('title'),\n      POST_BDY: snapshot.attr('body'),\n      POST_CMS: snapshot.hasMany('comments', { ids: true })\n    };\n\n    if (options.includeId) {\n      json.POST_ID_ = snapshot.id;\n    }\n\n    return json;\n  }\n}\n```\n\n## Customizing an App-Wide Serializer\n\nIf you want to define a serializer for your entire\napplication, you'll probably want to use `eachAttribute`\nand `eachRelationship` on the record.\n\n```app/serializers/application.js\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\nimport { underscore, singularize } from '<app-name>/utils/string-utils';\n\nexport default class ApplicationSerializer extends JSONAPISerializer {\n  serialize(snapshot, options) {\n    let json = {};\n\n    snapshot.eachAttribute((name) => {\n      json[serverAttributeName(name)] = snapshot.attr(name);\n    });\n\n    snapshot.eachRelationship((name, relationship) => {\n      if (relationship.kind === 'hasMany') {\n        json[serverHasManyName(name)] = snapshot.hasMany(name, { ids: true });\n      }\n    });\n\n    if (options.includeId) {\n      json.ID_ = snapshot.id;\n    }\n\n    return json;\n  }\n}\n\nfunction serverAttributeName(attribute) {\n  return underscore(attribute).toUpperCase();\n}\n\nfunction serverHasManyName(name) {\n  return serverAttributeName(singularize(name)) + '_IDS';\n}\n```\n\nThis serializer will generate JSON that looks like this:\n\n```javascript\n{\n  \"TITLE\": \"Rails is omakase\",\n  \"BODY\": \"Yep. Omakase.\",\n  \"COMMENT_IDS\": [ \"1\", \"2\", \"3\" ]\n}\n```\n\n## Tweaking the Default Formatting\n\nIf you just want to do some small tweaks on the default JSON:API formatted response,\nyou can call `super.serialize` first and make the tweaks\non the returned object.\n\n```app/serializers/post.js\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class PostSerializer extends JSONAPISerializer {\n  serialize(snapshot, options) {\n    let json = super.serialize(...arguments);\n\n    json.data.attributes.subject = json.data.attributes.title;\n    delete json.data.attributes.title;\n\n    return json;\n  }\n}\n```",
      "itemtype": "method",
      "name": "serialize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "json",
        "type": "Object"
      },
      "class": "JSONAPISerializer",
      "module": "@ember-data/serializer/json-api"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 95,
      "description": "The `primaryKey` is used when serializing and deserializing\ndata. Ember Data always uses the `id` property to store the id of\nthe record. The external source may not always follow this\nconvention. In these cases it is useful to override the\n`primaryKey` property to match the `primaryKey` of your external\nstore.\n\nExample\n\n```app/serializers/application.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class ApplicationSerializer extends JSONSerializer {\n  primaryKey = '_id'\n}\n```",
      "itemtype": "property",
      "name": "primaryKey",
      "type": "{String}",
      "access": "public",
      "tagname": "",
      "default": "'id'",
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 120,
      "description": "The `attrs` object can be used to declare a simple mapping between\nproperty names on `Model` records and payload keys in the\nserialized JSON object representing the record. An object with the\nproperty `key` can also be used to designate the attribute's key on\nthe response payload.\n\nExample\n\n```app/models/person.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PersonModel extends Model {\n  @attr('string') firstName;\n  @attr('string') lastName;\n  @attr('string') occupation;\n  @attr('boolean') admin;\n}\n```\n\n```app/serializers/person.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class PersonSerializer extends JSONSerializer {\n  attrs = {\n    admin: 'is_admin',\n    occupation: { key: 'career' }\n  }\n}\n```\n\nYou can also remove attributes and relationships by setting the `serialize`\nkey to `false` in your mapping object.\n\nExample\n\n```app/serializers/person.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class PostSerializer extends JSONSerializer {\n  attrs = {\n    admin: { serialize: false },\n    occupation: { key: 'career' }\n  }\n}\n```\n\nWhen serialized:\n\n```javascript\n{\n  \"firstName\": \"Harry\",\n  \"lastName\": \"Houdini\",\n  \"career\": \"magician\"\n}\n```\n\nNote that the `admin` is now not included in the payload.\n\nSetting `serialize` to `true` enforces serialization for hasMany\nrelationships even if it's neither a many-to-many nor many-to-none\nrelationship.",
      "itemtype": "property",
      "name": "attrs",
      "access": "public",
      "tagname": "",
      "type": "{Object}",
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 189,
      "description": "Given a subclass of `Model` and a JSON object this method will\niterate through each attribute of the `Model` and invoke the\n`Transform#deserialize` method on the matching property of the\nJSON object.  This method is typically called after the\nserializer's `normalize` method.",
      "itemtype": "method",
      "name": "applyTransforms",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "typeClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "data",
          "description": "The data to transform",
          "type": "Object"
        }
      ],
      "return": {
        "description": "data The transformed data object",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 218,
      "description": "The `normalizeResponse` method is used to normalize a payload from the\nserver to a JSON-API Document.\n\nhttp://jsonapi.org/format/#document-structure\n\nThis method delegates to a more specific normalize method based on\nthe `requestType`.\n\nTo override this method with a custom one, make sure to call\n`return super.normalizeResponse(store, primaryModelClass, payload, id, requestType)` with your\npre-processed data.\n\nHere's an example of using `normalizeResponse` manually:\n\n```javascript\nsocket.on('message', function(message) {\n  let data = message.data;\n  let modelClass = store.modelFor(data.modelName);\n  let serializer = store.serializerFor(data.modelName);\n  let normalized = serializer.normalizeSingleResponse(store, modelClass, data, data.id);\n\n  store.push(normalized);\n});\n```",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 279,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `findRecord`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeFindRecordResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 297,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `queryRecord`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeQueryRecordResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 315,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `findAll`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeFindAllResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 333,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `findBelongsTo`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeFindBelongsToResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 351,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `findHasMany`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeFindHasManyResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 369,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `findMany`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeFindManyResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 387,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `query`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeQueryResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 405,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `createRecord`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeCreateRecordResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 423,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `deleteRecord`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeDeleteRecordResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 441,
      "description": "Called by the default normalizeResponse implementation when the\ntype of request is `updateRecord`",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeUpdateRecordResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 459,
      "description": "normalizeUpdateRecordResponse, normalizeCreateRecordResponse and\nnormalizeDeleteRecordResponse delegate to this method by default.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeSaveResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 477,
      "description": "normalizeQueryResponse and normalizeFindRecordResponse delegate to this\nmethod by default.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeSingleResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 495,
      "description": "normalizeQueryResponse, normalizeFindManyResponse, and normalizeFindHasManyResponse delegate\nto this method by default.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "normalizeArrayResponse",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 513,
      "itemtype": "method",
      "name": "_normalizeResponse",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        },
        {
          "name": "isSingle",
          "description": "",
          "type": "Boolean"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "access": "private",
      "tagname": "",
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 562,
      "description": "Normalizes a part of the JSON payload returned by\nthe server. You should override this method, munge the hash\nand call super if you have generic normalization to do.\n\nIt takes the type of the record that is being normalized\n(as a Model class), the property where the hash was\noriginally found, and the hash to normalize.\n\nYou can use this method, for example, to normalize underscored keys to camelized\nor other general-purpose normalizations.\n\nExample\n\n```app/serializers/application.js\nimport JSONSerializer from '@ember-data/serializer/json';\nimport { underscore } from '<app-name>/utils/string-utils';\nimport { get } from '@ember/object';\n\nexport default class ApplicationSerializer extends JSONSerializer {\n  normalize(typeClass, hash) {\n    let fields = typeClass.fields;\n\n    fields.forEach(function(type, field) {\n      let payloadField = underscore(field);\n      if (field === payloadField) { return; }\n\n      hash[field] = hash[payloadField];\n      delete hash[payloadField];\n    });\n\n    return super.normalize(...arguments);\n  }\n}\n```",
      "itemtype": "method",
      "name": "normalize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "typeClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "hash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 630,
      "description": "Returns the resource's ID.",
      "itemtype": "method",
      "name": "extractId",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelClass",
          "description": "",
          "type": "Object"
        },
        {
          "name": "resourceHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "String"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 645,
      "description": "Returns the resource's attributes formatted as a JSON-API \"attributes object\".\n\nhttp://jsonapi.org/format/#document-resource-object-attributes",
      "itemtype": "method",
      "name": "extractAttributes",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelClass",
          "description": "",
          "type": "Object"
        },
        {
          "name": "resourceHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 670,
      "description": "Returns a relationship formatted as a JSON-API \"relationship object\".\n\nhttp://jsonapi.org/format/#document-resource-object-relationships",
      "itemtype": "method",
      "name": "extractRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "relationshipModelName",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationshipHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 705,
      "description": "Returns a polymorphic relationship formatted as a JSON-API \"relationship object\".\n\nhttp://jsonapi.org/format/#document-resource-object-relationships\n\n`relationshipOptions` is a hash which contains more information about the\npolymorphic relationship which should be extracted:\n  - `resourceHash` complete hash of the resource the relationship should be\n    extracted from\n  - `relationshipKey` key under which the value for the relationship is\n    extracted from the resourceHash\n  - `relationshipMeta` meta information about the relationship",
      "itemtype": "method",
      "name": "extractPolymorphicRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "relationshipModelName",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationshipHash",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationshipOptions",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 729,
      "description": "Returns the resource's relationships formatted as a JSON-API \"relationships object\".\n\nhttp://jsonapi.org/format/#document-resource-object-relationships",
      "itemtype": "method",
      "name": "extractRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelClass",
          "description": "",
          "type": "Object"
        },
        {
          "name": "resourceHash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 801,
      "description": "Dasherizes the model name in the payload",
      "itemtype": "method",
      "name": "modelNameFromPayloadKey",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "the model's modelName",
        "type": "String"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 813,
      "itemtype": "method",
      "name": "normalizeRelationships",
      "access": "private",
      "tagname": "",
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 836,
      "itemtype": "method",
      "name": "normalizeUsingDeclaredMapping",
      "access": "private",
      "tagname": "",
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 869,
      "description": "Looks up the property key that was set by the custom `attr` mapping\npassed to the serializer.",
      "itemtype": "method",
      "name": "_getMappedKey",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "key",
        "type": "String"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 908,
      "description": "Check attrs.key.serialize property to inform if the `key`\ncan be serialized",
      "itemtype": "method",
      "name": "_canSerialize",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "true if the key can be serialized",
        "type": "Boolean"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 923,
      "description": "When attrs.key.serialize is set to true then\nit takes priority over the other checks and the related\nattribute/relationship will be serialized",
      "itemtype": "method",
      "name": "_mustSerialize",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "true if the key must be serialized",
        "type": "Boolean"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 939,
      "description": "Check if the given hasMany relationship should be serialized\n\nBy default only many-to-many and many-to-none relationships are serialized.\nThis could be configured per relationship by Serializer's `attrs` object.",
      "itemtype": "method",
      "name": "shouldSerializeHasMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "key",
          "description": "",
          "type": "String"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "RelationshipSchema"
        }
      ],
      "return": {
        "description": "true if the hasMany relationship should be serialized",
        "type": "Boolean"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 962,
      "description": "Called when a record is saved in order to convert the\nrecord into JSON.\n\nBy default, it creates a JSON object with a key for\neach attribute and belongsTo relationship.\n\nFor example, consider this model:\n\n```app/models/comment.js\nimport Model, { attr, belongsTo } from '@ember-data/model';\n\nexport default class CommentModel extends Model {\n  @attr title;\n  @attr body;\n\n  @belongsTo('user') author;\n}\n```\n\nThe default serialization would create a JSON object like:\n\n```javascript\n{\n  \"title\": \"Rails is unagi\",\n  \"body\": \"Rails? Omakase? O_O\",\n  \"author\": 12\n}\n```\n\nBy default, attributes are passed through as-is, unless\nyou specified an attribute type (`attr('date')`). If\nyou specify a transform, the JavaScript value will be\nserialized when inserted into the JSON hash.\n\nBy default, belongs-to relationships are converted into\nIDs when inserted into the JSON hash.\n\n## IDs\n\n`serialize` takes an options hash with a single option:\n`includeId`. If this option is `true`, `serialize` will,\nby default include the ID in the JSON object it builds.\n\nThe adapter passes in `includeId: true` when serializing\na record for `createRecord`, but not for `updateRecord`.\n\n## Customization\n\nYour server may expect a different JSON format than the\nbuilt-in serialization format.\n\nIn that case, you can implement `serialize` yourself and\nreturn a JSON hash of your choosing.\n\n```app/serializers/post.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class PostSerializer extends JSONSerializer {\n  serialize(snapshot, options) {\n    let json = {\n      POST_TTL: snapshot.attr('title'),\n      POST_BDY: snapshot.attr('body'),\n      POST_CMS: snapshot.hasMany('comments', { ids: true })\n    };\n\n    if (options.includeId) {\n      json.POST_ID_ = snapshot.id;\n    }\n\n    return json;\n  }\n}\n```\n\n## Customizing an App-Wide Serializer\n\nIf you want to define a serializer for your entire\napplication, you'll probably want to use `eachAttribute`\nand `eachRelationship` on the record.\n\n```app/serializers/application.js\nimport JSONSerializer from '@ember-data/serializer/json';\nimport { singularize } from '<app-name>/utils/string-utils';\n\nexport default class ApplicationSerializer extends JSONSerializer {\n  serialize(snapshot, options) {\n    let json = {};\n\n    snapshot.eachAttribute((name) => {\n      json[serverAttributeName(name)] = snapshot.attr(name);\n    });\n\n    snapshot.eachRelationship((name, relationship) => {\n      if (relationship.kind === 'hasMany') {\n        json[serverHasManyName(name)] = snapshot.hasMany(name, { ids: true });\n      }\n    });\n\n    if (options.includeId) {\n      json.ID_ = snapshot.id;\n    }\n\n    return json;\n  }\n}\n\nfunction serverAttributeName(attribute) {\n  return attribute.underscore().toUpperCase();\n}\n\nfunction serverHasManyName(name) {\n  return serverAttributeName(singularize(name)) + \"_IDS\";\n}\n```\n\nThis serializer will generate JSON that looks like this:\n\n```javascript\n{\n  \"TITLE\": \"Rails is omakase\",\n  \"BODY\": \"Yep. Omakase.\",\n  \"COMMENT_IDS\": [ \"1\", \"2\", \"3\" ]\n}\n```\n\n## Tweaking the Default JSON\n\nIf you just want to do some small tweaks on the default JSON,\nyou can call `super.serialize` first and make the tweaks on\nthe returned JSON.\n\n```app/serializers/post.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class PostSerializer extends JSONSerializer {\n  serialize(snapshot, options) {\n    let json = super.serialize(...arguments);\n\n    json.subject = json.title;\n    delete json.title;\n\n    return json;\n  }\n}\n```",
      "itemtype": "method",
      "name": "serialize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "json",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1140,
      "description": "You can use this method to customize how a serialized record is added to the complete\nJSON hash to be sent to the server. By default the JSON Serializer does not namespace\nthe payload and just sends the raw serialized JSON object.\nIf your server expects namespaced keys, you should consider using the RESTSerializer.\nOtherwise you can override this method to customize how the record is added to the hash.\nThe hash property should be modified by reference.\n\nFor example, your server may expect underscored root objects.\n\n```app/serializers/application.js\nimport RESTSerializer from '@ember-data/serializer/rest';\nimport { underscoren} from '<app-name>/utils/string-utils';\n\nexport default class ApplicationSerializer extends RESTSerializer {\n  serializeIntoHash(data, type, snapshot, options) {\n    let root = underscore(type.modelName);\n    data[root] = this.serialize(snapshot, options);\n  }\n}\n```",
      "itemtype": "method",
      "name": "serializeIntoHash",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "hash",
          "description": "",
          "type": "Object"
        },
        {
          "name": "typeClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1173,
      "description": "`serializeAttribute` can be used to customize how `attr`\nproperties are serialized\n\nFor example if you wanted to ensure all your attributes were always\nserialized as properties on an `attributes` object you could\nwrite:\n\n```app/serializers/application.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class ApplicationSerializer extends JSONSerializer {\n  serializeAttribute(snapshot, json, key, attributes) {\n    json.attributes = json.attributes || {};\n    super.serializeAttribute(snapshot, json.attributes, key, attributes);\n  }\n}\n```",
      "itemtype": "method",
      "name": "serializeAttribute",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "json",
          "description": "",
          "type": "Object"
        },
        {
          "name": "key",
          "description": "",
          "type": "String"
        },
        {
          "name": "attribute",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1221,
      "description": "`serializeBelongsTo` can be used to customize how `belongsTo`\nproperties are serialized.\n\nExample\n\n```app/serializers/post.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class PostSerializer extends JSONSerializer {\n  serializeBelongsTo(snapshot, json, relationship) {\n    let key = relationship.name;\n    let belongsTo = snapshot.belongsTo(key);\n\n    key = this.keyForRelationship ? this.keyForRelationship(key, \"belongsTo\", \"serialize\") : key;\n\n    json[key] = !belongsTo ? null : belongsTo.record.toJSON();\n  }\n}\n```",
      "itemtype": "method",
      "name": "serializeBelongsTo",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "json",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1275,
      "description": "`serializeHasMany` can be used to customize how `hasMany`\nproperties are serialized.\n\nExample\n\n```app/serializers/post.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class PostSerializer extends JSONSerializer {\n  serializeHasMany(snapshot, json, relationship) {\n    let key = relationship.name;\n    if (key === 'comments') {\n      return;\n    } else {\n      super.serializeHasMany(...arguments);\n    }\n  }\n}\n```",
      "itemtype": "method",
      "name": "serializeHasMany",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "json",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1322,
      "description": "You can use this method to customize how polymorphic objects are\nserialized. Objects are considered to be polymorphic if\n`{ polymorphic: true }` is pass as the second argument to the\n`belongsTo` function.\n\nExample\n\n```app/serializers/comment.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class CommentSerializer extends JSONSerializer {\n  serializePolymorphicType(snapshot, json, relationship) {\n    let key = relationship.name;\n    let belongsTo = snapshot.belongsTo(key);\n\n    key = this.keyForAttribute ? this.keyForAttribute(key, 'serialize') : key;\n\n    if (!belongsTo) {\n      json[key + '_type'] = null;\n    } else {\n      json[key + '_type'] = belongsTo.modelName;\n    }\n  }\n}\n```",
      "itemtype": "method",
      "name": "serializePolymorphicType",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "json",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1357,
      "description": "`extractMeta` is used to deserialize any meta information in the\nadapter payload. By default Ember Data expects meta information to\nbe located on the `meta` property of the payload object.\n\nExample\n\n```app/serializers/post.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class PostSerializer extends JSONSerializer {\n  extractMeta(store, typeClass, payload) {\n    if (payload && payload.hasOwnProperty('_pagination')) {\n      let meta = payload._pagination;\n      delete payload._pagination;\n      return meta;\n    }\n  }\n}\n```",
      "itemtype": "method",
      "name": "extractMeta",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "modelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1392,
      "description": "`extractErrors` is used to extract model errors when a call\nto `Model#save` fails with an `InvalidError`. By default\nEmber Data expects error information to be located on the `errors`\nproperty of the payload object.\n\nThis serializer expects this `errors` object to be an Array similar\nto the following, compliant with the https://jsonapi.org/format/#errors specification:\n\n```js\n{\n  \"errors\": [\n    {\n      \"detail\": \"This username is already taken!\",\n      \"source\": {\n        \"pointer\": \"data/attributes/username\"\n      }\n    }, {\n      \"detail\": \"Doesn't look like a valid email.\",\n      \"source\": {\n        \"pointer\": \"data/attributes/email\"\n      }\n    }\n  ]\n}\n```\n\nThe key `detail` provides a textual description of the problem.\nAlternatively, the key `title` can be used for the same purpose.\n\nThe nested keys `source.pointer` detail which specific element\nof the request data was invalid.\n\nNote that JSON-API also allows for object-level errors to be placed\nin an object with pointer `data`, signifying that the problem\ncannot be traced to a specific attribute:\n\n```javascript\n{\n  \"errors\": [\n    {\n      \"detail\": \"Some generic non property error message\",\n      \"source\": {\n        \"pointer\": \"data\"\n      }\n    }\n  ]\n}\n```\n\nWhen turn into a `Errors` object, you can read these errors\nthrough the property `base`:\n\n```handlebars\n{{#each @model.errors.base as |error|}}\n  <div class=\"error\">\n    {{error.message}}\n  </div>\n{{/each}}\n```\n\nExample of alternative implementation, overriding the default\nbehavior to deal with a different format of errors:\n\n```app/serializers/post.js\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class PostSerializer extends JSONSerializer {\n  extractErrors(store, typeClass, payload, id) {\n    if (payload && typeof payload === 'object' && payload._problems) {\n      payload = payload._problems;\n      this.normalizeErrors(typeClass, payload);\n    }\n    return payload;\n  }\n}\n```",
      "itemtype": "method",
      "name": "extractErrors",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "typeClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "(String|Number)"
        }
      ],
      "return": {
        "description": "json The deserialized errors",
        "type": "Object"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1527,
      "description": "`keyForAttribute` can be used to define rules for how to convert an\nattribute name in your model to a key in your JSON.\n\nExample\n\n```app/serializers/application.js\nimport JSONSerializer from '@ember-data/serializer/json';\nimport { underscore } from '<app-name>/utils/string-utils';\n\nexport default class ApplicationSerializer extends JSONSerializer {\n  keyForAttribute(attr, method) {\n    return underscore(attr).toUpperCase();\n  }\n}\n```",
      "itemtype": "method",
      "name": "keyForAttribute",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        },
        {
          "name": "method",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "normalized key",
        "type": "String"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1554,
      "description": "`keyForRelationship` can be used to define a custom key when\nserializing and deserializing relationship properties. By default\n`JSONSerializer` does not provide an implementation of this method.\n\nExample\n\n  ```app/serializers/post.js\n  import JSONSerializer from '@ember-data/serializer/json';\n  import { underscore } from '<app-name>/utils/string-utils';\n\n  export default class PostSerializer extends JSONSerializer {\n    keyForRelationship(key, relationship, method) {\n      return `rel_${underscore(key)}`;\n    }\n  }\n  ```",
      "itemtype": "method",
      "name": "keyForRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        },
        {
          "name": "typeClass",
          "description": "",
          "type": "String"
        },
        {
          "name": "method",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "normalized key",
        "type": "String"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1583,
      "description": "`keyForLink` can be used to define a custom key when deserializing link\nproperties.",
      "itemtype": "method",
      "name": "keyForLink",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        },
        {
          "name": "kind",
          "description": "`belongsTo` or `hasMany`",
          "type": "String"
        }
      ],
      "return": {
        "description": "normalized key",
        "type": "String"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/json.js",
      "line": 1599,
      "itemtype": "method",
      "name": "transformFor",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "attributeType",
          "description": "",
          "type": "String"
        },
        {
          "name": "skipAssertion",
          "description": "",
          "type": "Boolean"
        }
      ],
      "return": {
        "description": "transform",
        "type": "Transform"
      },
      "class": "JSONSerializer",
      "module": "@ember-data/serializer/json"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 70,
      "description": "`keyForPolymorphicType` can be used to define a custom key when\nserializing and deserializing a polymorphic type. By default, the\nreturned key is `${key}Type`.\n\nExample\n\n ```app/serializers/post.js\n import RESTSerializer from '@ember-data/serializer/rest';\n\n export default class ApplicationSerializer extends RESTSerializer {\n   keyForPolymorphicType(key, relationship) {\n     let relationshipKey = this.keyForRelationship(key);\n\n     return 'type-' + relationshipKey;\n   }\n }\n ```",
      "itemtype": "method",
      "name": "keyForPolymorphicType",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        },
        {
          "name": "typeClass",
          "description": "",
          "type": "String"
        },
        {
          "name": "method",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "normalized key",
        "type": "String"
      },
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 102,
      "description": "Normalizes a part of the JSON payload returned by\nthe server. You should override this method, munge the hash\nand call super if you have generic normalization to do.\n\nIt takes the type of the record that is being normalized\n(as a Model class), the property where the hash was\noriginally found, and the hash to normalize.\n\nFor example, if you have a payload that looks like this:\n\n```js\n{\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Rails is omakase\",\n    \"comments\": [ 1, 2 ]\n  },\n  \"comments\": [{\n    \"id\": 1,\n    \"body\": \"FIRST\"\n  }, {\n    \"id\": 2,\n    \"body\": \"Rails is unagi\"\n  }]\n}\n```\n\nThe `normalize` method will be called three times:\n\n* With `App.Post`, `\"posts\"` and `{ id: 1, title: \"Rails is omakase\", ... }`\n* With `App.Comment`, `\"comments\"` and `{ id: 1, body: \"FIRST\" }`\n* With `App.Comment`, `\"comments\"` and `{ id: 2, body: \"Rails is unagi\" }`\n\nYou can use this method, for example, to normalize underscored keys to camelized\nor other general-purpose normalizations. You will only need to implement\n`normalize` and manipulate the payload as desired.\n\nFor example, if the `IDs` under `\"comments\"` are provided as `_id` instead of\n`id`, you can specify how to normalize just the comments:\n\n```app/serializers/post.js\nimport RESTSerializer from '@ember-data/serializer/rest';\n\nexport default class ApplicationSerializer extends RESTSerializer {\n  normalize(model, hash, prop) {\n    if (prop === 'comments') {\n      hash.id = hash._id;\n      delete hash._id;\n    }\n\n    return super.normalize(...arguments);\n  }\n}\n```\n\nOn each call to the `normalize` method, the third parameter (`prop`) is always\none of the keys that were in the original payload or in the result of another\nnormalization as `normalizeResponse`.",
      "itemtype": "method",
      "name": "normalize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "resourceHash",
          "description": "",
          "type": "Object"
        },
        {
          "name": "prop",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 170,
      "description": "Normalizes an array of resource payloads and returns a JSON-API Document\nwith primary data and, if any, included data as `{ data, included }`.",
      "itemtype": "method",
      "name": "_normalizeArray",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        },
        {
          "name": "arrayHash",
          "description": "",
          "type": "Object"
        },
        {
          "name": "prop",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "access": "private",
      "tagname": "",
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 221,
      "itemtype": "method",
      "name": "_normalizeResponse",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "primaryModelClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Number"
        },
        {
          "name": "requestType",
          "description": "",
          "type": "String"
        },
        {
          "name": "isSingle",
          "description": "",
          "type": "Boolean"
        }
      ],
      "return": {
        "description": "JSON-API Document",
        "type": "Object"
      },
      "access": "private",
      "tagname": "",
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 365,
      "description": "This method allows you to push a payload containing top-level\ncollections of records organized per type.\n\n```js\n{\n  \"posts\": [{\n    \"id\": \"1\",\n    \"title\": \"Rails is omakase\",\n    \"author\", \"1\",\n    \"comments\": [ \"1\" ]\n  }],\n  \"comments\": [{\n    \"id\": \"1\",\n    \"body\": \"FIRST\"\n  }],\n  \"users\": [{\n    \"id\": \"1\",\n    \"name\": \"@d2h\"\n  }]\n}\n```\n\nIt will first normalize the payload, so you can use this to push\nin data streaming in from your server structured the same way\nthat fetches and saves are structured.",
      "itemtype": "method",
      "name": "pushPayload",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "store",
          "description": "",
          "type": "Store"
        },
        {
          "name": "payload",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 428,
      "description": "This method is used to convert each JSON root key in the payload\ninto a modelName that it can use to look up the appropriate model for\nthat part of the payload.\n\nFor example, your server may send a model name that does not correspond with\nthe name of the model in your app. Let's take a look at an example model,\nand an example payload:\n\n```app/models/post.js\nimport Model from '@ember-data/model';\n\nexport default class Post extends Model {}\n```\n\n```javascript\n  {\n    \"blog/post\": {\n      \"id\": \"1\n    }\n  }\n```\n\nEmber Data is going to normalize the payload's root key for the modelName. As a result,\nit will try to look up the \"blog/post\" model. Since we don't have a model called \"blog/post\"\n(or a file called app/models/blog/post.js in ember-cli), Ember Data will throw an error\nbecause it cannot find the \"blog/post\" model.\n\nSince we want to remove this namespace, we can define a serializer for the application that will\nremove \"blog/\" from the payload key whenver it's encountered by Ember Data:\n\n```app/serializers/application.js\nimport RESTSerializer from '@ember-data/serializer/rest';\n\nexport default class ApplicationSerializer extends RESTSerializer {\n  modelNameFromPayloadKey(payloadKey) {\n    if (payloadKey === 'blog/post') {\n      return super.modelNameFromPayloadKey(payloadKey.replace('blog/', ''));\n    } else {\n     return super.modelNameFromPayloadKey(payloadKey);\n    }\n  }\n}\n```\n\nAfter refreshing, Ember Data will appropriately look up the \"post\" model.\n\nBy default the modelName for a model is its\nname in dasherized form. This means that a payload key like \"blogPost\" would be\nnormalized to \"blog-post\" when Ember Data looks up the model. Usually, Ember Data\ncan use the correct inflection to do this for you. Most of the time, you won't\nneed to override `modelNameFromPayloadKey` for this purpose.",
      "itemtype": "method",
      "name": "modelNameFromPayloadKey",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "key",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "the model's modelName",
        "type": "String"
      },
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 492,
      "description": "Called when a record is saved in order to convert the\nrecord into JSON.\n\nBy default, it creates a JSON object with a key for\neach attribute and belongsTo relationship.\n\nFor example, consider this model:\n\n```app/models/comment.js\nimport Model, { attr, belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @attr title\n  @attr body\n\n  @belongsTo('user') author\n}\n```\n\nThe default serialization would create a JSON object like:\n\n```js\n{\n  \"title\": \"Rails is unagi\",\n  \"body\": \"Rails? Omakase? O_O\",\n  \"author\": 12\n}\n```\n\nBy default, attributes are passed through as-is, unless\nyou specified an attribute type (`attr('date')`). If\nyou specify a transform, the JavaScript value will be\nserialized when inserted into the JSON hash.\n\nBy default, belongs-to relationships are converted into\nIDs when inserted into the JSON hash.\n\n## IDs\n\n`serialize` takes an options hash with a single option:\n`includeId`. If this option is `true`, `serialize` will,\nby default include the ID in the JSON object it builds.\n\nThe adapter passes in `includeId: true` when serializing\na record for `createRecord`, but not for `updateRecord`.\n\n## Customization\n\nYour server may expect a different JSON format than the\nbuilt-in serialization format.\n\nIn that case, you can implement `serialize` yourself and\nreturn a JSON hash of your choosing.\n\n```app/serializers/post.js\nimport RESTSerializer from '@ember-data/serializer/rest';\n\nexport default class ApplicationSerializer extends RESTSerializer {\n  serialize(snapshot, options) {\n    let json = {\n      POST_TTL: snapshot.attr('title'),\n      POST_BDY: snapshot.attr('body'),\n      POST_CMS: snapshot.hasMany('comments', { ids: true })\n    };\n\n    if (options.includeId) {\n      json.POST_ID_ = snapshot.id;\n    }\n\n    return json;\n  }\n}\n```\n\n## Customizing an App-Wide Serializer\n\nIf you want to define a serializer for your entire\napplication, you'll probably want to use `eachAttribute`\nand `eachRelationship` on the record.\n\n```app/serializers/application.js\nimport RESTSerializer from '@ember-data/serializer/rest';\nimport { pluralize } from '<app-name>/utils/string-utils';\n\nexport default class ApplicationSerializer extends RESTSerializer {\n  serialize(snapshot, options) {\n    let json = {};\n\n    snapshot.eachAttribute(function(name) {\n      json[serverAttributeName(name)] = snapshot.attr(name);\n    });\n\n    snapshot.eachRelationship(function(name, relationship) {\n      if (relationship.kind === 'hasMany') {\n        json[serverHasManyName(name)] = snapshot.hasMany(name, { ids: true });\n      }\n    });\n\n    if (options.includeId) {\n      json.ID_ = snapshot.id;\n    }\n\n    return json;\n  }\n}\n\nfunction serverAttributeName(attribute) {\n  return attribute.underscore().toUpperCase();\n}\n\nfunction serverHasManyName(name) {\n  return serverAttributeName(singularize(name)) + \"_IDS\";\n}\n```\n\nThis serializer will generate JSON that looks like this:\n\n```js\n{\n  \"TITLE\": \"Rails is omakase\",\n  \"BODY\": \"Yep. Omakase.\",\n  \"COMMENT_IDS\": [ 1, 2, 3 ]\n}\n```\n\n## Tweaking the Default JSON\n\nIf you just want to do some small tweaks on the default JSON,\nyou can call super first and make the tweaks on the returned\nJSON.\n\n```app/serializers/post.js\nimport RESTSerializer from '@ember-data/serializer/rest';\n\nexport default class ApplicationSerializer extends RESTSerializer {\n  serialize(snapshot, options) {\n    let json = super.serialize(snapshot, options);\n\n    json.subject = json.title;\n    delete json.title;\n\n    return json;\n  }\n}\n```",
      "itemtype": "method",
      "name": "serialize",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "json",
        "type": "Object"
      },
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 649,
      "description": "You can use this method to customize the root keys serialized into the JSON.\nThe hash property should be modified by reference (possibly using something like _.extend)\nBy default the REST Serializer sends the modelName of a model, which is a camelized\nversion of the name.\n\nFor example, your server may expect underscored root objects.\n\n```app/serializers/application.js\nimport RESTSerializer from '@ember-data/serializer/rest';\nimport { underscore } from '<app-name>/utils/string-utils';\n\nexport default class ApplicationSerializer extends RESTSerializer {\n  serializeIntoHash(data, type, record, options) {\n    let root = underscore(type.modelName);\n    data[root] = this.serialize(record, options);\n  }\n}\n```",
      "itemtype": "method",
      "name": "serializeIntoHash",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "hash",
          "description": "",
          "type": "Object"
        },
        {
          "name": "typeClass",
          "description": "",
          "type": "Model"
        },
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 681,
      "description": "You can use `payloadKeyFromModelName` to override the root key for an outgoing\nrequest. By default, the RESTSerializer returns a camelized version of the\nmodel's name.\n\nFor a model called TacoParty, its `modelName` would be the string `taco-party`. The RESTSerializer\nwill send it to the server with `tacoParty` as the root key in the JSON payload:\n\n```js\n{\n  \"tacoParty\": {\n    \"id\": \"1\",\n    \"location\": \"Matthew Beale's House\"\n  }\n}\n```\n\nFor example, your server may expect dasherized root objects:\n\n```app/serializers/application.js\nimport RESTSerializer from '@ember-data/serializer/rest';\nimport { dasherize } from '<app-name>/utils/string-utils';\n\nexport default class ApplicationSerializer extends RESTSerializer {\n  payloadKeyFromModelName(modelName) {\n    return dasherize(modelName);\n  }\n}\n```\n\nGiven a `TacoParty` model, calling `save` on it would produce an outgoing\nrequest like:\n\n```js\n{\n  \"taco-party\": {\n    \"id\": \"1\",\n    \"location\": \"Matthew Beale's House\"\n  }\n}\n```",
      "itemtype": "method",
      "name": "payloadKeyFromModelName",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "String"
      },
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 732,
      "description": "You can use this method to customize how polymorphic objects are serialized.\nBy default the REST Serializer creates the key by appending `Type` to\nthe attribute and value from the model's camelcased model name.",
      "itemtype": "method",
      "name": "serializePolymorphicType",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "snapshot",
          "description": "",
          "type": "Snapshot"
        },
        {
          "name": "json",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationship",
          "description": "",
          "type": "Object"
        }
      ],
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/serializer/src/rest.js",
      "line": 755,
      "description": "You can use this method to customize how a polymorphic relationship should\nbe extracted.",
      "itemtype": "method",
      "name": "extractPolymorphicRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "relationshipType",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationshipHash",
          "description": "",
          "type": "Object"
        },
        {
          "name": "relationshipOptions",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "Object"
      },
      "class": "RESTSerializer",
      "module": "@ember-data/serializer/rest"
    },
    {
      "file": "../packages/store/src/-private/cache-handler/types.ts",
      "line": 21,
      "description": "Invoked to determine if the request may be fulfilled from cache\nif possible.\n\nNote, this is only invoked if the request has a cache-key.\n\nIf no cache entry is found or the entry is hard expired,\nthe request will be fulfilled from the configured request handlers\nand the cache will be updated before returning the response.",
      "itemtype": "method",
      "name": "isHardExpired",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableDocumentIdentifier"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        }
      ],
      "return": {
        "description": "true if the request is considered hard expired",
        "type": "Boolean"
      },
      "class": "<Interface> CachePolicy",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/cache-handler/types.ts",
      "line": 38,
      "description": "Invoked if `isHardExpired` is false to determine if the request\nshould be update behind the scenes if cache data is already available.\n\nNote, this is only invoked if the request has a cache-key.\n\nIf true, the request will be fulfilled from cache while a backgrounded\nrequest is made to update the cache via the configured request handlers.",
      "itemtype": "method",
      "name": "isSoftExpired",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableDocumentIdentifier"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        }
      ],
      "return": {
        "description": "true if the request is considered soft expired",
        "type": "Boolean"
      },
      "class": "<Interface> CachePolicy",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/cache-handler/types.ts",
      "line": 55,
      "description": "Invoked when a request will be sent to the configured request handlers.\nThis is invoked for both foreground and background requests.\n\nNote, this is invoked regardless of whether the request has a cache-key.",
      "itemtype": "method",
      "name": "willRequest [Optional]",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "request",
          "description": "",
          "type": "ImmutableRequestInfo"
        },
        {
          "name": "identifier",
          "description": "",
          "type": "StableDocumentIdentifier | null"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "class": "<Interface> CachePolicy",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/cache-handler/types.ts",
      "line": 70,
      "description": "Invoked when a request has been fulfilled from the configured request handlers.\nThis is invoked for both foreground and background requests once the cache has\nbeen updated.\n\nNote, this is invoked regardless of whether the request has a cache-key.\n\nIt is best practice to notify the store of any requests marked as invalidated\nso that request subscriptions can reload when needed.\n\n```ts\nstore.notifications.notify(identifier, 'invalidated');\n```\n\nThis allows anything subscribed to the request to be notified of the change\n\ne.g.\n\n```ts\nstore.notifications.subscribe(identifier, (_, type) => {\n  if (type === 'invalidated') {\n    // do update\n  }\n});\n```\n\nNote,",
      "itemtype": "method",
      "name": "didRequest [Optional]",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "request",
          "description": "",
          "type": "ImmutableRequestInfo"
        },
        {
          "name": "response",
          "description": "",
          "type": "ImmutableResponse"
        },
        {
          "name": "identifier",
          "description": "",
          "type": "StableDocumentIdentifier | null"
        },
        {
          "name": "store",
          "description": "",
          "type": "Store"
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "class": "<Interface> CachePolicy",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/identifier-cache.ts",
      "line": 264,
      "description": "Internal hook to allow management of merge conflicts with identifiers.\n\nwe allow late binding of this private internal merge so that\nthe cache can insert itself here to handle elimination of duplicates",
      "itemtype": "method",
      "name": "__configureMerge",
      "access": "private",
      "tagname": "",
      "class": "IdentifierCache",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/identifier-cache.ts",
      "line": 281,
      "itemtype": "method",
      "name": "_getRecordIdentifier",
      "access": "private",
      "tagname": "",
      "class": "IdentifierCache",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/identifier-cache.ts",
      "line": 360,
      "description": "allows us to peek without generating when needed\nuseful for the \"create\" case when we need to see if\nwe are accidentally overwritting something",
      "itemtype": "method",
      "name": "peekRecordIdentifier",
      "params": [
        {
          "name": "resource",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "StableRecordIdentifier | undefined"
      },
      "access": "private",
      "tagname": "",
      "class": "IdentifierCache",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/identifier-cache.ts",
      "line": 374,
      "description": "Returns the DocumentIdentifier for the given Request, creates one if it does not yet exist.\nReturns `null` if the request does not have a `cacheKey` or `url`.",
      "itemtype": "method",
      "name": "getOrCreateDocumentIdentifier",
      "params": [
        {
          "name": "request",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "StableDocumentIdentifier | null"
      },
      "access": "public",
      "tagname": "",
      "class": "IdentifierCache",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/identifier-cache.ts",
      "line": 408,
      "description": "Returns the Identifier for the given Resource, creates one if it does not yet exist.\n\nSpecifically this means that we:\n\n- validate the `id` `type` and `lid` combo against known identifiers\n- return an object with an `lid` that is stable (repeated calls with the same\n  `id` + `type` or `lid` will return the same `lid` value)\n- this referential stability of the object itself is guaranteed",
      "itemtype": "method",
      "name": "getOrCreateRecordIdentifier",
      "params": [
        {
          "name": "resource",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "StableRecordIdentifier"
      },
      "access": "public",
      "tagname": "",
      "class": "IdentifierCache",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/identifier-cache.ts",
      "line": 427,
      "description": "Returns a new Identifier for the supplied data. Call this method to generate\nan identifier when a new resource is being created local to the client and\npotentially does not have an `id`.\n\nDelegates generation to the user supplied `GenerateMethod` if one has been provided\nwith the signature `generateMethod({ type }, 'record')`.",
      "itemtype": "method",
      "name": "createIdentifierForNewRecord",
      "params": [
        {
          "name": "data",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "StableRecordIdentifier"
      },
      "access": "public",
      "tagname": "",
      "class": "IdentifierCache",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/identifier-cache.ts",
      "line": 465,
      "description": "Provides the opportunity to update secondary lookup tables for existing identifiers\nCalled after an identifier created with `createIdentifierForNewRecord` has been\ncommitted.\n\nAssigned `id` to an `Identifier` if `id` has not previously existed; however,\nattempting to change the `id` or calling update without providing an `id` when\none is missing will throw an error.\n\n - sets `id` (if `id` was previously `null`)\n - `lid` and `type` MUST NOT be altered post creation\n\n If a merge occurs, it is possible the returned identifier does not match the originally\n provided identifier. In this case the abandoned identifier will go through the usual\n `forgetRecordIdentifier` codepaths.",
      "itemtype": "method",
      "name": "updateRecordIdentifier",
      "params": [
        {
          "name": "identifierObject",
          "description": ""
        },
        {
          "name": "data",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "StableRecordIdentifier"
      },
      "access": "public",
      "tagname": "",
      "class": "IdentifierCache",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/identifier-cache.ts",
      "line": 555,
      "itemtype": "method",
      "name": "_mergeRecordIdentifiers",
      "access": "private",
      "tagname": "",
      "class": "IdentifierCache",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/identifier-cache.ts",
      "line": 600,
      "description": "Provides the opportunity to eliminate an identifier from secondary lookup tables\nas well as eliminates it from ember-data's own lookup tables and book keeping.\n\nUseful when a record has been deleted and the deletion has been persisted and\nwe do not care about the record anymore. Especially useful when an `id` of a\ndeleted record might be reused later for a new record.",
      "itemtype": "method",
      "name": "forgetRecordIdentifier",
      "params": [
        {
          "name": "identifierObject",
          "description": ""
        }
      ],
      "access": "public",
      "tagname": "",
      "class": "IdentifierCache",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/caches/instance-cache.ts",
      "line": 48,
      "description": "Retrieves the unique referentially-stable [RecordIdentifier](/ember-data/release/classes/StableRecordIdentifier)\nassigned to the given record instance.\n```js\nimport { recordIdentifierFor } from \"@ember-data/store\";\n// ... gain access to a record, for instance with peekRecord or findRecord\nconst record = store.peekRecord(\"user\", \"1\");\n// get the identifier for the record (see docs for StableRecordIdentifier)\nconst identifier = recordIdentifierFor(record);\n// access the identifier's properties.\nconst { id, type, lid } = identifier;\n```",
      "itemtype": "method",
      "name": "recordIdentifierFor",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "record",
          "description": "a record instance previously obstained from the store.",
          "type": "Object"
        }
      ],
      "return": {
        "description": "",
        "type": "StableRecordIdentifier"
      },
      "class": "@ember-data/store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/legacy-model-support/record-reference.ts",
      "line": 53,
      "description": "The `id` of the record that this reference refers to.\n\nTogether, the `type` and `id` properties form a composite key for\nthe identity map.\n\nExample\n\n```javascript\nlet userRef = store.getReference('user', 1);\n\nuserRef.id(); // '1'\n```",
      "itemtype": "method",
      "name": "id",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The id of the record.",
        "type": "String"
      },
      "class": "RecordReference",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/legacy-model-support/record-reference.ts",
      "line": 77,
      "description": "The `identifier` of the record that this reference refers to.\n\nTogether, the `type` and `id` properties form a composite key for\nthe identity map.\n\nExample\n\n```javascript\nlet userRef = store.getReference('user', 1);\n\nuserRef.identifier(); // '1'\n```",
      "itemtype": "method",
      "name": "identifier",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "The identifier of the record.",
        "type": "String"
      },
      "class": "RecordReference",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/legacy-model-support/record-reference.ts",
      "line": 99,
      "description": "How the reference will be looked up when it is loaded. Currently\nthis always returns `identity` to signify that a record will be\nloaded by its `type` and `id`.\n\nExample\n\n```javascript\nconst userRef = store.getReference('user', 1);\n\nuserRef.remoteType(); // 'identity'\n```",
      "itemtype": "method",
      "name": "remoteType",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "'identity'",
        "type": "String"
      },
      "class": "RecordReference",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/legacy-model-support/record-reference.ts",
      "line": 120,
      "description": "This API allows you to provide a reference with new data. The\nsimplest usage of this API is similar to `store.push`: you provide a\nnormalized hash of data and the object represented by the reference\nwill update.\n\nIf you pass a promise to `push`, Ember Data will not ask the adapter\nfor the data if another attempt to fetch it is made in the\ninterim. When the promise resolves, the underlying object is updated\nwith the new data, and the promise returned by *this function* is resolved\nwith that object.\n\nFor example, `recordReference.push(promise)` will be resolved with a\nrecord.\n\n Example\n\n ```javascript\n let userRef = store.getReference('user', 1);\n\n // provide data for reference\n userRef.push({\n   data: {\n     id: \"1\",\n     type: \"user\",\n     attributes: {\n       username: \"@user\"\n     }\n   }\n }).then(function(user) {\n   userRef.value() === user;\n });\n ```",
      "itemtype": "method",
      "name": "push",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "objectOrPromise",
          "description": "a JSON:API ResourceDocument or a promise resolving to one"
        }
      ],
      "return": {
        "description": "a promise for the value (record or relationship)"
      },
      "class": "RecordReference",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/legacy-model-support/record-reference.ts",
      "line": 166,
      "description": "If the entity referred to by the reference is already loaded, it is\npresent as `reference.value`. Otherwise the value returned by this function\nis `null`.\n\n Example\n\n ```javascript\n let userRef = store.getReference('user', 1);\n\n userRef.value(); // user\n ```",
      "itemtype": "method",
      "name": "value",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "the record for this RecordReference",
        "type": "Model"
      },
      "class": "RecordReference",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/legacy-model-support/record-reference.ts",
      "line": 187,
      "description": "Triggers a fetch for the backing entity based on its `remoteType`\n(see `remoteType` definitions per reference type).\n\nExample\n\n```javascript\nlet userRef = store.getReference('user', 1);\n\n// load user (via store.find)\nuserRef.load().then(...)\n```",
      "itemtype": "method",
      "name": "load",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "the record for this RecordReference",
        "type": "Promise<record>"
      },
      "class": "RecordReference",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/legacy-model-support/record-reference.ts",
      "line": 212,
      "description": "Reloads the record if it is already loaded. If the record is not\nloaded it will load the record via `store.findRecord`\n\nExample\n\n```javascript\nlet userRef = store.getReference('user', 1);\n\n// or trigger a reload\nuserRef.reload().then(...)\n```",
      "itemtype": "method",
      "name": "reload",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "the record for this RecordReference",
        "type": "Promise<record>"
      },
      "class": "RecordReference",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 44,
      "description": "Cache the response to a request\n\nUnlike `store.push` which has UPSERT\nsemantics, `put` has `replace` semantics similar to\nthe `http` method `PUT`\n\nthe individually cacheable\ne resource data it may contain\nshould upsert, but the document data surrounding it should\nfully replace any existing information\n\nNote that in order to support inserting arbitrary data\nto the cache that did not originate from a request `put`\nshould expect to sometimes encounter a document with only\na `content` member and therefor must not assume the existence\nof `request` and `response` on the document.",
      "itemtype": "method",
      "name": "put",
      "params": [
        {
          "name": "doc",
          "description": "",
          "type": "StructuredDocument"
        }
      ],
      "return": {
        "description": "",
        "type": "ResourceDocument"
      },
      "access": "public",
      "tagname": "",
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 71,
      "description": "Perform an operation on the cache to update the remote state.\n\nNote: currently the only valid operation is a MergeOperation\nwhich occurs when a collision of identifiers is detected.",
      "itemtype": "method",
      "name": "patch",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "op",
          "description": "the operation to perform"
        }
      ],
      "return": {
        "description": "",
        "type": "Void"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 86,
      "description": "Update resource data with a local mutation. Currently supports operations\non relationships only.",
      "itemtype": "method",
      "name": "mutate",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "mutation",
          "description": ""
        }
      ],
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 98,
      "description": "Peek resource data from the Cache.\n\nIn development, if the return value\nis JSON the return value\nwill be deep-cloned and deep-frozen\nto prevent mutation thereby enforcing cache\nImmutability.\n\nThis form of peek is useful for implementations\nthat want to feed raw-data from cache to the UI\nor which want to interact with a blob of data\ndirectly from the presentation cache.\n\nAn implementation might want to do this because\nde-referencing records which read from their own\nblob is generally safer because the record does\nnot require retaining connections to the Store\nand Cache to present data on a per-field basis.\n\nThis generally takes the place of `getAttr` as\nan API and may even take the place of `getRelationship`\ndepending on implementation specifics, though this\nlatter usage is less recommended due to the advantages\nof the Graph handling necessary entanglements and\nnotifications for relational data.",
      "itemtype": "method",
      "name": "peek",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier | StableDocumentIdentifier"
        }
      ],
      "return": {
        "description": "the known resource data",
        "type": "ResourceDocument | ResourceBlob | null"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 141,
      "description": "Peek the Cache for the existing request data associated with\na cacheable request",
      "itemtype": "method",
      "name": "peekRequest",
      "params": [
        {
          "name": "UNKNOWN",
          "description": "",
          "type": "StableDocumentIdentifier"
        }
      ],
      "return": {
        "description": "",
        "type": "StableDocumentIdentifier | null"
      },
      "access": "public",
      "tagname": "",
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 154,
      "description": "Push resource data from a remote source into the cache for this identifier",
      "itemtype": "method",
      "name": "upsert",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "data",
          "description": ""
        },
        {
          "name": "hasRecord",
          "description": ""
        }
      ],
      "return": {
        "description": "if `hasRecord` is true then calculated key changes should be returned",
        "type": "Void | string[]"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 171,
      "description": "Create a fork of the cache from the current state.\n\nApplications should typically not call this method themselves,\npreferring instead to fork at the Store level, which will\nutilize this method to fork the cache.",
      "itemtype": "method",
      "name": "fork",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "Promise<Cache>"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 186,
      "description": "Merge a fork back into a parent Cache.\n\nApplications should typically not call this method themselves,\npreferring instead to merge at the Store level, which will\nutilize this method to merge the caches.",
      "itemtype": "method",
      "name": "merge",
      "params": [
        {
          "name": "cache",
          "description": "",
          "type": "Cache"
        }
      ],
      "access": "public",
      "tagname": "",
      "return": {
        "description": "Promise<void>"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 202,
      "description": "Generate the list of changes applied to all\nrecord in the store.\n\nEach individual resource or document that has\nbeen mutated should be described as an individual\n`Change` entry in the returned array.\n\nA `Change` is described by an object containing up to\nthree properties: (1) the `identifier` of the entity that\nchanged; (2) the `op` code of that change being one of\n`upsert` or `remove`, and if the op is `upsert` a `patch`\ncontaining the data to merge into the cache for the given\nentity.\n\nThis `patch` is opaque to the Store but should be understood\nby the Cache and may expect to be utilized by an Adapter\nwhen generating data during a `save` operation.\n\nIt is generally recommended that the `patch` contain only\nthe updated state, ignoring fields that are unchanged\n\n```ts\ninterface Change {\n identifier: StableRecordIdentifier | StableDocumentIdentifier;\n op: 'upsert' | 'remove';\n patch?: unknown;\n}\n```",
      "itemtype": "method",
      "name": "diff",
      "access": "public",
      "tagname": "",
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 242,
      "description": "Serialize the entire contents of the Cache into a Stream\nwhich may be fed back into a new instance of the same Cache\nvia `cache.hydrate`.",
      "itemtype": "method",
      "name": "dump",
      "return": {
        "description": "",
        "type": "Promise<ReadableStream>"
      },
      "access": "public",
      "tagname": "",
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 255,
      "description": "hydrate a Cache from a Stream with content previously serialized\nfrom another instance of the same Cache, resolving when hydration\nis complete.\n\nThis method should expect to be called both in the context of restoring\nthe Cache during application rehydration after SSR **AND** at unknown\ntimes during the lifetime of an already booted application when it is\ndesired to bulk-load additional information into the cache. This latter\nbehavior supports optimizing pre/fetching of data for route transitions\nvia data-only SSR modes.",
      "itemtype": "method",
      "name": "hydrate",
      "params": [
        {
          "name": "stream",
          "description": "",
          "type": "ReadableStream"
        }
      ],
      "return": {
        "description": "",
        "type": "Promise<void>"
      },
      "access": "public",
      "tagname": "",
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 282,
      "description": "[LIFECYCLE] Signal to the cache that a new record has been instantiated on the client\n\nIt returns properties from options that should be set on the record during the create\nprocess. This return value behavior is deprecated.",
      "itemtype": "method",
      "name": "clientDidCreate",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 297,
      "description": "[LIFECYCLE] Signals to the cache that a resource\nwill be part of a save transaction.",
      "itemtype": "method",
      "name": "willCommit",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 309,
      "description": "[LIFECYCLE] Signals to the cache that a resource\nwas successfully updated as part of a save transaction.",
      "itemtype": "method",
      "name": "didCommit",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "data",
          "description": ""
        }
      ],
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 322,
      "description": "[LIFECYCLE] Signals to the cache that a resource\nwas update via a save transaction failed.",
      "itemtype": "method",
      "name": "commitWasRejected",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "errors",
          "description": ""
        }
      ],
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 335,
      "description": "[LIFECYCLE] Signals to the cache that all data for a resource\nshould be cleared.",
      "itemtype": "method",
      "name": "unloadRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 350,
      "description": "Retrieve the data for an attribute from the cache",
      "itemtype": "method",
      "name": "getAttr",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "propertyName",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Unknown"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 363,
      "description": "Retrieve the remote state for an attribute from the cache",
      "itemtype": "method",
      "name": "getRemoteAttr",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "propertyName",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Unknown"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 376,
      "description": "Mutate the data for an attribute in the cache",
      "itemtype": "method",
      "name": "setAttr",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "propertyName",
          "description": ""
        },
        {
          "name": "value",
          "description": ""
        }
      ],
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 389,
      "description": "Query the cache for the changed attributes of a resource.",
      "itemtype": "method",
      "name": "changedAttrs",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": ""
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 401,
      "description": "Query the cache for whether any mutated attributes exist",
      "itemtype": "method",
      "name": "hasChangedAttrs",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 413,
      "description": "Tell the cache to discard any uncommitted mutations to attributes",
      "itemtype": "method",
      "name": "rollbackAttrs",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "the names of attributes that were restored"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 428,
      "description": "Query the cache for the changes to relationships of a resource.\n\nReturns a map of relationship names to RelationshipDiff objects.\n\n```ts\ntype RelationshipDiff =\n | {\n     kind: 'collection';\n     remoteState: StableRecordIdentifier[];\n     additions: Set<StableRecordIdentifier>;\n     removals: Set<StableRecordIdentifier>;\n     localState: StableRecordIdentifier[];\n     reordered: boolean;\n   }\n | {\n     kind: 'resource';\n     remoteState: StableRecordIdentifier | null;\n     localState: StableRecordIdentifier | null;\n   };\n   ```",
      "itemtype": "method",
      "name": "changedRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "",
        "type": "Map<string, RelationshipDiff>"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 459,
      "description": "Query the cache for whether any mutated attributes exist",
      "itemtype": "method",
      "name": "hasChangedRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 471,
      "description": "Tell the cache to discard any uncommitted mutations to relationships.\n\nThis will also discard the change on any appropriate inverses.\n\nThis method is a candidate to become a mutation",
      "itemtype": "method",
      "name": "rollbackRelationships",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "the names of relationships that were restored",
        "type": "String[]"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 487,
      "description": "Query the cache for the current state of a relationship property",
      "itemtype": "method",
      "name": "getRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "propertyName",
          "description": ""
        }
      ],
      "return": {
        "description": "resource relationship object"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 503,
      "description": "Query the cache for the remote state of a relationship property",
      "itemtype": "method",
      "name": "getRelationship",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "propertyName",
          "description": ""
        }
      ],
      "return": {
        "description": "resource relationship object"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 522,
      "description": "Update the cache state for the given resource to be marked as locally deleted,\nor remove such a mark.",
      "itemtype": "method",
      "name": "setIsDeleted",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "isDeleted",
          "description": ""
        }
      ],
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 535,
      "description": "Query the cache for any validation errors applicable to the given resource.",
      "itemtype": "method",
      "name": "getErrors",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": ""
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 547,
      "description": "Query the cache for whether a given resource has any available data",
      "itemtype": "method",
      "name": "isEmpty",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 559,
      "description": "Query the cache for whether a given resource was created locally and not\nyet persisted.",
      "itemtype": "method",
      "name": "isNew",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 572,
      "description": "Query the cache for whether a given resource is marked as deleted (but not\nnecessarily persisted yet).",
      "itemtype": "method",
      "name": "isDeleted",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/cache-manager.ts",
      "line": 585,
      "description": "Query the cache for whether a given resource has been deleted and that deletion\nhas also been persisted.",
      "itemtype": "method",
      "name": "isDeletionCommitted",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "CacheManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/notification-manager.ts",
      "line": 122,
      "description": "Subscribe to changes for a given resource identifier, resource addition/removal, or document addition/removal.\n\n```ts\nexport type CacheOperation = 'added' | 'removed' | 'updated' | 'state';\n\nexport interface NotificationCallback {\n  (identifier: StableRecordIdentifier, notificationType: 'attributes' | 'relationships', key?: string): void;\n  (identifier: StableRecordIdentifier, notificationType: 'errors' | 'meta' | 'identity' | 'state'): void;\n  (identifier: StableRecordIdentifier, notificationType: NotificationType, key?: string): void;\n}\nexport interface ResourceOperationCallback {\n  // resource updates\n  (identifier: StableRecordIdentifier, notificationType: CacheOperation): void;\n}\nexport interface DocumentOperationCallback {\n  // document updates\n  (identifier: StableDocumentIdentifier, notificationType: CacheOperation): void;\n}\n```",
      "itemtype": "method",
      "name": "subscribe",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableDocumentIdentifier | StableRecordIdentifier | 'resource' | 'document'"
        },
        {
          "name": "callback",
          "description": "",
          "type": "NotificationCallback | ResourceOperationCallback | DocumentOperationCallback"
        }
      ],
      "return": {
        "description": "an opaque token to be used with unsubscribe",
        "type": "UnsubscribeToken"
      },
      "class": "NotificationManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/notification-manager.ts",
      "line": 179,
      "description": "remove a previous subscription",
      "itemtype": "method",
      "name": "unsubscribe",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "token",
          "description": "",
          "type": "UnsubscribeToken"
        }
      ],
      "class": "NotificationManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/managers/notification-manager.ts",
      "line": 192,
      "description": "Custom Caches and Application Code should not call this method directly.",
      "itemtype": "method",
      "name": "notify",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "value",
          "description": ""
        },
        {
          "name": "key",
          "description": ""
        }
      ],
      "return": {
        "description": "whether a notification was delivered to any subscribers",
        "type": "Boolean"
      },
      "access": "private",
      "tagname": "",
      "class": "NotificationManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/network/request-cache.ts",
      "line": 194,
      "description": "Subscribe to requests for a given resource identity.\n\nThe callback will receive the current state of the request.\n\n```ts\ninterface RequestState {\n  state: 'pending' | 'fulfilled' | 'rejected';\n  type: 'query' | 'mutation';\n  request: Request;\n  response?: { data: unknown };\n}\n```\n\nNote: It should be considered dangerous to use this API for more than simple\nstate derivation or debugging. The `request` and `response` properties are poorly\nspec'd and may change unexpectedly when shifting what Handlers are in use or how\nrequests are issued from the Store.\n\nWe expect to revisit this API in the near future as we continue to refine the\nRequestManager ergonomics, as a simpler but more powerful direct integration\nwith the RequestManager for these purposes is likely to be a better long-term\ndesign.",
      "itemtype": "method",
      "name": "subscribeForRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        },
        {
          "name": "callback",
          "description": "",
          "type": "(state: RequestState) => void"
        }
      ],
      "class": "RequestStateService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/network/request-cache.ts",
      "line": 232,
      "description": "Retrieve all active requests for a given resource identity.",
      "itemtype": "method",
      "name": "getPendingRequestsForRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "an array of request states for any pending requests for the given identifier",
        "type": "RequestState[]"
      },
      "class": "RequestStateService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/network/request-cache.ts",
      "line": 244,
      "description": "Retrieve the last completed request for a given resource identity.",
      "itemtype": "method",
      "name": "getLastRequestForRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "return": {
        "description": "the state of the most recent request for the given identifier",
        "type": "RequestState | null"
      },
      "class": "RequestStateService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/identifier-array.ts",
      "line": 171,
      "description": "The flag to signal a `RecordArray` is currently loading data.\nExample\n```javascript\nlet people = store.peekAll('person');\npeople.isUpdating; // false\npeople.update();\npeople.isUpdating; // true\n```",
      "itemtype": "property",
      "name": "isUpdating",
      "access": "public",
      "tagname": "",
      "type": "Boolean",
      "class": "RecordArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/identifier-array.ts",
      "line": 201,
      "description": "The store that created this record array.",
      "itemtype": "property",
      "name": "store",
      "access": "private",
      "tagname": "",
      "type": "Store",
      "class": "RecordArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/identifier-array.ts",
      "line": 472,
      "description": "Used to get the latest version of all of the records in this array\nfrom the adapter.\n\nExample\n\n```javascript\nlet people = store.peekAll('person');\npeople.isUpdating; // false\n\npeople.update().then(function() {\n  people.isUpdating; // false\n});\n\npeople.isUpdating; // true\n```",
      "itemtype": "method",
      "name": "update",
      "access": "public",
      "tagname": "",
      "class": "RecordArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/identifier-array.ts",
      "line": 527,
      "description": "Saves all of the records in the `RecordArray`.\n\nExample\n\n```javascript\nlet messages = store.peekAll('message');\nmessages.forEach(function(message) {\n  message.hasBeenSeen = true;\n});\nmessages.save();\n```",
      "itemtype": "method",
      "name": "save",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "promise",
        "type": "Promise<IdentifierArray>"
      },
      "class": "RecordArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/many-array.ts",
      "line": 92,
      "description": "The loading state of this array",
      "itemtype": "property",
      "name": "isLoaded",
      "type": "Boolean",
      "access": "public",
      "tagname": "",
      "class": "ManyArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/many-array.ts",
      "line": 100,
      "description": "`true` if the relationship is polymorphic, `false` otherwise.",
      "itemtype": "property",
      "name": "isPolymorphic",
      "type": "Boolean",
      "access": "private",
      "tagname": "",
      "class": "ManyArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/many-array.ts",
      "line": 108,
      "description": "Metadata associated with the request for async hasMany relationships.\n\nExample\n\nGiven that the server returns the following JSON payload when fetching a\nhasMany relationship:\n\n```js\n{\n  \"comments\": [{\n    \"id\": 1,\n    \"comment\": \"This is the first comment\",\n  }, {\n// ...\n  }],\n\n  \"meta\": {\n    \"page\": 1,\n    \"total\": 5\n  }\n}\n```\n\nYou can then access the meta data via the `meta` property:\n\n```js\nlet comments = await post.comments;\nlet meta = comments.meta;\n\n// meta.page => 1\n// meta.total => 5\n```",
      "itemtype": "property",
      "name": "meta",
      "type": "Object | null",
      "access": "public",
      "tagname": "",
      "class": "ManyArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/many-array.ts",
      "line": 146,
      "description": "Retrieve the links for this relationship",
      "itemtype": "property",
      "name": "links",
      "type": "Object | null",
      "access": "public",
      "tagname": "",
      "class": "ManyArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/many-array.ts",
      "line": 386,
      "description": "Reloads all of the records in the manyArray. If the manyArray\nholds a relationship that was originally fetched using a links url\nEmberData will revisit the original links url to repopulate the\nrelationship.\n\nIf the ManyArray holds the result of a `store.query()` reload will\nre-run the original query.\n\nExample\n\n```javascript\nlet user = store.peekRecord('user', '1')\nawait login(user);\n\nlet permissions = await user.permissions;\nawait permissions.reload();\n```",
      "itemtype": "method",
      "name": "reload",
      "access": "public",
      "tagname": "",
      "class": "ManyArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/many-array.ts",
      "line": 417,
      "description": "Saves all of the records in the `ManyArray`.\n\nNote: this API can only be used in legacy mode with a configured Adapter.\n\nExample\n\n```javascript\nconst { content: { data: inbox } } = await store.request(findRecord({ type: 'inbox', id: '1' }));\n\nlet messages = await inbox.messages;\nmessages.forEach((message) => {\n  message.isRead = true;\n});\nmessages.save();\n```",
      "itemtype": "method",
      "name": "save",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "promise",
        "type": "PromiseArray"
      },
      "class": "ManyArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/record-arrays/many-array.ts",
      "line": 439,
      "description": "Create a child record within the owner",
      "itemtype": "method",
      "name": "createRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "hash",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "record",
        "type": "Model"
      },
      "class": "ManyArray",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 34,
      "description": "The links object for this document, if any\n\ne.g.\n\n```\n{\n  self: '/articles?page[number]=3',\n}\n```",
      "itemtype": "property",
      "name": "links",
      "type": "{object|undefined} - a links object",
      "access": "public",
      "tagname": "",
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 50,
      "description": "The primary data for this document, if any.\n\nIf this document has no primary data (e.g. because it is an error document)\nthis property will be `undefined`.\n\nFor collections this will be an array of record instances,\nfor single resource requests it will be a single record instance or null.",
      "itemtype": "property",
      "name": "data",
      "access": "public",
      "tagname": "",
      "type": "{object|Array<object>|null|undefined} - a data object",
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 65,
      "description": "The errors returned by the API for this request, if any",
      "itemtype": "property",
      "name": "errors",
      "access": "public",
      "tagname": "",
      "type": "{object|undefined} - an errors object",
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 74,
      "description": "The meta object for this document, if any",
      "itemtype": "property",
      "name": "meta",
      "access": "public",
      "tagname": "",
      "type": "{object|undefined} - a meta object",
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 83,
      "description": "The identifier associated with this document, if any",
      "itemtype": "property",
      "name": "identifier",
      "access": "public",
      "tagname": "",
      "type": "{StableDocumentIdentifier|null}",
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 146,
      "description": "Fetches the related link for this document, returning a promise that resolves\nwith the document when the request completes. If no related link is present,\nwill fallback to the self link if present",
      "itemtype": "method",
      "name": "fetch",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "Promise<Document>"
      },
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 163,
      "description": "Fetches the next link for this document, returning a promise that resolves\nwith the new document when the request completes, or null  if there is no\nnext link.",
      "itemtype": "method",
      "name": "next",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "Promise<Document | null>"
      },
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 177,
      "description": "Fetches the prev link for this document, returning a promise that resolves\nwith the new document when the request completes, or null if there is no\nprev link.",
      "itemtype": "method",
      "name": "prev",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "Promise<Document | null>"
      },
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 191,
      "description": "Fetches the first link for this document, returning a promise that resolves\nwith the new document when the request completes, or null if there is no\nfirst link.",
      "itemtype": "method",
      "name": "first",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "Promise<Document | null>"
      },
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 205,
      "description": "Fetches the last link for this document, returning a promise that resolves\nwith the new document when the request completes, or null if there is no\nlast link.",
      "itemtype": "method",
      "name": "last",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "Promise<Document | null>"
      },
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/document.ts",
      "line": 219,
      "description": "Implemented for `JSON.stringify` support.\n\nReturns the JSON representation of the document wrapper.\n\nThis is a shallow serialization, it does not deeply serialize\nthe document's contents, leaving that to the individual record\ninstances to determine how to do, if at all.",
      "itemtype": "method",
      "name": "toJSON",
      "access": "public",
      "tagname": "",
      "return": {
        "description": ""
      },
      "class": "ReactiveDocument",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 360,
      "description": "This hook enables an app to supply a SchemaService\nfor use when information about a resource's schema needs\nto be queried.\n\nThis method will only be called once to instantiate the singleton\nservice, which can then be accessed via `store.schema`.\n\nFor Example, to use the default SchemaService for SchemaRecord\n\n```ts\nimport { SchemaService } from '@warp-drive/schema-record';\n\nclass extends Store {\n  createSchemaService() {\n    return new SchemaService();\n  }\n}\n```\n\nOr to use the SchemaService for @ember-data/model\n\n```ts\nimport { buildSchema } from '@ember-data/model/hooks';\n\nclass extends Store {\n  createSchemaService() {\n    return buildSchema(this);\n  }\n}\n```\n\nIf you wish to chain services, you must either\ninstantiate each schema source directly or super to retrieve\nan existing service. For convenience, when migrating from\n`@ember-data/model` to `@warp-drive/schema-record` a\nSchemaService is provided that handles this transition\nfor you:\n\n```ts\nimport { DelegatingSchemaService } from '@ember-data/model/migration-support';\nimport { SchemaService } from '@warp-drive/schema-record';\n\nclass extends Store {\n  createSchemaService() {\n    const schema = new SchemaService();\n    return new DelegatingSchemaService(this, schema);\n  }\n}\n```\n\nWhen using the DelegateSchemaService, the schema will first\nbe sourced from directly registered schemas, then will fallback\nto sourcing a schema from available models if no schema is found.",
      "itemtype": "method",
      "name": "createSchemaService (hook)",
      "return": {
        "description": "",
        "type": "SchemaService"
      },
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 421,
      "description": "DEPRECATED - Use the property `store.schema` instead.\n\nProvides access to the SchemaDefinitionService instance\nfor this Store instance.\n\nThe SchemaDefinitionService can be used to query for\ninformation about the schema of a resource.",
      "itemtype": "method",
      "name": "getSchemaDefinitionService",
      "deprecated": true,
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 436,
      "description": "DEPRECATED - Use `createSchemaService` instead.\n\nAllows an app to register a custom SchemaService\nfor use when information about a resource's schema needs\nto be queried.\n\nThis method can only be called more than once, but only one schema\ndefinition service may exist. Therefore if you wish to chain services\nyou must lookup the existing service and close over it with the new\nservice by accessing `store.schema` prior to registration.\n\nFor Example:\n\n```ts\nimport Store from '@ember-data/store';\n\nclass SchemaDelegator {\n  constructor(schema) {\n    this._schema = schema;\n  }\n\n  hasResource(resource: { type: string }): boolean {\n    if (AbstractSchemas.has(resource.type)) {\n      return true;\n    }\n    return this._schema.hasResource(resource);\n  }\n\n  attributesDefinitionFor(identifier: RecordIdentifier | { type: string }): AttributesSchema {\n    return this._schema.attributesDefinitionFor(identifier);\n  }\n\n  relationshipsDefinitionFor(identifier: RecordIdentifier | { type: string }): RelationshipsSchema {\n    const schema = AbstractSchemas.get(identifier.type);\n    return schema || this._schema.relationshipsDefinitionFor(identifier);\n  }\n}\n\nexport default class extends Store {\n  constructor(...args) {\n    super(...args);\n\n    const schema = this.createSchemaService();\n    this.registerSchemaDefinitionService(new SchemaDelegator(schema));\n  }\n}\n```",
      "itemtype": "method",
      "name": "registerSchemaDefinitionService",
      "params": [
        {
          "name": "schema",
          "description": "",
          "type": "SchemaService"
        }
      ],
      "deprecated": true,
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 492,
      "description": "DEPRECATED - Use `createSchemaService` instead.\n\nAllows an app to register a custom SchemaService\nfor use when information about a resource's schema needs\nto be queried.\n\nThis method can only be called more than once, but only one schema\ndefinition service may exist. Therefore if you wish to chain services\nyou must lookup the existing service and close over it with the new\nservice by accessing `store.schema` prior to registration.\n\nFor Example:\n\n```ts\nimport Store from '@ember-data/store';\n\nclass SchemaDelegator {\n  constructor(schema) {\n    this._schema = schema;\n  }\n\n  hasResource(resource: { type: string }): boolean {\n    if (AbstractSchemas.has(resource.type)) {\n      return true;\n    }\n    return this._schema.hasResource(resource);\n  }\n\n  attributesDefinitionFor(identifier: RecordIdentifier | { type: string }): AttributesSchema {\n    return this._schema.attributesDefinitionFor(identifier);\n  }\n\n  relationshipsDefinitionFor(identifier: RecordIdentifier | { type: string }): RelationshipsSchema {\n    const schema = AbstractSchemas.get(identifier.type);\n    return schema || this._schema.relationshipsDefinitionFor(identifier);\n  }\n}\n\nexport default class extends Store {\n  constructor(...args) {\n    super(...args);\n\n    const schema = this.schema;\n    this.registerSchema(new SchemaDelegator(schema));\n  }\n}\n```",
      "itemtype": "method",
      "name": "registerSchema",
      "params": [
        {
          "name": "schema",
          "description": "",
          "type": "SchemaService"
        }
      ],
      "deprecated": true,
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 552,
      "description": "Provides access to the NotificationManager associated\nwith this Store instance.\n\nThe NotificationManager can be used to subscribe to\nchanges to the cache.",
      "itemtype": "property",
      "name": "notifications",
      "type": "NotificationManager",
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 564,
      "description": "Provides access to the SchemaService instance\nfor this Store instance.\n\nThe SchemaService can be used to query for\ninformation about the schema of a resource.",
      "itemtype": "property",
      "name": "schema",
      "type": "SchemaService",
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 582,
      "description": "Provides access to the IdentifierCache instance\nfor this store.\n\nThe IdentifierCache can be used to generate or\nretrieve a stable unique identifier for any resource.",
      "itemtype": "property",
      "name": "identifierCache",
      "type": "IdentifierCache",
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 593,
      "description": "Provides access to the requestManager instance associated\nwith this Store instance.\n\nWhen using `ember-data` this property is automatically\nset to an instance of `RequestManager`. When not using `ember-data`\nyou must configure this property yourself, either by declaring\nit as a service or by initializing it.\n\n```ts\nimport Store, { CacheHandler } from '@ember-data/store';\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\n\nclass extends Store {\n  requestManager = new RequestManager()\n   .use([Fetch])\n   .useCache(CacheHandler);\n}\n```",
      "access": "public",
      "tagname": "",
      "itemtype": "property",
      "name": "requestManager",
      "type": "RequestManager",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 619,
      "description": "A Property which an App may set to provide a CachePolicy\nto control when a cached request becomes stale.\n\nNote, when defined, these methods will only be invoked if a\ncache key exists for the request, either because the request\ncontains `cacheOptions.key` or because the [IdentifierCache](/ember-data/release/classes/IdentifierCache)\nwas able to generate a key for the request using the configured\n[generation method](/ember-data/release/functions/@ember-data%2Fstore/setIdentifierGenerationMethod).\n\n`isSoftExpired` will only be invoked if `isHardExpired` returns `false`.\n\n```ts\nstore.lifetimes = {\n  // make the request and ignore the current cache state\n  isHardExpired(identifier: StableDocumentIdentifier): boolean {\n    return false;\n  }\n\n  // make the request in the background if true, return cache state\n  isSoftExpired(identifier: StableDocumentIdentifier): boolean {\n    return false;\n  }\n}\n```",
      "access": "public",
      "tagname": "",
      "itemtype": "property",
      "name": "lifetimes",
      "type": "CachePolicy|undefined",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 688,
      "itemtype": "method",
      "name": "init",
      "access": "private",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 768,
      "description": "Retrieve the RequestStateService instance\nassociated with this Store.\n\nThis can be used to query the status of requests\nthat have been initiated for a given identifier.",
      "itemtype": "method",
      "name": "getRequestStateService",
      "return": {
        "description": "",
        "type": "RequestStateService"
      },
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 800,
      "description": "Issue a request via the configured RequestManager,\ninserting the response into the cache and handing\nback a Future which resolves to a ResponseDocument\n\n## Cache Keys\n\nOnly GET requests with a url or requests with an explicit\ncache key (`cacheOptions.key`) will have the request result\nand document cached.\n\nThe cache key used is `requestConfig.cacheOptions.key`\nif present, falling back to `requestConfig.url`.\n\nParams are not serialized as part of the cache-key, so\neither ensure they are already in the url or utilize\n`requestConfig.cacheOptions.key`. For queries issued\nvia the `POST` method `requestConfig.cacheOptions.key`\nMUST be supplied for the document to be cached.\n\n## Requesting Without a Cache Key\n\nResource data within the request is always updated in the cache,\nregardless of whether a cache key is present for the request.\n\n## Fulfilling From Cache\n\nWhen a cache-key is determined, the request may fulfill\nfrom cache provided the cache is not stale.\n\nCache staleness is determined by the configured CachePolicy\nwith priority given to the `cacheOptions.reload` and\n`cacheOptions.backgroundReload` on the request if present.\n\nIf the cache data has soft expired or the request asks for a background\nreload, the request will fulfill from cache if possible and\nmake a non-blocking request in the background to update the cache.\n\nIf the cache data has hard expired or the request asks for a reload,\nthe request will not fulfill from cache and will make a blocking\nrequest to update the cache.\n\n## The Response\n\nThe primary difference between `requestManager.request` and `store.request`\nis that `store.request` will attempt to hydrate the response content into\na response Document containing RecordInstances.",
      "itemtype": "method",
      "name": "request",
      "params": [
        {
          "name": "requestConfig",
          "description": "",
          "type": "StoreRequestInput"
        }
      ],
      "return": {
        "description": "",
        "type": "Future"
      },
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 917,
      "description": "A hook which an app or addon may implement. Called when\nthe Store is attempting to create a Record Instance for\na resource.\n\nThis hook can be used to select or instantiate any desired\nmechanism of presenting cache data to the ui for access\nmutation, and interaction.",
      "itemtype": "method",
      "name": "instantiateRecord (hook)",
      "params": [
        {
          "name": "identifier",
          "description": ""
        },
        {
          "name": "createRecordArgs",
          "description": ""
        },
        {
          "name": "recordDataFor",
          "description": "deprecated use this.cache"
        },
        {
          "name": "notificationManager",
          "description": "deprecated use this.notifications"
        }
      ],
      "return": {
        "description": "A record instance"
      },
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 935,
      "description": "A hook which an app or addon may implement. Called when\nthe Store is destroying a Record Instance. This hook should\nbe used to teardown any custom record instances instantiated\nwith `instantiateRecord`.",
      "itemtype": "method",
      "name": "teardownRecord (hook)",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "record",
          "description": ""
        }
      ],
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 946,
      "description": "Returns the schema for a particular resource type (modelName).\n\nWhen used with Model from @ember-data/model the return is the model class,\nbut this is not guaranteed.\n\nIf looking to query attribute or relationship information it is\nrecommended to use `getSchemaDefinitionService` instead. This method\nshould be considered legacy and exists primarily to continue to support\nAdapter/Serializer APIs which expect it's return value in their method\nsignatures.\n\nThe class of a model might be useful if you want to get a list of all the\nrelationship names of the model, see\n[`relationshipNames`](/ember-data/release/classes/Model?anchor=relationshipNames)\nfor example.",
      "itemtype": "method",
      "name": "modelFor",
      "access": "public",
      "tagname": "",
      "deprecated": true,
      "params": [
        {
          "name": "type",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "ModelSchema"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 983,
      "description": "Create a new record in the current store. The properties passed\nto this method are set on the newly created record.\n\nTo create a new instance of a `Post`:\n\n```js\nstore.createRecord('post', {\n  title: 'Ember is awesome!'\n});\n```\n\nTo create a new instance of a `Post` that has a relationship with a `User` record:\n\n```js\nlet user = this.store.peekRecord('user', '1');\nstore.createRecord('post', {\n  title: 'Ember is awesome!',\n  user: user\n});\n```",
      "itemtype": "method",
      "name": "createRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "type",
          "description": "the name of the resource",
          "type": "String"
        },
        {
          "name": "inputProperties",
          "description": "a hash of properties to set on the\n  newly created record.",
          "type": "Object"
        }
      ],
      "return": {
        "description": "record",
        "type": "Model"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 1075,
      "description": "For symmetry, a record can be deleted via the store.\n\nExample\n\n```javascript\nlet post = store.createRecord('post', {\n  title: 'Ember is awesome!'\n});\n\nstore.deleteRecord(post);\n```",
      "itemtype": "method",
      "name": "deleteRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "record",
          "description": "",
          "type": "Unknown"
        }
      ],
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 1109,
      "description": "For symmetry, a record can be unloaded via the store.\nThis will cause the record to be destroyed and freed up for garbage collection.\n\nExample\n\n```javascript\nconst { content: { data: post } } = await store.request(findRecord({ type: 'post', id: '1' }));\nstore.unloadRecord(post);\n```",
      "itemtype": "method",
      "name": "unloadRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "record",
          "description": "",
          "type": "Model"
        }
      ],
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 1134,
      "description": "This method returns a record for a given identifier or type and id combination.\n\nThe `findRecord` method will always resolve its promise with the same\nobject for a given identifier or type and `id`.\n\nThe `findRecord` method will always return a **promise** that will be\nresolved with the record.\n\n**Example 1**\n\n```app/routes/post.js\nexport default class PostRoute extends Route {\n  model({ post_id }) {\n    return this.store.findRecord('post', post_id);\n  }\n}\n```\n\n**Example 2**\n\n`findRecord` can be called with a single identifier argument instead of the combination\nof `type` (modelName) and `id` as separate arguments. You may recognize this combo as\nthe typical pairing from [JSON:API](https://jsonapi.org/format/#document-resource-object-identification)\n\n```app/routes/post.js\nexport default class PostRoute extends Route {\n  model({ post_id: id }) {\n    return this.store.findRecord({ type: 'post', id });\n  }\n}\n```\n\n**Example 3**\n\nIf you have previously received an lid via an Identifier for this record, and the record\nhas already been assigned an id, you can find the record again using just the lid.\n\n```app/routes/post.js\nstore.findRecord({ lid });\n```\n\nIf the record is not yet available, the store will ask the adapter's `findRecord`\nmethod to retrieve and supply the necessary data. If the record is already present\nin the store, it depends on the reload behavior _when_ the returned promise\nresolves.\n\n### Preloading\n\nYou can optionally `preload` specific attributes and relationships that you know of\nby passing them via the passed `options`.\n\nFor example, if your Ember route looks like `/posts/1/comments/2` and your API route\nfor the comment also looks like `/posts/1/comments/2` if you want to fetch the comment\nwithout also fetching the post you can pass in the post to the `findRecord` call:\n\n```app/routes/post-comments.js\nexport default class PostRoute extends Route {\n  model({ post_id, comment_id: id }) {\n    return this.store.findRecord({ type: 'comment', id, { preload: { post: post_id }} });\n  }\n}\n```\n\nIn your adapter you can then access this id without triggering a network request via the\nsnapshot:\n\n```app/adapters/application.js\nexport default class Adapter {\n\n  findRecord(store, schema, id, snapshot) {\n    let type = schema.modelName;\n\n    if (type === 'comment')\n      let postId = snapshot.belongsTo('post', { id: true });\n\n      return fetch(`./posts/${postId}/comments/${id}`)\n        .then(response => response.json())\n    }\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```\n\nThis could also be achieved by supplying the post id to the adapter via the adapterOptions\nproperty on the options hash.\n\n```app/routes/post-comments.js\nexport default class PostRoute extends Route {\n  model({ post_id, comment_id: id }) {\n    return this.store.findRecord({ type: 'comment', id, { adapterOptions: { post: post_id }} });\n  }\n}\n```\n\n```app/adapters/application.js\nexport default class Adapter {\n  findRecord(store, schema, id, snapshot) {\n    let type = schema.modelName;\n\n    if (type === 'comment')\n      let postId = snapshot.adapterOptions.post;\n\n      return fetch(`./posts/${postId}/comments/${id}`)\n        .then(response => response.json())\n    }\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```\n\nIf you have access to the post model you can also pass the model itself to preload:\n\n```javascript\nlet post = await store.findRecord('post', '1');\nlet comment = await store.findRecord('comment', '2', { post: myPostModel });\n```\n\n### Reloading\n\nThe reload behavior is configured either via the passed `options` hash or\nthe result of the adapter's `shouldReloadRecord`.\n\nIf `{ reload: true }` is passed or `adapter.shouldReloadRecord` evaluates\nto `true`, then the returned promise resolves once the adapter returns\ndata, regardless if the requested record is already in the store:\n\n```js\nstore.push({\n  data: {\n    id: 1,\n    type: 'post',\n    revision: 1\n  }\n});\n\n// adapter#findRecord resolves with\n// [\n//   {\n//     id: 1,\n//     type: 'post',\n//     revision: 2\n//   }\n// ]\nstore.findRecord('post', '1', { reload: true }).then(function(post) {\n  post.revision; // 2\n});\n```\n\nIf no reload is indicated via the above mentioned ways, then the promise\nimmediately resolves with the cached version in the store.\n\n### Background Reloading\n\nOptionally, if `adapter.shouldBackgroundReloadRecord` evaluates to `true`,\nthen a background reload is started, which updates the records' data, once\nit is available:\n\n```js\n// app/adapters/post.js\nimport ApplicationAdapter from \"./application\";\n\nexport default class PostAdapter extends ApplicationAdapter {\n  shouldReloadRecord(store, snapshot) {\n    return false;\n  },\n\n  shouldBackgroundReloadRecord(store, snapshot) {\n    return true;\n  }\n});\n\n// ...\n\nstore.push({\n  data: {\n    id: 1,\n    type: 'post',\n    revision: 1\n  }\n});\n\nlet blogPost = store.findRecord('post', '1').then(function(post) {\n  post.revision; // 1\n});\n\n// later, once adapter#findRecord resolved with\n// [\n//   {\n//     id: 1,\n//     type: 'post',\n//     revision: 2\n//   }\n// ]\n\nblogPost.revision; // 2\n```\n\nIf you would like to force or prevent background reloading, you can set a\nboolean value for `backgroundReload` in the options object for\n`findRecord`.\n\n```app/routes/post/edit.js\nexport default class PostEditRoute extends Route {\n  model(params) {\n    return this.store.findRecord('post', params.post_id, { backgroundReload: false });\n  }\n}\n```\n\nIf you pass an object on the `adapterOptions` property of the options\nargument it will be passed to your adapter via the snapshot\n\n```app/routes/post/edit.js\nexport default class PostEditRoute extends Route {\n  model(params) {\n    return this.store.findRecord('post', params.post_id, {\n      adapterOptions: { subscribe: false }\n    });\n  }\n}\n```\n\n```app/adapters/post.js\nimport MyCustomAdapter from './custom-adapter';\n\nexport default class PostAdapter extends MyCustomAdapter {\n  findRecord(store, type, id, snapshot) {\n    if (snapshot.adapterOptions.subscribe) {\n      // ...\n    }\n    // ...\n  }\n}\n```\n\nSee [peekRecord](../methods/peekRecord?anchor=peekRecord) to get the cached version of a record.\n\n### Retrieving Related Model Records\n\nIf you use an adapter such as Ember's default\n[`JSONAPIAdapter`](/ember-data/release/classes/JSONAPIAdapter)\nthat supports the [JSON API specification](http://jsonapi.org/) and if your server\nendpoint supports the use of an\n['include' query parameter](http://jsonapi.org/format/#fetching-includes),\nyou can use `findRecord()` or `findAll()` to automatically retrieve additional records related to\nthe one you request by supplying an `include` parameter in the `options` object.\n\nFor example, given a `post` model that has a `hasMany` relationship with a `comment`\nmodel, when we retrieve a specific post we can have the server also return that post's\ncomments in the same request:\n\n```app/routes/post.js\nexport default class PostRoute extends Route {\n  model(params) {\n    return this.store.findRecord('post', params.post_id, { include: ['comments'] });\n  }\n}\n```\n\n```app/adapters/application.js\nexport default class Adapter {\n  findRecord(store, schema, id, snapshot) {\n    let type = schema.modelName;\n\n    if (type === 'post')\n      let includes = snapshot.adapterOptions.include;\n\n      return fetch(`./posts/${postId}?include=${includes}`)\n        .then(response => response.json())\n    }\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```\n\nIn this case, the post's comments would then be available in your template as\n`model.comments`.\n\nMultiple relationships can be requested using an `include` parameter consisting of a\nlist of relationship names, while nested relationships can be specified\nusing a dot-separated sequence of relationship names. So to request both the post's\ncomments and the authors of those comments the request would look like this:\n\n```app/routes/post.js\nexport default class PostRoute extends Route {\n  model(params) {\n    return this.store.findRecord('post', params.post_id, { include: ['comments','comments.author'] });\n  }\n}\n```\n\n### Retrieving Specific Fields by Type\n\nIf your server endpoint supports the use of a ['fields' query parameter](https://jsonapi.org/format/#fetching-sparse-fieldsets),\nyou can use pass those fields through to your server.  At this point in time, this requires a few manual steps on your part.\n\n1. Implement `buildQuery` in your adapter.\n\n```app/adapters/application.js\nbuildQuery(snapshot) {\n  let query = super.buildQuery(...arguments);\n\n  let { fields } = snapshot.adapterOptions;\n\n  if (fields) {\n    query.fields = fields;\n  }\n\n  return query;\n}\n```\n\n2. Then pass through the applicable fields to your `findRecord` request.\n\nGiven a `post` model with attributes body, title, publishDate and meta, you can retrieve a filtered list of attributes.\n\n```app/routes/post.js\nexport default class extends Route {\n  model(params) {\n    return this.store.findRecord('post', params.post_id, { adapterOptions: { fields: { post: 'body,title' } });\n  }\n}\n```\n\nMoreover, you can filter attributes on related models as well. If a `post` has a `belongsTo` relationship to a user,\njust include the relationship key and attributes.\n\n```app/routes/post.js\nexport default class extends Route {\n  model(params) {\n    return this.store.findRecord('post', params.post_id, { adapterOptions: { fields: { post: 'body,title', user: 'name,email' } });\n  }\n}\n```",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "findRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "type",
          "description": "- either a string representing the name of the resource or a ResourceIdentifier object containing both the type (a string) and the id (a string) for the record or an lid (a string) of an existing record",
          "type": "String|object"
        },
        {
          "name": "id",
          "description": "- optional object with options for the request only if the first param is a ResourceIdentifier, else the string id of the record to be retrieved",
          "type": "(String|Integer|Object)"
        },
        {
          "name": "options",
          "description": "- if the first param is a string this will be the optional options for the request. See examples for available options.",
          "type": "Object",
          "optional": true
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 1545,
      "description": "Get the reference for the specified record.\n\nExample\n\n```javascript\nlet userRef = store.getReference('user', '1');\n\n// check if the user is loaded\nlet isLoaded = userRef.value() !== null;\n\n// get the record of the reference (null if not yet available)\nlet user = userRef.value();\n\n// get the identifier of the reference\nif (userRef.remoteType() === 'id') {\nlet id = userRef.id();\n}\n\n// load user (via store.find)\nuserRef.load().then(...)\n\n// or trigger a reload\nuserRef.reload().then(...)\n\n// provide data for reference\nuserRef.push({ id: 1, username: '@user' }).then(function(user) {\n  userRef.value() === user;\n});\n```",
      "itemtype": "method",
      "name": "getReference",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "resource",
          "description": "- modelName (string) or Identifier (object)",
          "type": "String|object"
        },
        {
          "name": "id",
          "description": "",
          "type": "String|Integer"
        }
      ],
      "since": "2.5.0",
      "return": {
        "description": "",
        "type": "RecordReference"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 1608,
      "description": "Get a record by a given type and ID without triggering a fetch.\n\nThis method will synchronously return the record if it is available in the store,\notherwise it will return `null`. A record is available if it has been fetched earlier, or\npushed manually into the store.\n\nSee [findRecord](../methods/findRecord?anchor=findRecord) if you would like to request this record from the backend.\n\n_Note: This is a synchronous method and does not return a promise._\n\n**Example 1**\n\n```js\nlet post = store.peekRecord('post', '1');\n\npost.id; // '1'\n```\n\n`peekRecord` can be called with a single identifier argument instead of the combination\nof `type` (modelName) and `id` as separate arguments. You may recognize this combo as\nthe typical pairing from [JSON:API](https://jsonapi.org/format/#document-resource-object-identification)\n\n**Example 2**\n\n```js\nlet post = store.peekRecord({ type: 'post', id });\npost.id; // '1'\n```\n\nIf you have previously received an lid from an Identifier for this record, you can lookup the record again using\njust the lid.\n\n**Example 3**\n\n```js\nlet post = store.peekRecord({ lid });\npost.id; // '1'\n```",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "peekRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "modelName",
          "description": "- either a string representing the modelName or a ResourceIdentifier object containing both the type (a string) and the id (a string) for the record or an lid (a string) of an existing record",
          "type": "String|object"
        },
        {
          "name": "id",
          "description": "- optional only if the first param is a ResourceIdentifier, else the string id of the record to be retrieved.",
          "type": "String|Integer"
        }
      ],
      "return": {
        "description": "record",
        "type": "Model|null"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 1690,
      "description": "This method delegates a query to the adapter. This is the one place where\nadapter-level semantics are exposed to the application.\n\nEach time this method is called a new request is made through the adapter.\n\nExposing queries this way seems preferable to creating an abstract query\nlanguage for all server-side queries, and then require all adapters to\nimplement them.\n\n---\n\nIf you do something like this:\n\n```javascript\nstore.query('person', { page: 1 });\n```\n\nThe request made to the server will look something like this:\n\n```\nGET \"/api/v1/person?page=1\"\n```\n\n---\n\nIf you do something like this:\n\n```javascript\nstore.query('person', { ids: ['1', '2', '3'] });\n```\n\nThe request made to the server will look something like this:\n\n```\nGET \"/api/v1/person?ids%5B%5D=1&ids%5B%5D=2&ids%5B%5D=3\"\ndecoded: \"/api/v1/person?ids[]=1&ids[]=2&ids[]=3\"\n```\n\nThis method returns a promise, which is resolved with a\n[`Collection`](/ember-data/release/classes/Collection)\nonce the server returns.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "query",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "type",
          "description": "the name of the resource",
          "type": "String"
        },
        {
          "name": "query",
          "description": "a query to be used by the adapter",
          "type": "Object"
        },
        {
          "name": "options",
          "description": "optional, may include `adapterOptions` hash which will be passed to adapter.query",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 1767,
      "description": "This method makes a request for one record, where the `id` is not known\nbeforehand (if the `id` is known, use [`findRecord`](../methods/findRecord?anchor=findRecord)\ninstead).\n\nThis method can be used when it is certain that the server will return a\nsingle object for the primary data.\n\nEach time this method is called a new request is made through the adapter.\n\nLet's assume our API provides an endpoint for the currently logged in user\nvia:\n\n```\n// GET /api/current_user\n{\n  user: {\n    id: 1234,\n    username: 'admin'\n  }\n}\n```\n\nSince the specific `id` of the `user` is not known beforehand, we can use\n`queryRecord` to get the user:\n\n```javascript\nstore.queryRecord('user', {}).then(function(user) {\n  let username = user.username;\n  // do thing\n});\n```\n\nThe request is made through the adapters' `queryRecord`:\n\n```app/adapters/user.js\nimport Adapter from '@ember-data/adapter';\nimport $ from 'jquery';\n\nexport default class UserAdapter extends Adapter {\n  queryRecord(modelName, query) {\n    return $.getJSON('/api/current_user');\n  }\n}\n```\n\nNote: the primary use case for `store.queryRecord` is when a single record\nis queried and the `id` is not known beforehand. In all other cases\n`store.query` and using the first item of the array is likely the preferred\nway:\n\n```\n// GET /users?username=unique\n{\n  data: [{\n    id: 1234,\n    type: 'user',\n    attributes: {\n      username: \"unique\"\n    }\n  }]\n}\n```\n\n```javascript\nstore.query('user', { username: 'unique' }).then(function(users) {\n  return users.firstObject;\n}).then(function(user) {\n  let id = user.id;\n});\n```\n\nThis method returns a promise, which resolves with the found record.\n\nIf the adapter returns no data for the primary data of the payload, then\n`queryRecord` resolves with `null`:\n\n```\n// GET /users?username=unique\n{\n  data: null\n}\n```\n\n```javascript\nstore.queryRecord('user', { username: 'unique' }).then(function(user) {\n   // user is null\n});\n```",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "queryRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "type",
          "description": "",
          "type": "String"
        },
        {
          "name": "query",
          "description": "an opaque query to be used by the adapter",
          "type": "Object"
        },
        {
          "name": "options",
          "description": "optional, may include `adapterOptions` hash which will be passed to adapter.queryRecord",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise which resolves with the found record or `null`",
        "type": "Promise"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 1895,
      "description": "`findAll` asks the adapter's `findAll` method to find the records for the\ngiven type, and returns a promise which will resolve with all records of\nthis type present in the store, even if the adapter only returns a subset\nof them.\n\n```app/routes/authors.js\nexport default class AuthorsRoute extends Route {\n  model(params) {\n    return this.store.findAll('author');\n  }\n}\n```\n\n_When_ the returned promise resolves depends on the reload behavior,\nconfigured via the passed `options` hash and the result of the adapter's\n`shouldReloadAll` method.\n\n### Reloading\n\nIf `{ reload: true }` is passed or `adapter.shouldReloadAll` evaluates to\n`true`, then the returned promise resolves once the adapter returns data,\nregardless if there are already records in the store:\n\n```js\nstore.push({\n  data: {\n    id: 'first',\n    type: 'author'\n  }\n});\n\n// adapter#findAll resolves with\n// [\n//   {\n//     id: 'second',\n//     type: 'author'\n//   }\n// ]\nstore.findAll('author', { reload: true }).then(function(authors) {\n  authors.getEach('id'); // ['first', 'second']\n});\n```\n\nIf no reload is indicated via the above mentioned ways, then the promise\nimmediately resolves with all the records currently loaded in the store.\n\n### Background Reloading\n\nOptionally, if `adapter.shouldBackgroundReloadAll` evaluates to `true`,\nthen a background reload is started. Once this resolves, the array with\nwhich the promise resolves, is updated automatically so it contains all the\nrecords in the store:\n\n```app/adapters/application.js\nimport Adapter from '@ember-data/adapter';\n\nexport default class ApplicationAdapter extends Adapter {\n  shouldReloadAll(store, snapshotsArray) {\n    return false;\n  },\n\n  shouldBackgroundReloadAll(store, snapshotsArray) {\n    return true;\n  }\n});\n\n// ...\n\nstore.push({\n  data: {\n    id: 'first',\n    type: 'author'\n  }\n});\n\nlet allAuthors;\nstore.findAll('author').then(function(authors) {\n  authors.getEach('id'); // ['first']\n\n  allAuthors = authors;\n});\n\n// later, once adapter#findAll resolved with\n// [\n//   {\n//     id: 'second',\n//     type: 'author'\n//   }\n// ]\n\nallAuthors.getEach('id'); // ['first', 'second']\n```\n\nIf you would like to force or prevent background reloading, you can set a\nboolean value for `backgroundReload` in the options object for\n`findAll`.\n\n```app/routes/post/edit.js\nexport default class PostEditRoute extends Route {\n  model() {\n    return this.store.findAll('post', { backgroundReload: false });\n  }\n}\n```\n\nIf you pass an object on the `adapterOptions` property of the options\nargument it will be passed to you adapter via the `snapshotRecordArray`\n\n```app/routes/posts.js\nexport default class PostsRoute extends Route {\n  model(params) {\n    return this.store.findAll('post', {\n      adapterOptions: { subscribe: false }\n    });\n  }\n}\n```\n\n```app/adapters/post.js\nimport MyCustomAdapter from './custom-adapter';\n\nexport default class UserAdapter extends MyCustomAdapter {\n  findAll(store, type, sinceToken, snapshotRecordArray) {\n    if (snapshotRecordArray.adapterOptions.subscribe) {\n      // ...\n    }\n    // ...\n  }\n}\n```\n\nSee [peekAll](../methods/peekAll?anchor=peekAll) to get an array of current records in the\nstore, without waiting until a reload is finished.\n\n### Retrieving Related Model Records\n\nIf you use an adapter such as Ember's default\n[`JSONAPIAdapter`](/ember-data/release/classes/JSONAPIAdapter)\nthat supports the [JSON API specification](http://jsonapi.org/) and if your server\nendpoint supports the use of an\n['include' query parameter](http://jsonapi.org/format/#fetching-includes),\nyou can use `findAll()` to automatically retrieve additional records related to\nthose requested by supplying an `include` parameter in the `options` object.\n\nFor example, given a `post` model that has a `hasMany` relationship with a `comment`\nmodel, when we retrieve all of the post records we can have the server also return\nall of the posts' comments in the same request:\n\n```app/routes/posts.js\nexport default class PostsRoute extends Route {\n  model() {\n    return this.store.findAll('post', { include: ['comments'] });\n  }\n}\n```\nMultiple relationships can be requested using an `include` parameter consisting of a\nlist or relationship names, while nested relationships can be specified\nusing a dot-separated sequence of relationship names. So to request both the posts'\ncomments and the authors of those comments the request would look like this:\n\n```app/routes/posts.js\nexport default class PostsRoute extends Route {\n  model() {\n    return this.store.findAll('post', { include: ['comments','comments.author'] });\n  }\n}\n```\n\nSee [query](../methods/query?anchor=query) to only get a subset of records from the server.",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "findAll",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "type",
          "description": "the name of the resource",
          "type": "String"
        },
        {
          "name": "options",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "promise",
        "type": "Promise"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 2097,
      "description": "This method returns a filtered array that contains all of the\nknown records for a given type in the store.\n\nNote that because it's just a filter, the result will contain any\nlocally created records of the type, however, it will not make a\nrequest to the backend to retrieve additional records. If you\nwould like to request all the records from the backend please use\n[store.findAll](../methods/findAll?anchor=findAll).\n\nAlso note that multiple calls to `peekAll` for a given type will always\nreturn the same `RecordArray`.\n\nExample\n\n```javascript\nlet localPosts = store.peekAll('post');\n```",
      "since": "1.13.0",
      "itemtype": "method",
      "name": "peekAll",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "type",
          "description": "the name of the resource",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "RecordArray"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 2137,
      "description": "This method unloads all records in the store.\nIt schedules unloading to happen during the next run loop.\n\nOptionally you can pass a type which unload all records for a given type.\n\n```javascript\nstore.unloadAll();\nstore.unloadAll('post');\n```",
      "itemtype": "method",
      "name": "unloadAll",
      "params": [
        {
          "name": "type",
          "description": "the name of the resource",
          "type": "String"
        }
      ],
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 2178,
      "description": "Push some data for a given type into the store.\n\nThis method expects normalized [JSON API](http://jsonapi.org/) document. This means you have to follow [JSON API specification](http://jsonapi.org/format/) with few minor adjustments:\n- record's `type` should always be in singular, dasherized form\n- members (properties) should be camelCased\n\n[Your primary data should be wrapped inside `data` property](http://jsonapi.org/format/#document-top-level):\n\n```js\nstore.push({\n  data: {\n    // primary data for single record of type `Person`\n    id: '1',\n    type: 'person',\n    attributes: {\n      firstName: 'Daniel',\n      lastName: 'Kmak'\n    }\n  }\n});\n```\n\n[Demo.](http://ember-twiddle.com/fb99f18cd3b4d3e2a4c7)\n\n`data` property can also hold an array (of records):\n\n```js\nstore.push({\n  data: [\n    // an array of records\n    {\n      id: '1',\n      type: 'person',\n      attributes: {\n        firstName: 'Daniel',\n        lastName: 'Kmak'\n      }\n    },\n    {\n      id: '2',\n      type: 'person',\n      attributes: {\n        firstName: 'Tom',\n        lastName: 'Dale'\n      }\n    }\n  ]\n});\n```\n\n[Demo.](http://ember-twiddle.com/69cdbeaa3702159dc355)\n\nThere are some typical properties for `JSONAPI` payload:\n* `id` - mandatory, unique record's key\n* `type` - mandatory string which matches `model`'s dasherized name in singular form\n* `attributes` - object which holds data for record attributes - `attr`'s declared in model\n* `relationships` - object which must contain any of the following properties under each relationships' respective key (example path is `relationships.achievements.data`):\n  - [`links`](http://jsonapi.org/format/#document-links)\n  - [`data`](http://jsonapi.org/format/#document-resource-object-linkage) - place for primary data\n  - [`meta`](http://jsonapi.org/format/#document-meta) - object which contains meta-information about relationship\n\nFor this model:\n\n```app/models/person.js\nimport Model, { attr, hasMany } from '@ember-data/model';\n\nexport default class PersonRoute extends Route {\n  @attr('string') firstName;\n  @attr('string') lastName;\n\n  @hasMany('person') children;\n}\n```\n\nTo represent the children as IDs:\n\n```js\n{\n  data: {\n    id: '1',\n    type: 'person',\n    attributes: {\n      firstName: 'Tom',\n      lastName: 'Dale'\n    },\n    relationships: {\n      children: {\n        data: [\n          {\n            id: '2',\n            type: 'person'\n          },\n          {\n            id: '3',\n            type: 'person'\n          },\n          {\n            id: '4',\n            type: 'person'\n          }\n        ]\n      }\n    }\n  }\n}\n```\n\n[Demo.](http://ember-twiddle.com/343e1735e034091f5bde)\n\nTo represent the children relationship as a URL:\n\n```js\n{\n  data: {\n    id: '1',\n    type: 'person',\n    attributes: {\n      firstName: 'Tom',\n      lastName: 'Dale'\n    },\n    relationships: {\n      children: {\n        links: {\n          related: '/people/1/children'\n        }\n      }\n    }\n  }\n}\n```\n\nIf you're streaming data or implementing an adapter, make sure\nthat you have converted the incoming data into this form. The\nstore's [normalize](../methods/normalize?anchor=normalize) method is a convenience\nhelper for converting a json payload into the form Ember Data\nexpects.\n\n```js\nstore.push(store.normalize('person', data));\n```\n\nThis method can be used both to push in brand new\nrecords, as well as to update existing records.",
      "itemtype": "method",
      "name": "push",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "data",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "the record(s) that was created or\n  updated."
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 2351,
      "description": "Push some data in the form of a json-api document into the store,\nwithout creating materialized records.",
      "itemtype": "method",
      "name": "_push",
      "access": "private",
      "tagname": "",
      "params": [
        {
          "name": "jsonApiDoc",
          "description": "",
          "type": "Object"
        }
      ],
      "return": {
        "description": "identifiers for the primary records that had data loaded",
        "type": "StableRecordIdentifier|Array<StableRecordIdentifier>|null"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 2381,
      "description": "Trigger a save for a Record.\n\nReturns a promise resolving with the same record when the save is complete.",
      "itemtype": "method",
      "name": "saveRecord",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "record",
          "description": "",
          "type": "Unknown"
        },
        {
          "name": "options",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Promise<record>"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 2437,
      "description": "Instantiation hook allowing applications or addons to configure the store\nto utilize a custom Cache implementation.\n\nThis hook should not be called directly by consuming applications or libraries.\nUse `Store.cache` to access the Cache instance.",
      "itemtype": "method",
      "name": "createCache (hook)",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "storeWrapper",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Cache"
      },
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-private/store-service.ts",
      "line": 2450,
      "description": "Returns the cache instance associated to this Store, instantiates the Cache\nif necessary via `Store.createCache`",
      "itemtype": "property",
      "name": "cache",
      "type": "Cache",
      "access": "public",
      "tagname": "",
      "class": "Store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/cache-capabilities-manager.ts",
      "line": 24,
      "description": "Provides access to the IdentifierCache instance\nfor this Store instance.\n\nThe IdentifierCache can be used to peek, generate or\nretrieve a stable unique identifier for any resource.",
      "itemtype": "property",
      "name": "identifierCache",
      "type": "IdentifierCache",
      "access": "public",
      "tagname": "",
      "class": "CacheCapabilitiesManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/cache-capabilities-manager.ts",
      "line": 36,
      "description": "DEPRECATED - use the schema property\n\nProvides access to the SchemaService instance\nfor this Store instance.\n\nThe SchemaService can be used to query for\ninformation about the schema of a resource.",
      "itemtype": "method",
      "name": "getSchemaDefinitionService",
      "deprecated": true,
      "access": "public",
      "tagname": "",
      "class": "CacheCapabilitiesManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/cache-capabilities-manager.ts",
      "line": 51,
      "description": "Provides access to the SchemaService instance\nfor this Store instance.\n\nThe SchemaService can be used to query for\ninformation about the schema of a resource.",
      "itemtype": "property",
      "name": "schema",
      "access": "public",
      "tagname": "",
      "class": "CacheCapabilitiesManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/cache-capabilities-manager.ts",
      "line": 63,
      "description": "Update the `id` for the record corresponding to the identifier\nThis operation can only be done for records whose `id` is `null`.",
      "itemtype": "method",
      "name": "setRecordId",
      "params": [
        {
          "name": "identifier;",
          "description": "",
          "type": "StableRecordIdentifier"
        },
        {
          "name": "id;",
          "description": "",
          "type": "String"
        }
      ],
      "access": "public",
      "tagname": "",
      "class": "CacheCapabilitiesManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/cache-capabilities-manager.ts",
      "line": 74,
      "description": "Signal to the store that the specified record may be considered fully\nremoved from the cache. Generally this means that not only does no\ndata exist for the identified resource, no known relationships still\npoint to it either.",
      "itemtype": "method",
      "name": "disconnectRecord",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        }
      ],
      "access": "public",
      "tagname": "",
      "class": "CacheCapabilitiesManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/cache-capabilities-manager.ts",
      "line": 86,
      "description": "Use this method to determine if the Store has an instantiated record associated\nwith an identifier.",
      "itemtype": "method",
      "name": "hasRecord",
      "params": [
        {
          "name": "identifier",
          "description": ""
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "access": "public",
      "tagname": "",
      "class": "CacheCapabilitiesManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/cache-capabilities-manager.ts",
      "line": 97,
      "description": "Notify subscribers of the NotificationManager that cache state has changed.\n\n`attributes` and `relationships` do not require a key, but if one is specified it\nis assumed to be the name of the attribute or relationship that has been updated.\n\nNo other namespaces currently expect the `key` argument.",
      "itemtype": "method",
      "name": "notifyChange",
      "params": [
        {
          "name": "identifier",
          "description": "",
          "type": "StableRecordIdentifier"
        },
        {
          "name": "namespace",
          "description": "",
          "type": "'attributes' | 'relationships' | 'identity' | 'errors' | 'meta' | 'state'"
        },
        {
          "name": "key",
          "description": "",
          "type": "String|undefined"
        }
      ],
      "access": "public",
      "tagname": "",
      "class": "CacheCapabilitiesManager",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/identifier.ts",
      "line": 8,
      "description": "Configures how unique identifier lid strings are generated by @ember-data/store.\n\nThis configuration MUST occur prior to the store instance being created.\n\nTakes a method which can expect to receive various data as its first argument\nand the name of a bucket as its second argument.\n\nCurrently there are two buckets, 'record' and 'document'.\n\n### Resource (`Record`) Identity\n\nIf the bucket is `record` the method must return a unique (to at-least\nthe given bucket) string identifier for the given data as a string to be\nused as the `lid` of an `Identifier` token.\n\nThis method will only be called by either `getOrCreateRecordIdentifier` or\n`createIdentifierForNewRecord` when an identifier for the supplied data\nis not already known via `lid` or `type + id` combo and one needs to be\ngenerated or retrieved from a proprietary cache.\n\n`data` will be the same data argument provided to `getOrCreateRecordIdentifier`\nand in the `createIdentifierForNewRecord` case will be an object with\nonly `type` as a key.\n\n```ts\nimport { setIdentifierGenerationMethod } from '@ember-data/store';\n\nexport function initialize(applicationInstance) {\n  // note how `count` here is now scoped to the application instance\n  // for our generation method by being inside the closure provided\n  // by the initialize function\n  let count = 0;\n\n  setIdentifierGenerationMethod((resource, bucket) => {\n    return resource.lid || `my-key-${count++}`;\n  });\n}\n\nexport default {\n  name: 'configure-ember-data-identifiers',\n  initialize\n};\n```\n\n### Document Identity\n\nIf the bucket is `document` the method will receive the associated\nimmutable `request` passed to `store.request` as its first argument\nand should return a unique string for the given request if the document\nshould be cached, and `null` if it should not be cached.\n\nNote, the request result will still be passed to the cache via `Cache.put`,\nbut caches should take this as a signal that the document should not itself\nbe cached, while its contents may still be used to update other cache state.\n\nThe presence of `cacheOptions.key` on the request will take precedence\nfor the document cache key, and this method will not be called if it is\npresent.\n\nThe default method implementation for this bucket is to return `null`\nfor all requests whose method is not `GET`, and to return the `url` for\nthose where it is.\n\nThis means that queries via `POST` MUST provide `cacheOptions.key` or\nimplement this hook.\n\n‚ö†Ô∏è Caution: Requests that do not have a `method` assigned are assumed to be `GET`",
      "itemtype": "method",
      "name": "setIdentifierGenerationMethod",
      "params": [
        {
          "name": "method",
          "description": ""
        }
      ],
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/identifier.ts",
      "line": 89,
      "description": "Configure a callback for when the identifier cache encounters new resource\ndata for an existing resource.\n\nThis configuration MUST occur prior to the store instance being created.\n\n```js\nimport { setIdentifierUpdateMethod } from '@ember-data/store';\n```\n\nTakes a method which can expect to receive an existing `Identifier` alongside\nsome new data to consider as a second argument. This is an opportunity\nfor secondary lookup tables and caches associated with the identifier\nto be amended.\n\nThis method is called everytime `updateRecordIdentifier` is called and\n with the same arguments. It provides the opportunity to update secondary\n lookup tables for existing identifiers.\n\nIt will always be called after an identifier created with `createIdentifierForNewRecord`\n has been committed, or after an update to the `record` a `RecordIdentifier`\n is assigned to has been committed. Committed here meaning that the server\n has acknowledged the update (for instance after a call to `.save()`)\n\nIf `id` has not previously existed, it will be assigned to the `Identifier`\n prior to this `UpdateMethod` being called; however, calls to the parent method\n `updateRecordIdentifier` that attempt to change the `id` or calling update\n without providing an `id` when one is missing will throw an error.",
      "itemtype": "method",
      "name": "setIdentifierUpdateMethod",
      "params": [
        {
          "name": "method",
          "description": ""
        }
      ],
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/identifier.ts",
      "line": 130,
      "description": "Configure a callback for when the identifier cache is going to release an identifier.\n\nThis configuration MUST occur prior to the store instance being created.\n\n```js\nimport { setIdentifierForgetMethod } from '@ember-data/store';\n```\n\nTakes method which can expect to receive an existing `Identifier` that should be eliminated\nfrom any secondary lookup tables or caches that the user has populated for it.",
      "itemtype": "method",
      "name": "setIdentifierForgetMethod",
      "params": [
        {
          "name": "method",
          "description": ""
        }
      ],
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/identifier.ts",
      "line": 150,
      "description": "Configure a callback for when the identifier cache is being torn down.\n\nThis configuration MUST occur prior to the store instance being created.\n\n```js\nimport { setIdentifierResetMethod } from '@ember-data/store';\n```\n\nTakes a method which can expect to be called when the parent application is destroyed.\n\nIf you have properly used a WeakMap to encapsulate the state of your customization\nto the application instance, you may not need to implement the `resetMethod`.",
      "itemtype": "method",
      "name": "setIdentifierResetMethod",
      "params": [
        {
          "name": "method",
          "description": ""
        }
      ],
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/identifier.ts",
      "line": 172,
      "description": "Configure a callback for when the identifier cache is generating a new\nStableRecordIdentifier for a resource.\n\nThis method controls the `type` and `id` that will be assigned to the\n`StableRecordIdentifier` that is created.\n\nThis configuration MUST occur prior to the store instance being created.\n\n```js\nimport { setKeyInfoForResource } from '@ember-data/store';\n```",
      "itemtype": "method",
      "name": "setKeyInfoForResource",
      "params": [
        {
          "name": "method",
          "description": ""
        }
      ],
      "access": "public",
      "tagname": "",
      "static": 1,
      "class": "@ember-data/store",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 76,
      "description": "DEPRECATED - use `hasResource` instead\n\nQueries whether the SchemaService recognizes `type` as a resource type",
      "itemtype": "method",
      "name": "doesTypeExist",
      "access": "public",
      "tagname": "",
      "deprecated": true,
      "params": [
        {
          "name": "type",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 89,
      "description": "Queries whether the SchemaService recognizes `type` as a resource type",
      "itemtype": "method",
      "name": "hasResource",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "}",
          "description": "resource",
          "type": "StableRecordIdentifier| type: string"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 99,
      "description": "Queries whether the SchemaService recognizes `type` as a resource trait",
      "itemtype": "method",
      "name": "hasTrait",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "type",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 109,
      "description": "Queries whether the given resource has the given trait",
      "itemtype": "method",
      "name": "resourceHasTrait",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "}",
          "description": "resource",
          "type": "StableRecordIdentifier| type: string"
        },
        {
          "name": "trait",
          "description": "",
          "type": "String"
        }
      ],
      "return": {
        "description": "",
        "type": "Boolean"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 120,
      "description": "Queries for the fields of a given resource type or resource identity.\n\nShould error if the resource type is not recognized.",
      "itemtype": "method",
      "name": "fields",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "}",
          "description": "resource",
          "type": "StableRecordIdentifier| type: string"
        }
      ],
      "return": {
        "description": "",
        "type": "Map<string, FieldSchema>"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 132,
      "description": "Returns the transformation registered with the name provided\nby `field.type`. Validates that the field is a valid transformable.",
      "itemtype": "method",
      "name": "transformation",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "}",
          "description": "field",
          "type": "TransformableField| type: string"
        }
      ],
      "return": {
        "description": "",
        "type": "Transformation"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 143,
      "description": "Returns the hash function registered with the name provided\nby `field.type`. Validates that the field is a valid HashField.",
      "itemtype": "method",
      "name": "hashFn",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "}",
          "description": "field",
          "type": "HashField| type: string"
        }
      ],
      "return": {
        "description": "",
        "type": "HashFn"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 154,
      "description": "Returns the derivation registered with the name provided\nby `field.type`. Validates that the field is a valid DerivedField.",
      "itemtype": "method",
      "name": "derivation",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "}",
          "description": "field",
          "type": "DerivedField| type: string"
        }
      ],
      "return": {
        "description": "",
        "type": "Derivation"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 165,
      "description": "Returns the schema for the provided resource type.",
      "itemtype": "method",
      "name": "resource",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "}",
          "description": "resource",
          "type": "StableRecordIdentifier| type: string"
        }
      ],
      "return": {
        "description": "",
        "type": "ResourceSchema"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 175,
      "description": "Enables registration of multiple ResourceSchemas at once.\n\nThis can be useful for either pre-loading schema information\nor for registering schema information delivered by API calls\nor other sources just-in-time.",
      "itemtype": "method",
      "name": "registerResources",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "schemas",
          "description": ""
        }
      ],
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 188,
      "description": "Enables registration of a single ResourceSchema.\n\nThis can be useful for either pre-loading schema information\nor for registering schema information delivered by API calls\nor other sources just-in-time.",
      "itemtype": "method",
      "name": "registerResource",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "schema",
          "description": "",
          "type": "ResourceSchema"
        }
      ],
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 201,
      "description": "Enables registration of a transformation.\n\nThe transformation can later be retrieved by the name\nattached to it's `[Type]` property.",
      "itemtype": "method",
      "name": "registerTransformations",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "transform",
          "description": "",
          "type": "Transformation"
        }
      ],
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 213,
      "description": "Enables registration of a derivation.\n\nThe derivation can later be retrieved by the name\nattached to it's `[Type]` property.",
      "itemtype": "method",
      "name": "registerDerivations",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "derivation",
          "description": "",
          "type": "Derivation"
        }
      ],
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 225,
      "description": "Enables registration of a hashing function\n\nThe hashing function can later be retrieved by the name\nattached to it's `[Type]` property.",
      "itemtype": "method",
      "name": "registerHashFn",
      "access": "public",
      "tagname": "",
      "params": [
        {
          "name": "hashfn",
          "description": "",
          "type": "HashFn"
        }
      ],
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 237,
      "description": "DEPRECATED - use `fields` instead\n\nReturns definitions for all properties of the specified resource\nthat are considered \"attributes\". Generally these are properties\nthat are not related to book-keeping state on the client and do\nnot represent a linkage to another resource.\n\nThe return value should be a dictionary of key:value pairs\nwhere the `key` is the attribute or property's name and `value`\nis an object with at least the property `name` which should also\nmatch `key`.\n\nOptionally, this object may also specify `type`, which should\nbe a string reference to a `transform`, and `options` which\nshould be dictionary in which any key:value pairs are permissable.\n\nFor instance, when using `@ember-data/model`, the following attribute\ndefinition:\n\n```ts\nclass extends Model {\n  @attr('string', { defaultValue: 'hello' }) greeting;\n  @attr('date') birthday;\n  @attr firstName;\n}\n```\n\nWould be returned as:\n\n```js\n{\n  greeting: { name: 'greeting', type: 'string', options: { defaultValue: 'hello' } },\n  birthday: { name: 'birthday', type: 'date' },\n  firstName: { name: 'firstName' }\n}\n```",
      "itemtype": "method",
      "name": "attributesDefinitionFor",
      "access": "public",
      "tagname": "",
      "deprecated": true,
      "params": [
        {
          "name": "}",
          "description": "identifier",
          "type": "RecordIdentifier| type: string"
        }
      ],
      "return": {
        "description": "",
        "type": "AttributesSchema"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 283,
      "description": "DEPRECATED - use `fields` instead\n\nReturns definitions for all properties of the specified resource\nthat are considered \"relationships\". Generally these are properties\nthat represent a linkage to another resource.\n\nThe return value should be a dictionary of key:value pairs\nwhere the `key` is the relationship or property's name and `value`\nis an object with at least the following properties:\n\n- `name` which should also match the `key` used in the dictionary.\n- `kind` which should be either `belongsTo` or `hasMany`\n- `type` which should be the related resource's string \"type\"\n- `options` which should be a dictionary allowing any key but with\n   at least the below keys present.\n\n- `options.async` a boolean representing whether data for this relationship is\n     typically loaded on-demand.\n- `options.inverse` a string or null representing the field name / key of the\n      corresponding relationship on the inverse resource.\n\nAdditionally the following options properties are optional. See [Polymorphic Relationships](https://rfcs.emberjs.com/id/0793-polymporphic-relations-without-inheritance)\n\n- `options.polymorphic` a boolean representing whether multiple resource types\n   can be used to satisfy this relationship.\n- `options.as` a string representing the abstract type that the concrete side of\n   a relationship must specify when fulfilling a polymorphic inverse.\n\nFor example, the following Model using @ember-data/model would generate this relationships\ndefinition by default:\n\n```js\nclass User extends Model {\n  @belongsTo('user', { async: false, inverse: null }) bestFriend;\n  @hasMany('user', { async: true, inverse: 'friends' }) friends;\n  @hasMany('pet', { async: false, polymorphic: true, inverse: 'owner' }) pets;\n}\n```\n\nWhich would be returned as\n\n```js\n{\n  bestFriend: {\n    name: 'bestFriend',\n    kind: 'belongsTo',\n    type: 'user',\n    options: {\n      async: false,\n      inverse: null\n    }\n  },\n  friends: {\n    name: 'friends',\n    kind: 'hasMany',\n    type: 'user',\n    options: {\n      async: true,\n      inverse: 'friends'\n    }\n  },\n  pets: {\n    name: 'pets',\n    kind: 'hasMany',\n    type: 'pet',\n    options: {\n      async: false,\n      polymorphic: true,\n      inverse: 'owner'\n    }\n  },\n}\n```",
      "itemtype": "method",
      "name": "relationshipsDefinitionFor",
      "access": "public",
      "tagname": "",
      "deprecated": true,
      "params": [
        {
          "name": "}",
          "description": "identifier",
          "type": "RecordIdentifier| type: string"
        }
      ],
      "return": {
        "description": "",
        "type": "RelationshipsSchema"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/store/src/-types/q/schema-service.ts",
      "line": 366,
      "description": "Returns all known resource types",
      "itemtype": "method",
      "name": "resourceTypes",
      "access": "public",
      "tagname": "",
      "return": {
        "description": "",
        "type": "String[]"
      },
      "class": "<Interface> SchemaService",
      "module": "@ember-data/store"
    },
    {
      "file": "../packages/tracking/src/-private.ts",
      "line": 216,
      "description": "Run `method` without subscribing to any tracked properties\ncontrolled by EmberData.\n\nThis should rarely be used except by libraries that really\nknow what they are doing. It is most useful for wrapping\ncertain kinds of fetch/query logic from within a `Resource`\n`hook` or other similar pattern.",
      "itemtype": "method",
      "name": "untracked",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "method",
          "description": ""
        }
      ],
      "return": {
        "description": "result of invoking method"
      },
      "class": "@ember-data/tracking",
      "module": "@ember-data/tracking"
    },
    {
      "file": "../packages/tracking/src/-private.ts",
      "line": 239,
      "description": "Run the method, subscribing to any tracked properties\nmanaged by EmberData that were accessed or written during\nthe method's execution as per-normal but while allowing\ninterleaving of reads and writes.\n\nThis is useful when for instance you want to perform\na mutation based on existing state that must be read first.",
      "itemtype": "method",
      "name": "transact",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "method",
          "description": ""
        }
      ],
      "return": {
        "description": "result of invoking method"
      },
      "class": "@ember-data/tracking",
      "module": "@ember-data/tracking"
    },
    {
      "file": "../packages/tracking/src/-private.ts",
      "line": 262,
      "description": "A helpful utility for creating a new function that\nalways runs in a transaction. E.G. this \"memoizes\"\ncalling `transact(fn)`, currying args as necessary.",
      "itemtype": "method",
      "name": "memoTransact",
      "access": "public",
      "tagname": "",
      "static": 1,
      "params": [
        {
          "name": "method",
          "description": ""
        }
      ],
      "return": {
        "description": "a function that will invoke method in a transaction with any provided args and return its result"
      },
      "class": "@ember-data/tracking",
      "module": "@ember-data/tracking"
    }
  ],
  "warnings": [
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:66"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:100"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:124"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:141"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:160"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:203"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:350"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:367"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:381"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:405"
    },
    {
      "message": "unknown tag: until",
      "line": " ../packages/build-config/src/deprecation-versions.ts:438"
    },
    {
      "message": "unknown tag: recommended",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:34"
    },
    {
      "message": "unknown tag: ignored",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:52"
    },
    {
      "message": "param name missing: {StableDocumentIdentifier}",
      "line": " ../packages/core-types/src/cache.ts:178"
    },
    {
      "message": "param name missing: {StableDocumentIdentifier}",
      "line": " ../packages/json-api/src/-private/cache.ts:609"
    },
    {
      "message": "param name missing: {StableDocumentIdentifier}",
      "line": " ../packages/store/src/-private/managers/cache-manager.ts:141"
    },
    {
      "message": "replacing incorrect tag: function with method",
      "line": " ../packages/store/src/-private/managers/record-array-manager.ts:26"
    },
    {
      "message": "replacing incorrect tag: function with method",
      "line": " ../packages/tracking/src/-private.ts:216"
    },
    {
      "message": "replacing incorrect tag: function with method",
      "line": " ../packages/tracking/src/-private.ts:239"
    },
    {
      "message": "Missing item type\nA utility function that returns a promise that resolves\neven when the source promise rejects.",
      "line": " ../packages/adapter/src/-private/utils/continue-on-reject.ts:1"
    },
    {
      "message": "Missing item type\nA private flag to enable logging of the native Map/Set\nconstructor and method calls.\n\nEXTREMELY MALPERFORMANT\n\nLOG_METRIC_COUNTS must also be enabled.",
      "line": " ../packages/build-config/src/debugging.ts:101"
    },
    {
      "message": "Missing item type\nWhether this SchemaObject is Polymorphic.\n\nIf the SchemaObject is polymorphic, `options.type` must also be supplied.",
      "line": " ../packages/core-types/src/schema/fields.ts:529"
    },
    {
      "message": "Missing item type\nIf the SchemaObject is Polymorphic, the key on the raw cache data to use\nas the \"resource-type\" value for the schema-object.\n\nDefaults to \"type\".",
      "line": " ../packages/core-types/src/schema/fields.ts:538"
    },
    {
      "message": "Missing item type\nConfigures how the SchemaArray determines whether\nan object in the cache is the same as an object\npreviously used to instantiate one of the schema-objects\nit contains.\n\nThe default is `'@identity'`.\n\nValid options are:\n\n- `'@identity'` (default) : the cached object's referential identity will be used.\n      This may result in significant instability when resource data is updated from the API\n- `'@index'`              : the cached object's index in the array will be used.\n      This is only a good choice for arrays that rarely if ever change membership\n- `'@hash'`               : will lookup the `@hash` function supplied in the ResourceSchema for\n      The contained schema-object and use the computed result to determine and compare identity.\n- <field-name> (string)   : the name of a field to use as the key, only GenericFields (kind `field`)\n      Are valid field names for this purpose. The cache state without transforms applied will be\n      used when comparing values. The field value should be unique enough to guarantee two schema-objects\n      of the same type will not collide.",
      "line": " ../packages/core-types/src/schema/fields.ts:667"
    },
    {
      "message": "Missing item type\nWhether this SchemaArray is Polymorphic.\n\nIf the SchemaArray is polymorphic, `options.type` must also be supplied.",
      "line": " ../packages/core-types/src/schema/fields.ts:692"
    },
    {
      "message": "Missing item type\nIf the SchemaArray is Polymorphic, the key on the raw cache data to use\nas the \"resource-type\" value for the schema-object.\n\nDefaults to \"type\".",
      "line": " ../packages/core-types/src/schema/fields.ts:701"
    },
    {
      "message": "Missing item type\nWhether the relationship is async\n\nIf true, it is expected that the cache\ndata for this field will contain a link\nthat can be used to fetch the related\nresource when needed.",
      "line": " ../packages/core-types/src/schema/fields.ts:828"
    },
    {
      "message": "Missing item type\nThe name of the inverse field on the\nrelated resource that points back to\nthis field on this resource to form a\nbidirectional relationship.\n\nIf null, the relationship is unidirectional.",
      "line": " ../packages/core-types/src/schema/fields.ts:840"
    },
    {
      "message": "Missing item type\nIf this field is satisfying a polymorphic\nrelationship on another resource, then this\nshould be set to the trait or abstract type\nthat this resource implements.",
      "line": " ../packages/core-types/src/schema/fields.ts:852"
    },
    {
      "message": "Missing item type\nWhether this field is a polymorphic relationship,\nmeaning that it can point to multiple types of\nresources so long as they implement the trait\nor abstract type specified in `type`.",
      "line": " ../packages/core-types/src/schema/fields.ts:862"
    },
    {
      "message": "Missing item type\nOptions for resources are optional. If\nnot present, all options are presumed\nto be falsey",
      "line": " ../packages/core-types/src/schema/fields.ts:913"
    },
    {
      "message": "Missing item type\nWhether the relationship is async\n\nIf true, it is expected that the cache\ndata for this field will contain links\nthat can be used to fetch the related\nresources when needed.\n\nWhen false, it is expected that all related\nresources are loaded together with this resource,\nand that the cache data for this field will\ncontain the full list of pointers.\n\nWhen true, it is expected that the relationship\nis paginated. If the relationship is not paginated,\nthen the cache data for \"page 1\" would contain the\nfull list of pointers, and loading \"page 1\" would\nload all related resources.",
      "line": " ../packages/core-types/src/schema/fields.ts:921"
    },
    {
      "message": "Missing item type\nThe name of the inverse field on the\nrelated resource that points back to\nthis field on this resource to form a\nbidirectional relationship.\n\nIf null, the relationship is unidirectional.",
      "line": " ../packages/core-types/src/schema/fields.ts:944"
    },
    {
      "message": "Missing item type\nIf this field is satisfying a polymorphic\nrelationship on another resource, then this\nshould be set to the trait or abstract type\nthat this resource implements.",
      "line": " ../packages/core-types/src/schema/fields.ts:956"
    },
    {
      "message": "Missing item type\nWhether this field is a polymorphic relationship,\nmeaning that it can point to multiple types of\nresources so long as they implement the trait\nor abstract type specified in `type`.",
      "line": " ../packages/core-types/src/schema/fields.ts:966"
    },
    {
      "message": "Missing item type\nOptions to pass to the transform, if any\n\nMust comply to the specific transform's options\nschema.",
      "line": " ../packages/core-types/src/schema/fields.ts:1019"
    },
    {
      "message": "Missing item type\nOptions for belongsTo are mandatory.",
      "line": " ../packages/core-types/src/schema/fields.ts:1070"
    },
    {
      "message": "Missing item type\nWhether the relationship is async\n\nIf true, it is expected that the cache\ndata for this field will contain a link\nor a pointer that can be used to fetch\nthe related resource when needed.\n\nPointers are highly discouraged.",
      "line": " ../packages/core-types/src/schema/fields.ts:1076"
    },
    {
      "message": "Missing item type\nThe name of the inverse field on the\nrelated resource that points back to\nthis field on this resource to form a\nbidirectional relationship.\n\nIf null, the relationship is unidirectional.",
      "line": " ../packages/core-types/src/schema/fields.ts:1090"
    },
    {
      "message": "Missing item type\nIf this field is satisfying a polymorphic\nrelationship on another resource, then this\nshould be set to the trait or abstract type\nthat this resource implements.",
      "line": " ../packages/core-types/src/schema/fields.ts:1102"
    },
    {
      "message": "Missing item type\nWhether this field is a polymorphic relationship,\nmeaning that it can point to multiple types of\nresources so long as they implement the trait\nor abstract type specified in `type`.",
      "line": " ../packages/core-types/src/schema/fields.ts:1112"
    },
    {
      "message": "Missing item type\nWhether this field should ever make use of the legacy support infra\nfrom @ember-data/model and the LegacyNetworkMiddleware for adapters and serializers.\n\nWhen true, none of the legacy support will be utilized. Sync relationships\nwill be expected to already have all their data. When reloading a sync relationship\nyou would be expected to have a `related link` available from a prior relationship\npayload e.g.\n\n```ts\n{\n  data: {\n    type: 'user',\n    id: '2',\n    attributes: { name: 'Chris' },\n    relationships: {\n      bestFriend: {\n        links: { related: \"/users/1/bestFriend\" },\n        data: { type: 'user', id: '1' },\n      }\n    }\n  },\n  included: [\n    { type: 'user', id: '1', attributes: { name: 'Krystan' } }\n  ]\n}\n```\n\nAsync relationships will be loaded via their link if needed.",
      "line": " ../packages/core-types/src/schema/fields.ts:1122"
    },
    {
      "message": "Missing item type\nWhen omitted, the cache data for this field will\nclear local state of all changes except for the\naddition of records still in the \"new\" state any\ntime the remote data for this field is updated.\n\nWhen set to `false`, the cache data for this field\nwill instead intelligently commit any changes from\nlocal state that are present in the remote data,\nleaving any remaining changes in local state still.",
      "line": " ../packages/core-types/src/schema/fields.ts:1156"
    },
    {
      "message": "Missing item type\nOptions for belongsTo are mandatory.",
      "line": " ../packages/core-types/src/schema/fields.ts:1213"
    },
    {
      "message": "Missing item type\nWhether the relationship is async\n\nMUST be false for PolarisMode + LinksMode",
      "line": " ../packages/core-types/src/schema/fields.ts:1219"
    },
    {
      "message": "Missing item type\nThe name of the inverse field on the\nrelated resource that points back to\nthis field on this resource to form a\nbidirectional relationship.\n\nIf null, the relationship is unidirectional.",
      "line": " ../packages/core-types/src/schema/fields.ts:1228"
    },
    {
      "message": "Missing item type\nIf this field is satisfying a polymorphic\nrelationship on another resource, then this\nshould be set to the trait or abstract type\nthat this resource implements.",
      "line": " ../packages/core-types/src/schema/fields.ts:1240"
    },
    {
      "message": "Missing item type\nWhether this field is a polymorphic relationship,\nmeaning that it can point to multiple types of\nresources so long as they implement the trait\nor abstract type specified in `type`.",
      "line": " ../packages/core-types/src/schema/fields.ts:1250"
    },
    {
      "message": "Missing item type\nWhether this field should ever make use of the legacy support infra\nfrom @ember-data/model and the LegacyNetworkMiddleware for adapters and serializers.\n\nMUST be true for PolarisMode + LinksMode\n\nWhen true, none of the legacy support will be utilized. Sync relationships\nwill be expected to already have all their data. When reloading a sync relationship\nyou would be expected to have a `related link` available from a prior relationship\npayload e.g.\n\n```ts\n{\n  data: {\n    type: 'user',\n    id: '2',\n    attributes: { name: 'Chris' },\n    relationships: {\n      bestFriend: {\n        links: { related: \"/users/1/bestFriend\" },\n        data: { type: 'user', id: '1' },\n      }\n    }\n  },\n  included: [\n    { type: 'user', id: '1', attributes: { name: 'Krystan' } }\n  ]\n}\n```\n\nAsync relationships will be loaded via their link if needed.",
      "line": " ../packages/core-types/src/schema/fields.ts:1260"
    },
    {
      "message": "Missing item type\nWhen omitted, the cache data for this field will\nclear local state of all changes except for the\naddition of records still in the \"new\" state any\ntime the remote data for this field is updated.\n\nWhen set to `false`, the cache data for this field\nwill instead intelligently commit any changes from\nlocal state that are present in the remote data,\nleaving any remaining changes in local state still.\n\nMUST be false for PolarisMode + LinksMode",
      "line": " ../packages/core-types/src/schema/fields.ts:1296"
    },
    {
      "message": "Missing item type\nOptions for hasMany are mandatory.",
      "line": " ../packages/core-types/src/schema/fields.ts:1355"
    },
    {
      "message": "Missing item type\nWhether the relationship is async\n\nIf true, it is expected that the cache\ndata for this field will contain links\nor pointers that can be used to fetch\nthe related resources when needed.\n\nWhen false, it is expected that all related\nresources are loaded together with this resource,\nand that the cache data for this field will\ncontain the full list of pointers.\n\nhasMany relationships do not support pagination.",
      "line": " ../packages/core-types/src/schema/fields.ts:1361"
    },
    {
      "message": "Missing item type\nThe name of the inverse field on the\nrelated resource that points back to\nthis field on this resource to form a\nbidirectional relationship.\n\nIf null, the relationship is unidirectional.",
      "line": " ../packages/core-types/src/schema/fields.ts:1380"
    },
    {
      "message": "Missing item type\nIf this field is satisfying a polymorphic\nrelationship on another resource, then this\nshould be set to the trait or abstract type\nthat this resource implements.",
      "line": " ../packages/core-types/src/schema/fields.ts:1392"
    },
    {
      "message": "Missing item type\nWhether this field is a polymorphic relationship,\nmeaning that it can point to multiple types of\nresources so long as they implement the trait\nor abstract type specified in `type`.",
      "line": " ../packages/core-types/src/schema/fields.ts:1402"
    },
    {
      "message": "Missing item type\nWhether this field should ever make use of the legacy support infra\nfrom @ember-data/model and the LegacyNetworkMiddleware for adapters and serializers.\n\nWhen true, none of the legacy support will be utilized. Sync relationships\nwill be expected to already have all their data. When reloading a sync relationship\nyou would be expected to have a `related link` available from a prior relationship\npayload e.g.\n\n```ts\n{\n  data: {\n    type: 'user',\n    id: '2',\n    attributes: { name: 'Chris' },\n    relationships: {\n      bestFriends: {\n        links: { related: \"/users/1/bestFriends\" },\n        data: [ { type: 'user', id: '1' } ],\n      }\n    }\n  },\n  included: [\n    { type: 'user', id: '1', attributes: { name: 'Krystan' } }\n  ]\n}\n```\n\nAsync relationships will be loaded via their link if needed.",
      "line": " ../packages/core-types/src/schema/fields.ts:1412"
    },
    {
      "message": "Missing item type\nWhen omitted, the cache data for this field will\nclear local state of all changes except for the\naddition of records still in the \"new\" state any\ntime the remote data for this field is updated.\n\nWhen set to `false`, the cache data for this field\nwill instead intelligently commit any changes from\nlocal state that are present in the remote data,\nleaving any remaining changes in local state still.",
      "line": " ../packages/core-types/src/schema/fields.ts:1446"
    },
    {
      "message": "Missing item type\nOptions for hasMany are mandatory.",
      "line": " ../packages/core-types/src/schema/fields.ts:1503"
    },
    {
      "message": "Missing item type\nWhether the relationship is async\n\nMUST be false for PolarisMode + LinksMode\n\nIf true, it is expected that the cache\ndata for this field will contain links\nor pointers that can be used to fetch\nthe related resources when needed.\n\nWhen false, it is expected that all related\nresources are loaded together with this resource,\nand that the cache data for this field will\ncontain the full list of pointers.\n\nhasMany relationships do not support pagination.",
      "line": " ../packages/core-types/src/schema/fields.ts:1509"
    },
    {
      "message": "Missing item type\nThe name of the inverse field on the\nrelated resource that points back to\nthis field on this resource to form a\nbidirectional relationship.\n\nIf null, the relationship is unidirectional.",
      "line": " ../packages/core-types/src/schema/fields.ts:1530"
    },
    {
      "message": "Missing item type\nIf this field is satisfying a polymorphic\nrelationship on another resource, then this\nshould be set to the trait or abstract type\nthat this resource implements.",
      "line": " ../packages/core-types/src/schema/fields.ts:1542"
    },
    {
      "message": "Missing item type\nWhether this field is a polymorphic relationship,\nmeaning that it can point to multiple types of\nresources so long as they implement the trait\nor abstract type specified in `type`.",
      "line": " ../packages/core-types/src/schema/fields.ts:1552"
    },
    {
      "message": "Missing item type\nWhether this field should ever make use of the legacy support infra\nfrom @ember-data/model and the LegacyNetworkMiddleware for adapters and serializers.\n\nMUST be true for PolarisMode + LinksMode\n\nWhen true, none of the legacy support will be utilized. Sync relationships\nwill be expected to already have all their data. When reloading a sync relationship\nyou would be expected to have a `related link` available from a prior relationship\npayload e.g.\n\n```ts\n{\n  data: {\n    type: 'user',\n    id: '2',\n    attributes: { name: 'Chris' },\n    relationships: {\n      bestFriends: {\n        links: { related: \"/users/1/bestFriends\" },\n        data: [ { type: 'user', id: '1' } ],\n      }\n    }\n  },\n  included: [\n    { type: 'user', id: '1', attributes: { name: 'Krystan' } }\n  ]\n}\n```\n\nAsync relationships will be loaded via their link if needed.",
      "line": " ../packages/core-types/src/schema/fields.ts:1562"
    },
    {
      "message": "Missing item type\nWhen omitted, the cache data for this field will\nclear local state of all changes except for the\naddition of records still in the \"new\" state any\ntime the remote data for this field is updated.\n\nWhen set to `false`, the cache data for this field\nwill instead intelligently commit any changes from\nlocal state that are present in the remote data,\nleaving any remaining changes in local state still.\n\nMUST be false for PolarisMode + LinksMode",
      "line": " ../packages/core-types/src/schema/fields.ts:1598"
    },
    {
      "message": "Missing item type\nA type which represents a valid JSON schema\ndefinition for either a PolarisMode or a\nLegacyMode resource.\n\nNote, this is separate from the type returned\nby the SchemaService which provides fields as a Map\ninstead of as an Array.",
      "line": " ../packages/core-types/src/schema/fields.ts:1879"
    },
    {
      "message": "Missing item type\nServes as a reference to a `Resource` but does not contain\nany data itself.\n\nUsed to establish relationship linkages between `Resources` and\nto address data that may not be available synchronously.\n\n[JSON:API Spec](https://jsonapi.org/format/#document-resource-identifier-objects)",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:20"
    },
    {
      "message": "Missing item type\nWhile not officially part of the `JSON:API` spec,\n`ember-data` allows the use of `lid` as a local\nidentifier for a `Resource`.",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:34"
    },
    {
      "message": "Missing item type\nWhile valid in the `JSON:API` spec,\n`ember-data` ignores `meta` on `ResourceIdentifierObjects`",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:52"
    },
    {
      "message": "Missing item type\nServes as a reference to a resource created on the client\nbut not yet persisted.",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:62"
    },
    {
      "message": "Missing item type\nResources newly created on the client _may_\nnot have an `id` available to them prior\nto completion of their first successful `save`.\n\n`id` will be `null` in this case.",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:69"
    },
    {
      "message": "Missing item type\nResources newly created on the client _will always_\nhave an `lid` assigned immediately and available.",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:81"
    },
    {
      "message": "Missing item type\nContains the data for an existing resource in JSON:API format",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:120"
    },
    {
      "message": "Missing item type\nA (RAW) JSON:API Formatted Document.\n\nThese documents should follow the JSON:API spec but do not\nhave the same level of guarantees as their `spec` counterparts.",
      "line": " ../packages/core-types/src/spec/json-api-raw.ts:161"
    },
    {
      "message": "Missing item type\nA hash of changed attributes with the key being the attribute name and the value being an\narray of `[oldValue, newValue]`.",
      "line": " ../packages/core-types/src/cache.ts:16"
    },
    {
      "message": "Missing item type\nAn Identifier specific to a record which may or may not\nbe present in the cache.\n\nThe absence of an `id` DOES NOT indicate that this\nIdentifier is for a new client-created record as it\nmay also indicate that it was generated for a secondary\nindex and the primary `id` index is not yet known.",
      "line": " ../packages/core-types/src/identifier.ts:40"
    },
    {
      "message": "Missing item type\nUsed when an Identifier is known to be the stable version",
      "line": " ../packages/core-types/src/identifier.ts:53"
    },
    {
      "message": "Missing item type\nUsed when a StableRecordIdentifier was not created locally as part\nof a call to store.createRecord\n\nDistinguishing between this Identifier and one for a client created\nrecord that was created with an ID is generally speaking not possible\nat runtime, so anything with an ID typically narrows to this.",
      "line": " ../packages/core-types/src/identifier.ts:62"
    },
    {
      "message": "Missing item type\nUsed when a StableRecordIdentifier was created locally\n(by a call to store.createRecord).\n\nIt is possible in rare circumstances to have a StableRecordIdentifier\nthat is not for a new record but does not have an ID. This would\nhappen if a user intentionally created one for use with a secondary-index\nprior to the record having been fully loaded.",
      "line": " ../packages/core-types/src/identifier.ts:80"
    },
    {
      "message": "Missing item type\nA type utility that extracts the Type if available,\notherwise it returns never.",
      "line": " ../packages/core-types/src/record.ts:37"
    },
    {
      "message": "Missing item type\nA type utility that extracts the Type if available,\notherwise it returns string",
      "line": " ../packages/core-types/src/record.ts:45"
    },
    {
      "message": "Missing item type\nA Utility that extracts either resource types or resource paths from a TypedRecordInstance.\n\nIts limitations are mostly around its intentional non-recursiveness. It presumes that APIs which\nimplement includes will not allow cyclical include paths, and will collapse includes by type.\n\nThis follows closer to the JSON:API fields spec than to the includes spec in nature, but in\npractice it is so impracticle for an API to allow z-algo include paths that this is probably\nreasonable.\n\nWe may need to revisit this in the future, opting to either make this restriction optional or\nto allow for other strategies.\n\nThere's a 90% chance this particular implementation belongs being in the JSON:API package instead\nof core-types, but it's here for now.",
      "line": " ../packages/core-types/src/record.ts:118"
    },
    {
      "message": "Missing item type\nA utility that provides the union of all ResourceName for all potential\nincludes for the given TypedRecordInstance.",
      "line": " ../packages/core-types/src/record.ts:159"
    },
    {
      "message": "Missing item type\nA utility that provides the union type of all valid include paths for the given\nTypedRecordInstance.\n\nCyclical paths are filtered out.",
      "line": " ../packages/core-types/src/record.ts:170"
    },
    {
      "message": "Missing item type\nUse these options to adjust CacheHandler behavior for a request.",
      "line": " ../packages/core-types/src/request.ts:30"
    },
    {
      "message": "Missing item type\nA key that uniquely identifies this request. If not present, the url wil be used\nas the key for any GET request, while all other requests will not be cached.",
      "line": " ../packages/core-types/src/request.ts:36"
    },
    {
      "message": "Missing item type\nIf true, the request will be made even if a cached response is present\nand not expired.",
      "line": " ../packages/core-types/src/request.ts:43"
    },
    {
      "message": "Missing item type\nIf true, and a cached response is present and not expired, the request\nwill be made in the background and the cached response will be returned.",
      "line": " ../packages/core-types/src/request.ts:50"
    },
    {
      "message": "Missing item type\nUseful for metadata around when to invalidate the cache. Typically used\nby strategies that invalidate requests by resource type when a new resource\nof that type has been created. See the CachePolicy implementation\nprovided by `@ember-data/request-utils` for an example.\n\nIt is recommended to only use this for query/queryRecord requests where\nnew records created later would affect the results, though using it for\nfindRecord requests is also supported if desired where it may be useful\nwhen a create may affect the result of a sideloaded relationship.\n\nGenerally it is better to patch the cache directly for relationship updates\nthan to invalidate findRecord requests for one.",
      "line": " ../packages/core-types/src/request.ts:57"
    },
    {
      "message": "Missing item type\nIf true, the request will never be handled by the cache-manager and thus\nwill never resolve from cache nor update the cache.\n\nGenerally this is only used for legacy request that manage resource cache\nupdates in a non-standard way via the LegacyNetworkHandler.",
      "line": " ../packages/core-types/src/request.ts:75"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:184"
    },
    {
      "message": "Missing item type\nJavaScript's native Request class.\n\nEmberData provides our own typings due to incompleteness in the native typings.",
      "line": " ../packages/core-types/src/request.ts:201"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:209"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:213"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:217"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:221"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:225"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:229"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:233"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:237"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:241"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:245"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:249"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:253"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:257"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:261"
    },
    {
      "message": "Missing item type\nExtends JavaScript's native {@link Request} object with additional\nproperties specific to the RequestManager's capabilities.",
      "line": " ../packages/core-types/src/request.ts:272"
    },
    {
      "message": "Missing item type\nIf provided, used instead of the AbortController auto-configured for each request by the RequestManager",
      "line": " ../packages/core-types/src/request.ts:279"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:286"
    },
    {
      "message": "Missing item type\nThe identifiers of the primary resources involved in the request\n(if any). This may be used by handlers to perform transactional\noperations on the store.",
      "line": " ../packages/core-types/src/request.ts:295"
    },
    {
      "message": "Missing item type\ndata that a handler should convert into\nthe query (GET) or body (POST).\n\nNote: It is recommended that builders set query params\nand body directly in most scenarios.",
      "line": " ../packages/core-types/src/request.ts:305"
    },
    {
      "message": "Missing item type\noptions specifically intended for handlers\nto utilize to process the request",
      "line": " ../packages/core-types/src/request.ts:315"
    },
    {
      "message": "Missing item type\nImmutable version of {@link RequestInfo}. This is what is passed to handlers.",
      "line": " ../packages/core-types/src/request.ts:328"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:339"
    },
    {
      "message": "Missing item type",
      "line": " ../packages/core-types/src/request.ts:356"
    },
    {
      "message": "Missing item type\nUpserts the specified logging configuration into the runtime\nconfig.\n\nglobalThis.setWarpDriveLogging({ LOG_CACHE: true } });",
      "line": " ../packages/core-types/src/runtime.ts:29"
    },
    {
      "message": "Missing item type\nSymbol for the name of a resource, transformation\nor derivation.\n\n### With Resources\n\nThis is an optional feature that can be used by\nrecord implementations to provide a typescript\nhint for the type of the resource.\n\nWhen used, EmberData and WarpDrive APIs can\ntake advantage of this to provide better type\nsafety and intellisense.\n\n### With Derivations\n\nRequired for derivations registered with\n`store.registerDerivation(derivation)`.\n\n```ts\nfunction concat(record: object, options: ObjectValue | null, prop: string): string {}\nconcat[Name] = 'concat';\n```\n\n### With Transforms\n\nRequired for new-style transformations registered\nwith `store.registerTransform(transform)`.\n\nFor legacy transforms, if not used,\n`attr<Transform>('name')` will allow any string name.\n`attr('name')` will always allow any string name.\n\nIf used, `attr<Transform>('name')` will enforce\nthat the name is the same as the transform name.",
      "line": " ../packages/core-types/src/symbols.ts:8"
    },
    {
      "message": "Missing item type\nSymbol for the type of a resource.\n\nThis is an optional feature that can be used by\nrecord implementations to provide a typescript\nhint for the type of the resource.\n\nWhen used, EmberData and WarpDrive APIs can\ntake advantage of this to provide better type\nsafety and intellisense.",
      "line": " ../packages/core-types/src/symbols.ts:49"
    },
    {
      "message": "Missing item type\nSymbol for the name of a transform.\n\nThis is an optional feature that can be used by\ntransform implementations to provide a typescript\nhint for the name of the transform.\n\nIf not used, `attr<Transform>('name')` will\nallow any string name. `attr('name')` will always\nallow any string name.\n\nIf used, `attr<Transform>('name')` will enforce\nthat the name is the same as the transform name.",
      "line": " ../packages/core-types/src/symbols.ts:65"
    },
    {
      "message": "Missing item type\nSymbol for use by builders to indicate the return type\ngeneric to use for store.request()",
      "line": " ../packages/core-types/src/symbols.ts:84"
    },
    {
      "message": "Missing item type\nProvides info about the model for debugging purposes\nby grouping the properties into more semantic groups.\n\nMeant to be used by debugging tools such as the Chrome Ember Extension.\n\n- Groups all attributes in \"Attributes\" group.\n- Groups all belongsTo relationships in \"Belongs To\" group.\n- Groups all hasMany relationships in \"Has Many\" group.\n- Groups all flags in \"Flags\" group.\n- Flags relationship CPs as expensive properties.",
      "line": " ../packages/debug/src/data-adapter.ts:121"
    },
    {
      "message": "Missing item type\nThe request to monitor. This should be a `Future` instance returned\nby either the `store.request` or `store.requestManager.request` methods.",
      "line": " ../packages/ember/src/-private/request.gts:65"
    },
    {
      "message": "Missing item type\nA query to use for the request. This should be an object that can be\npassed to `store.request`. Use this in place of `@request` if you would\nlike the component to also initiate the request.",
      "line": " ../packages/ember/src/-private/request.gts:73"
    },
    {
      "message": "Missing item type\nThe store instance to use for making requests. If contexts are available,\nthe component will default to using the `store` on the context.\n\nThis is required if the store is not available via context or should be\ndifferent from the store provided via context.",
      "line": " ../packages/ember/src/-private/request.gts:82"
    },
    {
      "message": "Missing item type\nThe autorefresh behavior for the request. This can be a boolean, or any\ncombination of the following values: `'online'`, `'interval'`, `'invalid'`.\n\n- `'online'`: Refresh the request when the browser comes back online\n- `'interval'`: Refresh the request at a specified interval\n- `'invalid'`: Refresh the request when the store emits an invalidation\n\nIf `true`, this is equivalent to `'online,invalid'`.\n\nDefaults to `false`.",
      "line": " ../packages/ember/src/-private/request.gts:93"
    },
    {
      "message": "Missing item type\nThe number of milliseconds to wait before refreshing the request when the\nbrowser comes back online or the network becomes available.\n\nThis also controls the interval at which the request will be refreshed if\nthe `interval` autorefresh type is enabled.\n\nDefaults to `30_000` (30 seconds).",
      "line": " ../packages/ember/src/-private/request.gts:109"
    },
    {
      "message": "Missing item type\nThe behavior of the request initiated by autorefresh. This can be one of\nthe following values:\n\n- `'refresh'`: Refresh the request in the background\n- `'reload'`: Force a reload of the request\n- `'policy'` (**default**): Let the store's configured CachePolicy decide whether to\n   reload, refresh, or do nothing.\n\nDefaults to `'policy'`.",
      "line": " ../packages/ember/src/-private/request.gts:122"
    },
    {
      "message": "Missing item type\nThe block to render when the component is idle and waiting to be given a request.",
      "line": " ../packages/ember/src/-private/request.gts:138"
    },
    {
      "message": "Missing item type\nThe block to render when the request is loading.",
      "line": " ../packages/ember/src/-private/request.gts:145"
    },
    {
      "message": "Missing item type\nThe block to render when the request was cancelled.",
      "line": " ../packages/ember/src/-private/request.gts:152"
    },
    {
      "message": "Missing item type\nThe block to render when the request failed. If this block is not provided,\nthe error will be rethrown.\n\nThus it is required to provide an error block and proper error handling if\nyou do not want the error to crash the application.",
      "line": " ../packages/ember/src/-private/request.gts:162"
    },
    {
      "message": "Missing item type\nThe block to render when the request succeeded.",
      "line": " ../packages/ember/src/-private/request.gts:176"
    },
    {
      "message": "Missing item type\nThe store instance to use for making requests. If contexts are available, this\nwill be the `store` on the context, else it will be the store service.",
      "line": " ../packages/ember/src/-private/request.gts:404"
    },
    {
      "message": "Missing item type\nWhether the browser reports that the network is online.",
      "line": " ../packages/ember/src/-private/request.gts:412"
    },
    {
      "message": "Missing item type\nWhether the browser reports that the tab is hidden.",
      "line": " ../packages/ember/src/-private/request.gts:419"
    },
    {
      "message": "Missing item type\nWhether the component is currently refreshing the request.",
      "line": " ../packages/ember/src/-private/request.gts:426"
    },
    {
      "message": "Missing item type\nThe most recent blocking request that was made, typically\nthe result of a reload.\n\nThis will never be the original request passed as an arg to\nthe component.",
      "line": " ../packages/ember/src/-private/request.gts:433"
    },
    {
      "message": "Missing item type\nThe most recent request that was made, typically due to either a\nreload or a refresh.\n\nThis will never be the original request passed as an arg to\nthe component.",
      "line": " ../packages/ember/src/-private/request.gts:444"
    },
    {
      "message": "Missing item type\nThe time at which the network was reported as offline.",
      "line": " ../packages/ember/src/-private/request.gts:455"
    },
    {
      "message": "Missing item type\nThe event listener for network status changes,\ncached to use the reference for removal.",
      "line": " ../packages/ember/src/-private/request.gts:466"
    },
    {
      "message": "Missing item type\nThe event listener for visibility status changes,\ncached to use the reference for removal.",
      "line": " ../packages/ember/src/-private/request.gts:474"
    },
    {
      "message": "Missing item type\nThe last request passed as an arg to the component,\ncached for comparison.",
      "line": " ../packages/ember/src/-private/request.gts:482"
    },
    {
      "message": "Missing item type\nThe last query passed as an arg to the component,\ncached for comparison.",
      "line": " ../packages/ember/src/-private/request.gts:490"
    },
    {
      "message": "Missing item type\nInstall the event listeners for network and visibility changes.\nThis is only done in browser environments with a global `window`.",
      "line": " ../packages/ember/src/-private/request.gts:694"
    },
    {
      "message": "Missing item type\nIf the network is online and the tab is visible, either reload or refresh the request\nbased on the component's configuration and the requested update mode.\n\nValid modes are:\n\n- `'reload'`: Force a reload of the request.\n- `'refresh'`: Refresh the request in the background.\n- `'policy'`: Make the request, letting the store's configured CachePolicy decide whether to reload, refresh, or do nothing.\n- `undefined`: Make the request using the component's autorefreshBehavior setting if the autorefreshThreshold has passed.",
      "line": " ../packages/ember/src/-private/request.gts:732"
    },
    {
      "message": "Missing item type\nRetry the request, reloading it from the server.",
      "line": " ../packages/ember/src/-private/request.gts:824"
    },
    {
      "message": "Missing item type\nRefresh the request, updating it in the background.",
      "line": " ../packages/ember/src/-private/request.gts:834"
    },
    {
      "message": "Missing item type\nWhether the localState for this edge is out-of-sync\nwith the remoteState.\n\nif state.hasReceivedData=false we are also\nnot dirty since there is nothing to sync with.",
      "line": " ../packages/graph/src/-private/edges/collection.ts:25"
    },
    {
      "message": "Missing item type\nWhether data for this edge has been accessed at least once\nvia `graph.getData`",
      "line": " ../packages/graph/src/-private/edges/collection.ts:36"
    },
    {
      "message": "Missing item type\nA function which attempts to add a value to the local state of a collection\nrelationship, and returns true if the value was added, or false if it was\nalready present.\n\nIt will not generate a notification, will not update the relationships to dirty,\nand will not update the inverse relationships, making it suitable for use as\nan internal util to perform the just the addition to a specific side of a\nrelationship.",
      "line": " ../packages/graph/src/-private/-diff.ts:428"
    },
    {
      "message": "Missing item type\nThe field name on `this` record",
      "line": " ../packages/graph/src/-private/-edge-definition.ts:110"
    },
    {
      "message": "Missing item type\nThe `type` of the related record",
      "line": " ../packages/graph/src/-private/-edge-definition.ts:116"
    },
    {
      "message": "Missing item type\nThe field name on the opposing record",
      "line": " ../packages/graph/src/-private/-edge-definition.ts:130"
    },
    {
      "message": "Missing item type\nThe `type` of `this` record",
      "line": " ../packages/graph/src/-private/-edge-definition.ts:135"
    },
    {
      "message": "Missing item type\nWhether this relationship points back at the same type.\n\nIf the relationship is polymorphic, this will be true if\nit points back at the same abstract type.",
      "line": " ../packages/graph/src/-private/-edge-definition.ts:164"
    },
    {
      "message": "Missing item type\nIf this is a reflexive relationship, this is true\nif the relationship also points back at the same\nfield.",
      "line": " ../packages/graph/src/-private/-edge-definition.ts:174"
    },
    {
      "message": "Missing item type\nReports issues which violate the JSON:API spec for top-level members.\n\nVersion: 1.1\nSection: 7.1\nLink: https://jsonapi.org/format/#document-top-level",
      "line": " ../packages/json-api/src/-private/validator/1.1/7.1_top-level-document-members.ts:7"
    },
    {
      "message": "Missing item type\nValidates the resource objects in either the `data` or `included` members of\nJSON:API document.\n\nVersion: 1.1\nSection: 7.2\nLink: https://jsonapi.org/format/#document-resource-objects",
      "line": " ../packages/json-api/src/-private/validator/1.1/7.2_resource-objects.ts:16"
    },
    {
      "message": "Missing item type\nValidates the links object in a top-level JSON API document or resource object\n\nVersion: 1.1\n\nSection: 7.1 Top Level\nLink: https://jsonapi.org/format/#document-top-level\n\nSection: 7.2.3 Resource Objects\nLink: https://jsonapi.org/format/#document-resource-object-links\n\nSection: 7.2.2.2 Resource Relationships\nLink: https://jsonapi.org/format/#document-resource-object-relationships\n\nSection: 7.6 Document Links\nLink: https://jsonapi.org/format/#document-links",
      "line": " ../packages/json-api/src/-private/validator/1.1/links.ts:14"
    },
    {
      "message": "Missing item type\ndebugging only",
      "line": " ../packages/json-api/src/-private/cache.ts:102"
    },
    {
      "message": "Missing item type\nThis method is called by `record.save`, and gets passed a\nresolver for the promise that `record.save` returns.\n\nIt schedules saving to happen at the end of the run loop.",
      "line": " ../packages/legacy-compat/src/legacy-network-handler/fetch-manager.ts:82"
    },
    {
      "message": "Missing item type\nThis is a helper method that validates a JSON API top-level document\n\nThe format of a document is described here:\nhttp://jsonapi.org/format/#document-top-level",
      "line": " ../packages/legacy-compat/src/legacy-network-handler/serializer-response.ts:10"
    },
    {
      "message": "Missing item type\nThis method should never be called by user code.",
      "line": " ../packages/model/src/-private/references/has-many.ts:130"
    },
    {
      "message": "Missing item type\nOptions provided to the attr decorator are\nsupplied to the associated transform. Any\nkey-value pair is valid; however, it is highly\nrecommended to only use statically defined values\nthat could be serialized to JSON.\n\nIf no transform is provided, the only valid\noption is `defaultValue`.\n\nExamples:\n\n```ts\nclass User extends Model {\n @attr('string', { defaultValue: 'Anonymous' }) name;\n @attr('date', { defaultValue: () => new Date() }) createdAt;\n @attr({ defaultValue: () => ({}) }) preferences;\n @attr('boolean') hasVerifiedEmail;\n @attr address;\n}\n\n@class NOTATHING\n@typedoc",
      "line": " ../packages/model/src/-private/attr.ts:17"
    },
    {
      "message": "Missing item type\nThe default value for this attribute.\n\nDefault values can be provided as a value or a function that will be\nexecuted to generate the default value.\n\nDefault values *should not* be stateful (object, arrays, etc.) as\nthey will be shared across all instances of the record.",
      "line": " ../packages/model/src/-private/attr.ts:42"
    },
    {
      "message": "Missing item type\nvalue type must match the return type of the deserialize method",
      "line": " ../packages/model/src/-private/attr.ts:129"
    },
    {
      "message": "Missing item type\ndefaultValue type must match the return type of the deserialize method",
      "line": " ../packages/model/src/-private/attr.ts:137"
    },
    {
      "message": "Missing item type\nThe return type of `void` is a lie to appease TypeScript. The actual return type\nis a descriptor, but typescript incorrectly insists that decorator functions return\n`void` or `any`.",
      "line": " ../packages/model/src/-private/attr.ts:181"
    },
    {
      "message": "Missing item type\nHistorically EmberData managed a state machine\nfor each record, the localState for which\nwas reflected onto Model.\n\nThis implements the flags and stateName for backwards compat\nwith the state tree that used to be possible (listed below).\n\nstateName and dirtyType are candidates for deprecation.\n\nroot\n  empty\n    deleted    // hidden from stateName\n    preloaded  // hidden from stateName\n\n  loading\n     empty     // hidden from stateName\n     preloaded // hidden from stateName\n\n  loaded\n    saved\n    updated\n      uncommitted\n      invalid\n      inFlight\n    created\n      uncommitted\n      invalid\n      inFlight\n\n  deleted\n    saved\n      new      // hidden from stateName\n    uncommitted\n    invalid\n    inFlight",
      "line": " ../packages/model/src/-private/record-state.ts:29"
    },
    {
      "message": "Missing item type\nGet the keys of fields that are maybe defined as `belongsTo` relationships\n\n\"Maybe\" because getter/computed fields might be returning values that look\nlike relationships, but are not.",
      "line": " ../packages/model/src/-private/type-utils.ts:12"
    },
    {
      "message": "Missing item type\nGet the keys of fields that are maybe defined as `hasMany` relationships\n\n\"Maybe\" because getter/computed fields might be returning values that look\nlike relationships, but are not.",
      "line": " ../packages/model/src/-private/type-utils.ts:24"
    },
    {
      "message": "Missing item type\nGet the keys of fields that are maybe defined as `attr` fields\n\n\"Maybe\" because getter/computed fields might be returning values that look\nlike attributes, but are not.\n\nThis is computed by excluding the keys that are defined as `belongsTo` or `hasMany`\nas well as the keys on EmberObject and the Model base class",
      "line": " ../packages/model/src/-private/type-utils.ts:35"
    },
    {
      "message": "Missing item type\nGet the keys of fields that are maybe defined as relationships\n\n\"Maybe\" because getter/computed fields might be returning values that look\nlike relationships, but are not.",
      "line": " ../packages/model/src/-private/type-utils.ts:51"
    },
    {
      "message": "Missing item type\nGet the keys of all fields defined on the given subclass of Model\nthat don't exist on EmberObject or Model.",
      "line": " ../packages/model/src/-private/type-utils.ts:64"
    },
    {
      "message": "Missing item type\nReplaces underscores, spaces, or camelCase with dashes.\n\n```js\nimport { dasherize } from '@ember-data/request-utils/string';\n\ndasherize('innerHTML');                // 'inner-html'\ndasherize('action_name');              // 'action-name'\ndasherize('css-class-name');           // 'css-class-name'\ndasherize('my favorite items');        // 'my-favorite-items'\ndasherize('privateDocs/ownerInvoice';  // 'private-docs/owner-invoice'\n```",
      "line": " ../packages/request-utils/src/-private/string/transform.ts:94"
    },
    {
      "message": "Missing item type\nReturns the lowerCamelCase form of a string.\n\n```js\nimport { camelize } from '@ember-data/request-utils/string';\n\ncamelize('innerHTML');                   // 'innerHTML'\ncamelize('action_name');                 // 'actionName'\ncamelize('css-class-name');              // 'cssClassName'\ncamelize('my favorite items');           // 'myFavoriteItems'\ncamelize('My Favorite Items');           // 'myFavoriteItems'\ncamelize('private-docs/owner-invoice');  // 'privateDocs/ownerInvoice'\n```",
      "line": " ../packages/request-utils/src/-private/string/transform.ts:113"
    },
    {
      "message": "Missing item type\nReturns the lower\\_case\\_and\\_underscored form of a string.\n\n```js\nimport { underscore } from '@ember-data/request-utils/string';\n\nunderscore('innerHTML');                 // 'inner_html'\nunderscore('action_name');               // 'action_name'\nunderscore('css-class-name');            // 'css_class_name'\nunderscore('my favorite items');         // 'my_favorite_items'\nunderscore('privateDocs/ownerInvoice');  // 'private_docs/owner_invoice'\n```",
      "line": " ../packages/request-utils/src/-private/string/transform.ts:133"
    },
    {
      "message": "Missing item type\nReturns the Capitalized form of a string\n\n```js\nimport { capitalize } from '@ember-data/request-utils/string';\n\ncapitalize('innerHTML')                 // 'InnerHTML'\ncapitalize('action_name')               // 'Action_name'\ncapitalize('css-class-name')            // 'Css-class-name'\ncapitalize('my favorite items')         // 'My favorite items'\ncapitalize('privateDocs/ownerInvoice'); // 'PrivateDocs/ownerInvoice'\n```",
      "line": " ../packages/request-utils/src/-private/string/transform.ts:152"
    },
    {
      "message": "Missing item type\nA map of pending requests from request.id to their\nassociated CacheHandler promise.\n\nThis queue is managed by the CacheHandler",
      "line": " ../packages/request/src/-private/manager.ts:519"
    },
    {
      "message": "Missing item type\nWraps a derivation in a new function with Derivation signature but that looks\nup the value in the cache before recomputing.",
      "line": " ../packages/schema-record/src/-private/schema.ts:164"
    },
    {
      "message": "Missing item type\nA CacheHandler that adds support for using an EmberData Cache with a RequestManager.\n\nThis handler will only run when a request has supplied a `store` instance. Requests\nissued by the store via `store.request()` will automatically have the `store` instance\nattached to the request.\n\n```ts\nrequestManager.request({\n  store: store,\n  url: '/api/posts',\n  method: 'GET'\n});\n```\n\nWhen this handler elects to handle a request, it will return the raw `StructuredDocument`\nunless the request has `[EnableHydration]` set to `true`. In this case, the handler will\nreturn a `Document` instance that will automatically update the UI when the cache is updated\nin the future and will hydrate any identifiers in the StructuredDocument into Record instances.\n\nWhen issuing a request via the store, [EnableHydration] is automatically set to `true`. This\nmeans that if desired you can issue requests that utilize the cache without needing to also\nutilize Record instances if desired.\n\nSaid differently, you could elect to issue all requests via a RequestManager, without ever using\nthe store directly, by setting [EnableHydration] to `true` and providing a store instance. Not\nnecessarily the most useful thing, but the decoupled nature of the RequestManager and incremental-feature\napproach of EmberData allows for this flexibility.\n\n```ts\nimport { EnableHydration } from '@warp-drive/core-types/request';\n\nrequestManager.request({\n  store: store,\n  url: '/api/posts',\n  method: 'GET',\n  [EnableHydration]: true\n});\n\n@typedoc",
      "line": " ../packages/store/src/-private/cache-handler/handler.ts:48"
    },
    {
      "message": "Missing item type\nA trap method for a function call.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:9"
    },
    {
      "message": "Missing item type\nA trap for the `new` operator.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:16"
    },
    {
      "message": "Missing item type\nA trap for `Object.defineProperty()`.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:25"
    },
    {
      "message": "Missing item type\nA trap for the `delete` operator.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:33"
    },
    {
      "message": "Missing item type\nA trap for getting a property value.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:42"
    },
    {
      "message": "Missing item type\nA trap for `Object.getOwnPropertyDescriptor()`.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:51"
    },
    {
      "message": "Missing item type\nA trap for the `[[GetPrototypeOf]]` internal method.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:59"
    },
    {
      "message": "Missing item type\nA trap for the `in` operator.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:66"
    },
    {
      "message": "Missing item type\nA trap for `Object.isExtensible()`.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:74"
    },
    {
      "message": "Missing item type\nA trap for `Reflect.ownKeys()`.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:81"
    },
    {
      "message": "Missing item type\nA trap for `Object.preventExtensions()`.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:88"
    },
    {
      "message": "Missing item type\nA trap for setting a property value.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:95"
    },
    {
      "message": "Missing item type\nA trap for `Object.setPrototypeOf()`.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:105"
    },
    {
      "message": "Missing item type\nCreates a revocable Proxy object.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:115"
    },
    {
      "message": "Missing item type\nCreates a Proxy object. The Proxy object allows you to create an object that can be used in place of the\noriginal object, but which may redefine fundamental Object operations like getting, setting, and defining\nproperties. Proxy objects are commonly used to log property accesses, validate, format, or sanitize inputs.",
      "line": " ../packages/store/src/-private/record-arrays/native-proxy-type-fix.ts:123"
    },
    {
      "message": "Missing item type\nCurrently only records that extend object can be created via\nstore.createRecord. This is a limitation of the current API,\nbut can be worked around by creating a new identifier, running\nthe cache.clientDidCreate method, and then peeking the record\nfor the identifier.\n\nTo assign primary key to a record during creation, only `id` will\nwork correctly for `store.createRecord`, other primary key may be\nhandled by updating the record after creation or using the flow\ndescribed above.\n\nTODO: These are limitations we want to (and can) address. If you\nhave need of lifting these limitations, please open an issue.",
      "line": " ../packages/store/src/-private/store-service.ts:260"
    },
    {
      "message": "Missing item type\nAsync flush buffers notifications until flushed\nby finalization of a future configured by store.request\n\nThis is useful for ensuring that notifications are delivered\nprior to the promise resolving but without risk of promise\ninterleaving.",
      "line": " ../packages/store/src/-private/store-service.ts:657"
    },
    {
      "message": "Missing item type\nExecutes the callback, ensurng that any work that calls\nstore._schedule is executed after in the right order.\n\nWhen queues already exist, scheduled callbacks will\njoin the existing queue.",
      "line": " ../packages/store/src/-private/store-service.ts:744"
    },
    {
      "message": "Missing item type\nMinimum subset of static schema methods and properties on the\n\"model\" class.\n\nOnly used when using the legacy schema-service implementation\nfor @ember-data/model or when wrapping schema for legacy\nAdapters/Serializers.",
      "line": " ../packages/store/src/-types/q/ds-model.ts:6"
    },
    {
      "message": "Missing item type\nIn EmberData, a \"record instance\" is a class instance used to present the data\nfor a single resource, transforming the resource's cached raw data into a form\nthat is useful for the application.\n\nSince every application's needs are different, EmberData does not assume to know\nwhat the shape of the record instance should be. Instead, it provides a way to\ndefine the record instance's via the `instantiateRecord` hook on the store.\n\nThus for most purposes the `RecordInstance` type is \"opaque\" to EmberData, and\nshould be treated as \"unknown\" by the library.\n\nWherever possible, if typing an API that is consumer facing, instead of using\nOpaqueRecordInstance, we should prefer to use a generic and check if the generic\nextends `TypedRecordInstance`. This allows consumers to define their own record\ninstance types and not only have their types flow through EmberData APIs, but\nalso allows EmberData to provide typechecking and intellisense for the record\nbased on a special symbol prsent on record instances that implement the\n`TypedRecordInstance` interface.",
      "line": " ../packages/store/src/-types/q/record-instance.ts:5"
    },
    {
      "message": "Missing item type\nData to preload into the store before the request is made.\nThis feature is *highly* discouraged and has no corresponding\nfeature when using builders and handlers.\n\nExcepting relationships: the data should be in the form of a\nJSON object where the keys are fields on the record and the value\nis the raw value to be added to the cache.\n\nRelationships can either be provided as string IDs from which\nan identifier will be built base upon the relationship's expected\nresource type, or be record instances from which the identifier\nwill be extracted.",
      "line": " ../packages/store/src/-types/q/store.ts:11"
    },
    {
      "message": "Missing item type\nIf there is a current transaction, ensures that the relevant tag (and any\narray computed chains symbols, if applicable) will be consumed during the\ntransaction.\n\nIf there is no current transaction, will consume the tag(s) immediately.",
      "line": " ../packages/tracking/src/-private.ts:62"
    },
    {
      "message": "Missing item type\nuse to add a signal property to the prototype of something.\n\nFirst arg is the thing to define on\nSecond arg is the property name\nThird agg is the initial value of the property if any.\n\nfor instance\n\n```ts\nclass Model {}\ndefineSignal(Model.prototype, 'isLoading', false);\n```\n\nThis is sort of like using a stage-3 decorator but works today\nwhile we are still on legacy decorators.\n\ne.g. it is equivalent to\n\n```ts\nclass Model {\n  @signal accessor isLoading = false;\n}\n```",
      "line": " ../packages/tracking/src/-private.ts:285"
    },
    {
      "message": "Missing item type\nKey on the associated object",
      "line": " ../packages/tracking/src/-private.ts:349"
    },
    {
      "message": "Missing item type\nWhether this signal is part of an active transaction.",
      "line": " ../packages/tracking/src/-private.ts:356"
    },
    {
      "message": "Missing item type\nWhether to \"bust\" the lastValue cache",
      "line": " ../packages/tracking/src/-private.ts:362"
    },
    {
      "message": "Missing item type\nThe reason this signal is dirty",
      "line": " ../packages/tracking/src/-private.ts:368"
    },
    {
      "message": "Missing item type\nThe framework specific \"signal\" e.g. glimmer \"tracked\"\nor starbeam \"cell\" to consume/invalidate when appropriate.",
      "line": " ../packages/tracking/src/-private.ts:375"
    },
    {
      "message": "Missing item type\nIn classic ember, arrays must entangle a `[]` symbol\nin addition to any other tag in order for array chains to work.\n\nNote, this symbol MUST be the one that ember itself generates",
      "line": " ../packages/tracking/src/-private.ts:383"
    },
    {
      "message": "Missing item type\nIn classic ember, arrays must entangle a `@length` symbol\nin addition to any other tag in order for array chains to work.\n\nNote, this symbol MUST be the one that ember itself generates",
      "line": " ../packages/tracking/src/-private.ts:392"
    },
    {
      "message": "Missing item type\nThe lastValue computed for this signal when\na signal is also used for storage.",
      "line": " ../packages/tracking/src/-private.ts:402"
    },
    {
      "message": "Missing item type\nCreate a signal for the key/object pairing.",
      "line": " ../packages/tracking/src/-private.ts:417"
    },
    {
      "message": "Missing item type\nCreate a signal for the key/object pairing and subscribes to the signal.\n\nUse when you need to ensure a signal exists and is subscribed to.",
      "line": " ../packages/tracking/src/-private.ts:456"
    }
  ]
}
