{
  "data": {
    "id": "ember-data-5.3.8-@ember-data/model",
    "type": "module",
    "attributes": {
      "name": "@ember-data/model",
      "submodules": {},
      "elements": {},
      "fors": {
        "@ember-data/model": 1
      },
      "namespaces": {},
      "tag": "main",
      "file": "../model/src/-private/promise-many-array.ts",
      "line": 18,
      "description": "<html><head></head><body><p>This package provides a Presentation Model for resource data in an EmberData Cache.</p>\n<p>Models are defined as classes extending from <code>import Model from '@ember-data/model';</code> and the\nattributes and relationships on these classes are parsed at runtime to supply static \"schema\"\nto EmberData's SchemaService.</p>\n<p>Resource data for individual resources fetched from your API is presented to the UI via instances\nof the <code>Model</code>s you define. An instantiated <code>Model</code> is referred to as a <code>record</code>.</p>\n<p> When we refer to the <code>ModelClass</code> as opposed to a <code>Model</code> or <code>Record</code> we are referring\n specifically to the class definition and the static schema methods present on it.</p>\n<p> When we refer to a <code>record</code> we refer to a specific class instance presenting\n the resource data for a given <code>type</code> and <code>id</code>.</p>\n<h3 id=\"defining-a-model\">Defining a Model</h3>\n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <thead>\n            <tr>\n              <td colspan=\"2\">app/models/person.js</td>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre></td>\n              <td class=\"code\"><pre><span class=\"keyword\">import</span> <span class=\"type\">Model</span>, { attr, belongsTo, hasMany } from '<span class=\"meta\">@ember</span>-data/model';\n\n<span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Model</span> </span>{\n  <span class=\"meta\">@attr</span> name;\n\n  <span class=\"meta\">@belongsTo</span>('pet', { inverse: 'owners', async: <span class=\"literal\">false</span> }) dog;\n\n  <span class=\"meta\">@hasMany</span>('person', { inverse: 'friends', async: <span class=\"literal\">true</span> }) friends;\n}</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<h3 id=\"modelname-convention\">modelName convention</h3>\n<p> By convention, the name of a given model (its <code>type</code>) matches the name\n of the file in the <code>app/models</code> folder and should be lowercase, singular\n and dasherized.</p>\n</body></html>",
      "itemtype": "main",
      "parent": null,
      "publicclasses": [
        "BelongsToReference",
        "HasManyReference",
        "Errors",
        "Model",
        "PromiseManyArray"
      ],
      "privateclasses": [
        "PromiseBelongsTo"
      ],
      "staticfunctions": {
        "@ember-data/model": [
          {
            "file": "../packages/model/src/-private/attr.ts",
            "line": 183,
            "description": "`attr` defines an attribute on a [Model](/ember-data/release/classes/Model).\nBy default, attributes are passed through as-is, however you can specify an\noptional type to have the value automatically transformed.\nEmberData ships with four basic transform types: `string`, `number`,\n`boolean` and `date`. You can define your own transforms by subclassing\n[Transform](/ember-data/release/classes/Transform).\n\nNote that you cannot use `attr` to define an attribute of `id`.\n\n`attr` takes an optional hash as a second parameter, currently\nsupported options are:\n\n- `defaultValue`: Pass a string or a function to be called to set the attribute\nto a default value if and only if the key is absent from the payload response.\n\nExample\n\n```app/models/user.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('string') username;\n  @attr('string') email;\n  @attr('boolean', { defaultValue: false }) verified;\n}\n```\n\nDefault value can also be a function. This is useful it you want to return\na new object for each attribute.\n\n```app/models/user.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('string') username;\n  @attr('string') email;\n\n  @attr({\n    defaultValue() {\n      return {};\n    }\n  })\n  settings;\n}\n```\n\nThe `options` hash is passed as second argument to a transforms'\n`serialize` and `deserialize` method. This allows to configure a\ntransformation and adapt the corresponding value, based on the config:\n\n```app/models/post.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @attr('text', {\n    uppercase: true\n  })\n  text;\n}\n```\n\n```app/transforms/text.js\nexport default class TextTransform {\n  serialize(value, options) {\n    if (options.uppercase) {\n      return value.toUpperCase();\n    }\n\n    return value;\n  }\n\n  deserialize(value) {\n    return value;\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```",
            "itemtype": "method",
            "name": "attr",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "type",
                "description": "the attribute type",
                "type": "String|Object"
              },
              {
                "name": "options",
                "description": "a hash of options",
                "type": "Object"
              }
            ],
            "return": {
              "description": "",
              "type": "Attribute"
            },
            "class": "@ember-data/model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/belongs-to.ts",
            "line": 113,
            "description": "`belongsTo` is used to define One-To-One and One-To-Many, and One-To-None\nrelationships on a [Model](/ember-data/release/classes/Model).\n\n`belongsTo` takes a configuration hash as a second parameter, currently\nsupported options are:\n\n- `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n- `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n- `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n- `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n### Examples\n\nTo declare a **one-to-many** (or many-to-many) relationship, use\n`belongsTo` in combination with `hasMany`:\n\n```js\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('post', { async: false, inverse: 'comments' }) post;\n}\n\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'post' }) comments;\n}\n```\n\nTo declare a **one-to-one** relationship with managed inverses, use `belongsTo` for both sides:\n\n```js\n// app/models/author.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Author extends Model {\n  @belongsTo('address', { async: true, inverse: 'owner' }) address;\n}\n\n// app/models/address.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Address extends Model {\n  @belongsTo('author', { async: true, inverse: 'address' }) owner;\n}\n```\n\nTo declare a **one-to-one** relationship without managed inverses, use `belongsTo` for both sides\nwith `null` as the inverse:\n\n```js\n// app/models/author.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Author extends Model {\n  @belongsTo('address', { async: true, inverse: null }) address;\n}\n\n// app/models/address.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Address extends Model {\n  @belongsTo('author', { async: true, inverse: null }) owner;\n}\n```\n\nTo declare a one-to-none relationship between two models, use\n`belongsTo` with inverse set to `null` on just one side::\n\n```js\n// app/models/person.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Person extends Model {\n  @belongsTo('person', { async: false, inverse: null }) bestFriend;\n}\n```\n\n#### Sync vs Async Relationships\n\nEmberData fulfills relationships using resource data available in\nthe cache.\n\nSync relationships point directly to the known related resources.\n\nWhen a relationship is declared as async, if any of the known related\nresources have not been loaded, they will be fetched. The property\non the record when accessed provides a promise that resolves once\nall resources are loaded.\n\nAsync relationships may take advantage of links. On access, if the related\nlink has not been loaded, or if any known resources are not available in\nthe cache, the fresh state will be fetched using the link.\n\nIn contrast to async relationship, accessing a sync relationship\nwill error on access when any of the known related resources have\nnot been loaded.\n\nIf you are using `links` with sync relationships, you have to use\nthe BelongsTo reference API to fetch or refresh related resources\nthat aren't loaded. For instance, for a `bestFriend` relationship:\n\n```js\nperson.belongsTo('bestFriend').reload();\n```\n\n#### Polymorphic Relationships\n\nTo declare a polymorphic relationship, use `hasMany` with the `polymorphic`\noption set to `true`:\n\n```js\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n}\n```\n\n`'commentable'` here is referred to as the \"abstract type\" for the polymorphic\nrelationship.\n\nPolymorphic relationships with `inverse: null` will accept any type of record as their content.\nPolymorphic relationships with `inverse` set to a string will only accept records with a matching\ninverse relationships declaring itself as satisfying the abstract type.\n\nBelow, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\nfor this relationship.\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n}\n```\n\nNote: every Model that declares an inverse to a polymorphic relationship must\ndeclare itself exactly the same. This is because polymorphism is based on structural\ntraits.\n\nPolymorphic to polymorphic relationships are supported. Both sides of the relationship\nmust be declared as polymorphic, and the `as` option must be used to declare the abstract\ntype each record satisfies on both sides.",
            "itemtype": "method",
            "name": "belongsTo",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "type",
                "description": "(optional) the name of the related resource",
                "type": "String"
              },
              {
                "name": "options",
                "description": "(optional) a hash of options",
                "type": "Object"
              }
            ],
            "return": {
              "description": "relationship",
              "type": "PropertyDescriptor"
            },
            "class": "@ember-data/model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/has-many.ts",
            "line": 94,
            "description": "`hasMany` is used to define Many-To-One and Many-To-Many, and Many-To-None\nrelationships on a [Model](/ember-data/release/classes/Model).\n\n`hasMany` takes a configuration hash as a second parameter, currently\nsupported options are:\n\n- `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n- `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n- `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n- `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n### Examples\n\nTo declare a **many-to-one** (or one-to-many) relationship, use\n`belongsTo` in combination with `hasMany`:\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'post' }) comments;\n}\n\n\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('post', { async: false, inverse: 'comments' }) post;\n}\n```\n\nTo declare a **many-to-many** relationship with managed inverses, use `hasMany` for both sides:\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('tag', { async: true, inverse: 'posts' }) tags;\n}\n\n// app/models/tag.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Tag extends Model {\n  @hasMany('post', { async: true, inverse: 'tags' }) posts;\n}\n```\n\nTo declare a **many-to-many** relationship without managed inverses, use `hasMany` for both sides\nwith `null` as the inverse:\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('tag', { async: true, inverse: null }) tags;\n}\n\n// app/models/tag.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Tag extends Model {\n  @hasMany('post', { async: true, inverse: null }) posts;\n}\n```\n\nTo declare a many-to-none relationship between two models, use\n`hasMany` with inverse set to `null` on just one side::\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('category', { async: true, inverse: null }) categories;\n}\n```\n\n#### Sync vs Async Relationships\n\nEmberData fulfills relationships using resource data available in\nthe cache.\n\nSync relationships point directly to the known related resources.\n\nWhen a relationship is declared as async, if any of the known related\nresources have not been loaded, they will be fetched. The property\non the record when accessed provides a promise that resolves once\nall resources are loaded.\n\nAsync relationships may take advantage of links. On access, if the related\nlink has not been loaded, or if any known resources are not available in\nthe cache, the fresh state will be fetched using the link.\n\nIn contrast to async relationship, accessing a sync relationship\nwill error on access when any of the known related resources have\nnot been loaded.\n\nIf you are using `links` with sync relationships, you have to use\nthe HasMany reference API to fetch or refresh related resources\nthat aren't loaded. For instance, for a `comments` relationship:\n\n```js\npost.hasMany('comments').reload();\n```\n\n#### Polymorphic Relationships\n\nTo declare a polymorphic relationship, use `hasMany` with the `polymorphic`\noption set to `true`:\n\n```js\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n}\n```\n\n`'commentable'` here is referred to as the \"abstract type\" for the polymorphic\nrelationship.\n\nPolymorphic relationships with `inverse: null` will accept any type of record as their content.\nPolymorphic relationships with `inverse` set to a string will only accept records with a matching\ninverse relationships declaring itself as satisfying the abstract type.\n\nBelow, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\nfor this relationship.\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n}\n```\n\nNote: every Model that declares an inverse to a polymorphic relationship must\ndeclare itself exactly the same. This is because polymorphism is based on structural\ntraits.\n\nPolymorphic to polymorphic relationships are supported. Both sides of the relationship\nmust be declared as polymorphic, and the `as` option must be used to declare the abstract\ntype each record satisfies on both sides.",
            "itemtype": "method",
            "name": "hasMany",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "type",
                "description": "(optional) the name of the related resource",
                "type": "String"
              },
              {
                "name": "options",
                "description": "(optional) a hash of options",
                "type": "Object"
              }
            ],
            "return": {
              "description": "relationship",
              "type": "PropertyDescriptor"
            },
            "class": "@ember-data/model",
            "module": "@ember-data/model"
          }
        ],
        "Model": [
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1814,
            "description": "Iterates through the attributes of the model, calling the passed function on each\nattribute.\n\nThe callback method you provide should have the following signature (all\nparameters are optional):\n\n```javascript\nfunction(name, meta);\n```\n\n- `name` the name of the current property in the iteration\n- `meta` the meta object for the attribute property in the iteration\n\nNote that in addition to a callback, you can also pass an optional target\nobject that will be set as `this` on the context.\n\nExample\n\n```javascript\nimport Model, { attr } from '@ember-data/model';\n\nclass PersonModel extends Model {\n   @attr('string') firstName;\n   @attr('string') lastName;\n   @attr('date') birthday;\n }\n\nPersonModel.eachAttribute(function(name, meta) {\n   // do thing\n });\n\n// prints:\n// firstName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"firstName\"}\n// lastName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"lastName\"}\n// birthday {type: \"date\", kind: 'attribute', options: Object, parentType: function, name: \"birthday\"}\n```",
            "itemtype": "method",
            "name": "eachAttribute",
            "access": "public",
            "tagname": "",
            "params": [
              {
                "name": "callback",
                "description": "The callback to execute",
                "type": "Function"
              },
              {
                "name": "binding",
                "description": "the value to which the callback's `this` should be bound",
                "type": "Object",
                "optional": true
              }
            ],
            "static": 1,
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1633,
            "description": "Given a callback, iterates over each of the types related to a model,\ninvoking the callback with the related type's class. Each type will be\nreturned just once, regardless of how many different relationships it has\nwith a model.",
            "itemtype": "method",
            "name": "eachRelatedType",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "callback",
                "description": "the callback to invoke",
                "type": "Function"
              },
              {
                "name": "binding",
                "description": "the value to which the callback's `this` should be bound",
                "type": "Any"
              }
            ],
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1604,
            "description": "Given a callback, iterates over each of the relationships in the model,\ninvoking the callback with the name of each relationship and its relationship\ndescriptor.",
            "itemtype": "method",
            "name": "eachRelationship",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "callback",
                "description": "the callback to invoke",
                "type": "Function"
              },
              {
                "name": "binding",
                "description": "the value to which the callback's `this` should be bound",
                "type": "Any"
              }
            ],
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1872,
            "description": "Iterates through the transformedAttributes of the model, calling\nthe passed function on each attribute. Note the callback will not be\ncalled for any attributes that do not have an transformation type.\n\nThe callback method you provide should have the following signature (all\nparameters are optional):\n\n```javascript\nfunction(name, type);\n```\n\n- `name` the name of the current property in the iteration\n- `type` a string containing the name of the type of transformed\napplied to the attribute\n\nNote that in addition to a callback, you can also pass an optional target\nobject that will be set as `this` on the context.\n\nExample\n\n```javascript\nimport Model, { attr } from '@ember-data/model';\n\nlet Person = Model.extend({\n   firstName: attr(),\n   lastName: attr('string'),\n   birthday: attr('date')\n });\n\nPerson.eachTransformedAttribute(function(name, type) {\n   // do thing\n });\n\n// prints:\n// lastName string\n// birthday date\n```",
            "itemtype": "method",
            "name": "eachTransformedAttribute",
            "access": "public",
            "tagname": "",
            "params": [
              {
                "name": "callback",
                "description": "The callback to execute",
                "type": "Function"
              },
              {
                "name": "binding",
                "description": "the value to which the callback's `this` should be bound",
                "type": "Object",
                "optional": true
              }
            ],
            "static": 1,
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1190,
            "description": "Find the relationship which is the inverse of the one asked for.\n\nFor example, if you define models like this:\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n   @hasMany('message') comments;\n }\n```\n\n```app/models/message.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class MessageModel extends Model {\n   @belongsTo('post') owner;\n }\n```\n\n``` js\nstore.modelFor('post').inverseFor('comments', store) // { type: 'message', name: 'owner', kind: 'belongsTo' }\nstore.modelFor('message').inverseFor('owner', store) // { type: 'post', name: 'comments', kind: 'hasMany' }\n```",
            "itemtype": "method",
            "name": "inverseFor",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "name",
                "description": "the name of the relationship",
                "type": "String"
              },
              {
                "name": "store",
                "description": "",
                "type": "Store"
              }
            ],
            "return": {
              "description": "the inverse relationship, or null",
              "type": "Object"
            },
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1931,
            "description": "Returns the name of the model class.",
            "itemtype": "method",
            "name": "toString",
            "access": "public",
            "tagname": "",
            "static": 1,
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1149,
            "description": "For a given relationship name, returns the model type of the relationship.\n\nFor example, if you define a model like this:\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment') comments;\n}\n```\n\nCalling `store.modelFor('post').typeForRelationship('comments', store)` will return `Comment`.",
            "itemtype": "method",
            "name": "typeForRelationship",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "name",
                "description": "the name of the relationship",
                "type": "String"
              },
              {
                "name": "store",
                "description": "an instance of Store",
                "type": "Store"
              }
            ],
            "return": {
              "description": "the type of the relationship, or undefined",
              "type": "Model"
            },
            "class": "Model",
            "module": "@ember-data/model"
          }
        ]
      },
      "allstaticfunctions": {
        "@ember-data/model": [
          {
            "file": "../packages/model/src/-private/attr.ts",
            "line": 183,
            "description": "`attr` defines an attribute on a [Model](/ember-data/release/classes/Model).\nBy default, attributes are passed through as-is, however you can specify an\noptional type to have the value automatically transformed.\nEmberData ships with four basic transform types: `string`, `number`,\n`boolean` and `date`. You can define your own transforms by subclassing\n[Transform](/ember-data/release/classes/Transform).\n\nNote that you cannot use `attr` to define an attribute of `id`.\n\n`attr` takes an optional hash as a second parameter, currently\nsupported options are:\n\n- `defaultValue`: Pass a string or a function to be called to set the attribute\nto a default value if and only if the key is absent from the payload response.\n\nExample\n\n```app/models/user.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('string') username;\n  @attr('string') email;\n  @attr('boolean', { defaultValue: false }) verified;\n}\n```\n\nDefault value can also be a function. This is useful it you want to return\na new object for each attribute.\n\n```app/models/user.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('string') username;\n  @attr('string') email;\n\n  @attr({\n    defaultValue() {\n      return {};\n    }\n  })\n  settings;\n}\n```\n\nThe `options` hash is passed as second argument to a transforms'\n`serialize` and `deserialize` method. This allows to configure a\ntransformation and adapt the corresponding value, based on the config:\n\n```app/models/post.js\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @attr('text', {\n    uppercase: true\n  })\n  text;\n}\n```\n\n```app/transforms/text.js\nexport default class TextTransform {\n  serialize(value, options) {\n    if (options.uppercase) {\n      return value.toUpperCase();\n    }\n\n    return value;\n  }\n\n  deserialize(value) {\n    return value;\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```",
            "itemtype": "method",
            "name": "attr",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "type",
                "description": "the attribute type",
                "type": "String|Object"
              },
              {
                "name": "options",
                "description": "a hash of options",
                "type": "Object"
              }
            ],
            "return": {
              "description": "",
              "type": "Attribute"
            },
            "class": "@ember-data/model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/belongs-to.ts",
            "line": 113,
            "description": "`belongsTo` is used to define One-To-One and One-To-Many, and One-To-None\nrelationships on a [Model](/ember-data/release/classes/Model).\n\n`belongsTo` takes a configuration hash as a second parameter, currently\nsupported options are:\n\n- `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n- `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n- `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n- `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n### Examples\n\nTo declare a **one-to-many** (or many-to-many) relationship, use\n`belongsTo` in combination with `hasMany`:\n\n```js\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('post', { async: false, inverse: 'comments' }) post;\n}\n\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'post' }) comments;\n}\n```\n\nTo declare a **one-to-one** relationship with managed inverses, use `belongsTo` for both sides:\n\n```js\n// app/models/author.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Author extends Model {\n  @belongsTo('address', { async: true, inverse: 'owner' }) address;\n}\n\n// app/models/address.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Address extends Model {\n  @belongsTo('author', { async: true, inverse: 'address' }) owner;\n}\n```\n\nTo declare a **one-to-one** relationship without managed inverses, use `belongsTo` for both sides\nwith `null` as the inverse:\n\n```js\n// app/models/author.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Author extends Model {\n  @belongsTo('address', { async: true, inverse: null }) address;\n}\n\n// app/models/address.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Address extends Model {\n  @belongsTo('author', { async: true, inverse: null }) owner;\n}\n```\n\nTo declare a one-to-none relationship between two models, use\n`belongsTo` with inverse set to `null` on just one side::\n\n```js\n// app/models/person.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Person extends Model {\n  @belongsTo('person', { async: false, inverse: null }) bestFriend;\n}\n```\n\n#### Sync vs Async Relationships\n\nEmberData fulfills relationships using resource data available in\nthe cache.\n\nSync relationships point directly to the known related resources.\n\nWhen a relationship is declared as async, if any of the known related\nresources have not been loaded, they will be fetched. The property\non the record when accessed provides a promise that resolves once\nall resources are loaded.\n\nAsync relationships may take advantage of links. On access, if the related\nlink has not been loaded, or if any known resources are not available in\nthe cache, the fresh state will be fetched using the link.\n\nIn contrast to async relationship, accessing a sync relationship\nwill error on access when any of the known related resources have\nnot been loaded.\n\nIf you are using `links` with sync relationships, you have to use\nthe BelongsTo reference API to fetch or refresh related resources\nthat aren't loaded. For instance, for a `bestFriend` relationship:\n\n```js\nperson.belongsTo('bestFriend').reload();\n```\n\n#### Polymorphic Relationships\n\nTo declare a polymorphic relationship, use `hasMany` with the `polymorphic`\noption set to `true`:\n\n```js\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n}\n```\n\n`'commentable'` here is referred to as the \"abstract type\" for the polymorphic\nrelationship.\n\nPolymorphic relationships with `inverse: null` will accept any type of record as their content.\nPolymorphic relationships with `inverse` set to a string will only accept records with a matching\ninverse relationships declaring itself as satisfying the abstract type.\n\nBelow, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\nfor this relationship.\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n}\n```\n\nNote: every Model that declares an inverse to a polymorphic relationship must\ndeclare itself exactly the same. This is because polymorphism is based on structural\ntraits.\n\nPolymorphic to polymorphic relationships are supported. Both sides of the relationship\nmust be declared as polymorphic, and the `as` option must be used to declare the abstract\ntype each record satisfies on both sides.",
            "itemtype": "method",
            "name": "belongsTo",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "type",
                "description": "(optional) the name of the related resource",
                "type": "String"
              },
              {
                "name": "options",
                "description": "(optional) a hash of options",
                "type": "Object"
              }
            ],
            "return": {
              "description": "relationship",
              "type": "PropertyDescriptor"
            },
            "class": "@ember-data/model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/has-many.ts",
            "line": 94,
            "description": "`hasMany` is used to define Many-To-One and Many-To-Many, and Many-To-None\nrelationships on a [Model](/ember-data/release/classes/Model).\n\n`hasMany` takes a configuration hash as a second parameter, currently\nsupported options are:\n\n- `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n- `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n- `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n- `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n### Examples\n\nTo declare a **many-to-one** (or one-to-many) relationship, use\n`belongsTo` in combination with `hasMany`:\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'post' }) comments;\n}\n\n\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('post', { async: false, inverse: 'comments' }) post;\n}\n```\n\nTo declare a **many-to-many** relationship with managed inverses, use `hasMany` for both sides:\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('tag', { async: true, inverse: 'posts' }) tags;\n}\n\n// app/models/tag.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Tag extends Model {\n  @hasMany('post', { async: true, inverse: 'tags' }) posts;\n}\n```\n\nTo declare a **many-to-many** relationship without managed inverses, use `hasMany` for both sides\nwith `null` as the inverse:\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('tag', { async: true, inverse: null }) tags;\n}\n\n// app/models/tag.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Tag extends Model {\n  @hasMany('post', { async: true, inverse: null }) posts;\n}\n```\n\nTo declare a many-to-none relationship between two models, use\n`hasMany` with inverse set to `null` on just one side::\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('category', { async: true, inverse: null }) categories;\n}\n```\n\n#### Sync vs Async Relationships\n\nEmberData fulfills relationships using resource data available in\nthe cache.\n\nSync relationships point directly to the known related resources.\n\nWhen a relationship is declared as async, if any of the known related\nresources have not been loaded, they will be fetched. The property\non the record when accessed provides a promise that resolves once\nall resources are loaded.\n\nAsync relationships may take advantage of links. On access, if the related\nlink has not been loaded, or if any known resources are not available in\nthe cache, the fresh state will be fetched using the link.\n\nIn contrast to async relationship, accessing a sync relationship\nwill error on access when any of the known related resources have\nnot been loaded.\n\nIf you are using `links` with sync relationships, you have to use\nthe HasMany reference API to fetch or refresh related resources\nthat aren't loaded. For instance, for a `comments` relationship:\n\n```js\npost.hasMany('comments').reload();\n```\n\n#### Polymorphic Relationships\n\nTo declare a polymorphic relationship, use `hasMany` with the `polymorphic`\noption set to `true`:\n\n```js\n// app/models/comment.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class Comment extends Model {\n  @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n}\n```\n\n`'commentable'` here is referred to as the \"abstract type\" for the polymorphic\nrelationship.\n\nPolymorphic relationships with `inverse: null` will accept any type of record as their content.\nPolymorphic relationships with `inverse` set to a string will only accept records with a matching\ninverse relationships declaring itself as satisfying the abstract type.\n\nBelow, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\nfor this relationship.\n\n```js\n// app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n}\n```\n\nNote: every Model that declares an inverse to a polymorphic relationship must\ndeclare itself exactly the same. This is because polymorphism is based on structural\ntraits.\n\nPolymorphic to polymorphic relationships are supported. Both sides of the relationship\nmust be declared as polymorphic, and the `as` option must be used to declare the abstract\ntype each record satisfies on both sides.",
            "itemtype": "method",
            "name": "hasMany",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "type",
                "description": "(optional) the name of the related resource",
                "type": "String"
              },
              {
                "name": "options",
                "description": "(optional) a hash of options",
                "type": "Object"
              }
            ],
            "return": {
              "description": "relationship",
              "type": "PropertyDescriptor"
            },
            "class": "@ember-data/model",
            "module": "@ember-data/model"
          }
        ],
        "Model": [
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1088,
            "description": "Create should only ever be called by the store. To create an instance of a\n`Model` in a dirty state use `store.createRecord`.\n\n   To create instances of `Model` in a clean state, use `store.push`",
            "itemtype": "method",
            "name": "create",
            "access": "private",
            "tagname": "",
            "static": 1,
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1814,
            "description": "Iterates through the attributes of the model, calling the passed function on each\nattribute.\n\nThe callback method you provide should have the following signature (all\nparameters are optional):\n\n```javascript\nfunction(name, meta);\n```\n\n- `name` the name of the current property in the iteration\n- `meta` the meta object for the attribute property in the iteration\n\nNote that in addition to a callback, you can also pass an optional target\nobject that will be set as `this` on the context.\n\nExample\n\n```javascript\nimport Model, { attr } from '@ember-data/model';\n\nclass PersonModel extends Model {\n   @attr('string') firstName;\n   @attr('string') lastName;\n   @attr('date') birthday;\n }\n\nPersonModel.eachAttribute(function(name, meta) {\n   // do thing\n });\n\n// prints:\n// firstName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"firstName\"}\n// lastName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"lastName\"}\n// birthday {type: \"date\", kind: 'attribute', options: Object, parentType: function, name: \"birthday\"}\n```",
            "itemtype": "method",
            "name": "eachAttribute",
            "access": "public",
            "tagname": "",
            "params": [
              {
                "name": "callback",
                "description": "The callback to execute",
                "type": "Function"
              },
              {
                "name": "binding",
                "description": "the value to which the callback's `this` should be bound",
                "type": "Object",
                "optional": true
              }
            ],
            "static": 1,
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1633,
            "description": "Given a callback, iterates over each of the types related to a model,\ninvoking the callback with the related type's class. Each type will be\nreturned just once, regardless of how many different relationships it has\nwith a model.",
            "itemtype": "method",
            "name": "eachRelatedType",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "callback",
                "description": "the callback to invoke",
                "type": "Function"
              },
              {
                "name": "binding",
                "description": "the value to which the callback's `this` should be bound",
                "type": "Any"
              }
            ],
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1604,
            "description": "Given a callback, iterates over each of the relationships in the model,\ninvoking the callback with the name of each relationship and its relationship\ndescriptor.",
            "itemtype": "method",
            "name": "eachRelationship",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "callback",
                "description": "the callback to invoke",
                "type": "Function"
              },
              {
                "name": "binding",
                "description": "the value to which the callback's `this` should be bound",
                "type": "Any"
              }
            ],
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1872,
            "description": "Iterates through the transformedAttributes of the model, calling\nthe passed function on each attribute. Note the callback will not be\ncalled for any attributes that do not have an transformation type.\n\nThe callback method you provide should have the following signature (all\nparameters are optional):\n\n```javascript\nfunction(name, type);\n```\n\n- `name` the name of the current property in the iteration\n- `type` a string containing the name of the type of transformed\napplied to the attribute\n\nNote that in addition to a callback, you can also pass an optional target\nobject that will be set as `this` on the context.\n\nExample\n\n```javascript\nimport Model, { attr } from '@ember-data/model';\n\nlet Person = Model.extend({\n   firstName: attr(),\n   lastName: attr('string'),\n   birthday: attr('date')\n });\n\nPerson.eachTransformedAttribute(function(name, type) {\n   // do thing\n });\n\n// prints:\n// lastName string\n// birthday date\n```",
            "itemtype": "method",
            "name": "eachTransformedAttribute",
            "access": "public",
            "tagname": "",
            "params": [
              {
                "name": "callback",
                "description": "The callback to execute",
                "type": "Function"
              },
              {
                "name": "binding",
                "description": "the value to which the callback's `this` should be bound",
                "type": "Object",
                "optional": true
              }
            ],
            "static": 1,
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1190,
            "description": "Find the relationship which is the inverse of the one asked for.\n\nFor example, if you define models like this:\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n   @hasMany('message') comments;\n }\n```\n\n```app/models/message.js\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class MessageModel extends Model {\n   @belongsTo('post') owner;\n }\n```\n\n``` js\nstore.modelFor('post').inverseFor('comments', store) // { type: 'message', name: 'owner', kind: 'belongsTo' }\nstore.modelFor('message').inverseFor('owner', store) // { type: 'post', name: 'comments', kind: 'hasMany' }\n```",
            "itemtype": "method",
            "name": "inverseFor",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "name",
                "description": "the name of the relationship",
                "type": "String"
              },
              {
                "name": "store",
                "description": "",
                "type": "Store"
              }
            ],
            "return": {
              "description": "the inverse relationship, or null",
              "type": "Object"
            },
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1931,
            "description": "Returns the name of the model class.",
            "itemtype": "method",
            "name": "toString",
            "access": "public",
            "tagname": "",
            "static": 1,
            "class": "Model",
            "module": "@ember-data/model"
          },
          {
            "file": "../packages/model/src/-private/model.ts",
            "line": 1149,
            "description": "For a given relationship name, returns the model type of the relationship.\n\nFor example, if you define a model like this:\n\n```app/models/post.js\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment') comments;\n}\n```\n\nCalling `store.modelFor('post').typeForRelationship('comments', store)` will return `Comment`.",
            "itemtype": "method",
            "name": "typeForRelationship",
            "access": "public",
            "tagname": "",
            "static": 1,
            "params": [
              {
                "name": "name",
                "description": "the name of the relationship",
                "type": "String"
              },
              {
                "name": "store",
                "description": "an instance of Store",
                "type": "Store"
              }
            ],
            "return": {
              "description": "the type of the relationship, or undefined",
              "type": "Model"
            },
            "class": "Model",
            "module": "@ember-data/model"
          }
        ]
      },
      "version": "5.3.8"
    },
    "relationships": {
      "classes": {
        "data": []
      },
      "project-version": {
        "data": {
          "id": "ember-data-5.3.8",
          "type": "project-version"
        }
      }
    }
  }
}