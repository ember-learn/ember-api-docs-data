{
  "data": {
    "id": "ember-data-4.5.0-@ember-data/adapter",
    "type": "module",
    "attributes": {
      "name": "@ember-data/adapter",
      "submodules": {},
      "elements": {},
      "fors": {},
      "namespaces": {},
      "tag": "main",
      "file": "../adapter/addon/index.ts",
      "line": 151,
      "description": "<html><head></head><body><h2 id=\"overview\">Overview</h2>\n<p>In order to properly fetch and update data, EmberData\nneeds to understand how to connect to your API.</p>\n<p><code>Adapters</code> accept various kinds of requests from the store\nand manage fulfillment of the request from your API.</p>\n<h3 id=\"request-flow\">Request Flow</h3>\n<p>When the store decides it needs to issue a request it uses the\nfollowing flow to manage the request and process the data.</p>\n<ul>\n<li>find the appropriate adapter</li>\n<li>issue the request to the adapter</li>\n<li>await the adapter&apos;s response<ul>\n<li>if an error occurs reject with the error</li>\n<li>if no error<ul>\n<li>if there is response data<ul>\n<li>pass the response data to the appropriate serializer</li>\n<li>update the cache using the JSON:API formatted data from the serializer&apos;s response</li>\n</ul>\n</li>\n<li>return the primary record(s) associated with the request</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"request-errors\">Request Errors</h3>\n<p>When a request errors and your adapter does not have the ability to recover from the error,\nyou may either reject the promise returned by your adapter method with the error or simply\nthrow the error.</p>\n<p>If the request was for a <code>createRecord</code> <code>updateRecord</code> or <code>deleteRecord</code> special rules\napply to how this error will affect the state of the store and additional properties on\nthe <code>Error</code> class may be used. See the documentation for these methods in the\n<code>MinimumAdapterInterface</code> for more information.</p>\n<h3 id=\"implementing-an-adapter\">Implementing an Adapter</h3>\n<p>There are seven required adapter methods, one for each of\nthe primary request types that EmberData issues.</p>\n<p>They are:</p>\n<ul>\n<li>findRecord</li>\n<li>findAll</li>\n<li>queryRecord</li>\n<li>query</li>\n<li>createRecord</li>\n<li>updateRecord</li>\n<li>deleteRecord</li>\n</ul>\n<p>Each of these request types has a matching store method that triggers it\nand matching <code>requestType</code> that is passed to the serializer&apos;s\n<code>normalizeResponse</code> method.</p>\n<p>If your app only reads data but never writes data, it is not necessary\nto implement the methods for create, update, and delete. This extends to\nall of the store&apos;s find methods with the exception of <code>findRecord</code> (<code>findAll</code>,\n<code>query</code>, <code>queryRecord</code>): if you do not use the store method in your app then\nyour Adapter does not need the method.</p>\n<div class=\"highlight typescript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n</pre></td>\n              <td class=\"code\"><pre><span class=\"keyword\">import</span> <span class=\"title class_\">EmberObject</span> <span class=\"keyword\">from</span> <span class=\"string\">&apos;@ember/object&apos;</span>;\n\n<span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\">url, options = {}</span>) {\n  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url, options);\n  <span class=\"keyword\">return</span> response.<span class=\"title function_\">toJSON</span>();\n}\n\n<span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ApplicationAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EmberObject</span> {\n  <span class=\"title function_\">findRecord</span>(<span class=\"params\">_, { modelName }, id</span>) {\n    <span class=\"keyword\">return</span> <span class=\"title function_\">fetchData</span>(<span class=\"string\">`./<span class=\"subst\">${modelName}</span>s/<span class=\"subst\">${id}</span>`</span>);\n  }\n}</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<h3 id=\"adapter-resolution\">Adapter Resolution</h3>\n<p><code>store.adapterFor(name)</code> will lookup adapters defined in <code>app/adapters/</code> and\nreturn an instance.</p>\n<p><code>adapterFor</code> first attempts to find an adapter with an exact match on <code>name</code>,\nthen falls back to checking for the presence of an adapter named <code>application</code>.</p>\n<p>If no adapter is found, an error will be thrown.</p>\n<div class=\"highlight typescript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n</pre></td>\n              <td class=\"code\"><pre>store.adapterFor(<span class=\"string\">&apos;author&apos;</span>);\n\n<span class=\"regexp\">//</span> lookup paths (<span class=\"keyword\">in</span> order) =&gt;\n<span class=\"regexp\">//</span>   app<span class=\"regexp\">/adapters/</span>author.js\n<span class=\"regexp\">//</span>   app<span class=\"regexp\">/adapters/</span>application.js</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<p>Most requests in EmberData are made with respect to a particular <code>type</code> (or <code>modelName</code>)\n(e.g., &quot;get me the full collection of <strong>books</strong>&quot; or &quot;get me the <strong>employee</strong> whose id is 37&quot;). We\nrefer to this as the <strong>primary</strong> resource <code>type</code>.</p>\n<p><code>adapterFor</code> is used by the store to find an adapter with a name matching that of the primary\nresource <code>type</code> for the request, which then falls back to the <code>application</code> adapter.</p>\n<p>It is recommended that applications define only a single <code>application</code> adapter and serializer\nwhere possible, only implementing an adapter specific to the <code>type</code> when absolutely necessary.</p>\n<p>If you need to support multiple API versions for the same type, the per-type strategy for\ndefining adapters might not be adequate.</p>\n<p>If you have multiple APIs or multiple API versions and the single application adapter and per-type\nstrategy does not suite your needs, one strategy is to write an <code>application</code> adapter and serializer\nthat make use of <code>options</code> to specify the desired format when making a request, then forwards to the\nrequest to the desired adapter or serializer as needed.</p>\n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <thead>\n            <tr>\n              <td colspan=\"2\">app/adapters/application.js</td>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n</pre></td>\n              <td class=\"code\"><pre><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">EmberObject</span> </span>{\n  findRecord(store, schema, id, snapshot) {\n    let { apiVersion } = snapshot.adapterOptions;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.adapterFor(`-api-${apiVersion}`).findRecord(store, schema, id, snapshot);\n  }\n}</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<h3 id=\"using-an-adapter\">Using an Adapter</h3>\n<p>Any adapter in <code>app/adapters/</code> can be looked up by <code>name</code> using <code>store.adapterFor(name)</code>.</p>\n<h3 id=\"default-adapters\">Default Adapters</h3>\n<p>Applications whose API&apos;s structure endpoint URLs <em>very close to</em> or <em>exactly</em> the <strong>REST</strong>\nor <strong>JSON:API</strong> convention, the <code>@ember-data/adapter</code> package contains implementations\nthese applications can extend.</p>\n<p>Many applications will find writing their own adapter to be allow greater flexibility,\ncustomization, and maintenance than attempting to override methods in these adapters.</p>\n</body></html>",
      "itemtype": "main",
      "parent": null,
      "publicclasses": [
        "MinimumAdapterInterface",
        "BuildURLMixin",
        "Adapter"
      ],
      "privateclasses": [],
      "staticfunctions": {},
      "allstaticfunctions": {},
      "version": "4.5.0"
    },
    "relationships": {
      "classes": {
        "data": []
      },
      "project-version": {
        "data": {
          "id": "ember-data-4.5.0",
          "type": "project-version"
        }
      }
    }
  }
}