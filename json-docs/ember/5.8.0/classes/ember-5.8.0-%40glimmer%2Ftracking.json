{
  "data": {
    "id": "ember-5.8.0-@glimmer/tracking",
    "type": "class",
    "attributes": {
      "name": "@glimmer/tracking",
      "shortname": "@glimmer/tracking",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@glimmer/tracking",
      "namespace": "",
      "methods": [
        {
          "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
          "line": 22,
          "description": "<html><head></head><body><p>Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are <em>static</em>, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:</p>\n<div class=\"highlight handlebars\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n7\n</pre></td>\n              <td class=\"code\"><pre><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Count: </span><span class=\"template-variable\">{{<span class=\"name\">this.count</span>}}</span><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Times Ten: </span><span class=\"template-variable\">{{<span class=\"name\">this.timesTen</span>}}</span><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> </span></span><span class=\"template-variable\">{{<span class=\"name\">on</span> <span class=\"string\">\"click\"</span> this.plusOne}}</span><span class=\"language-xml\"><span class=\"tag\">&gt;</span>\n    Plus One\n  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n</pre></td>\n              <td class=\"code\"><pre><span class=\"keyword\">import</span> <span class=\"type\">Component</span> from '<span class=\"meta\">@glimmer</span>/component';\n<span class=\"keyword\">import</span> { tracked } from '<span class=\"meta\">@glimmer</span>/tracking';\n<span class=\"keyword\">import</span> { action } from '<span class=\"meta\">@ember</span>/<span class=\"class\"><span class=\"keyword\">object</span>'</span>;\n\n<span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>{\n  <span class=\"meta\">@tracked</span> count = <span class=\"number\">0</span>;\n\n  get timesTen() {\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.count * <span class=\"number\">10</span>;\n  }\n\n  <span class=\"meta\">@action</span>\n  plusOne() {\n    <span class=\"keyword\">this</span>.count += <span class=\"number\">1</span>;\n  }\n}</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<p>Both the <code>{{this.count}}</code> and the <code>{{this.timesTen}}</code> properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:</p>\n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n</pre></td>\n              <td class=\"code\"><pre><span class=\"keyword\">import</span> <span class=\"title class_\">Component</span> <span class=\"keyword\">from</span> <span class=\"string\">'@glimmer/component'</span>;\n<span class=\"keyword\">import</span> { tracked } <span class=\"keyword\">from</span> <span class=\"string\">'@glimmer/tracking'</span>;\n\n<span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> {\n  <span class=\"meta\">@tracked</span> name;\n  <span class=\"meta\">@tracked</span> phoneNumber;\n\n  <span class=\"title function_\">constructor</span>(<span class=\"params\">name, phoneNumber</span>) {\n    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;\n    <span class=\"variable language_\">this</span>.<span class=\"property\">phoneNumber</span> = phoneNumber;\n  }\n}\n\n<span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PhoneBookComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> {\n  entries = [\n    <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(<span class=\"string\">'Pizza Palace'</span>, <span class=\"number\">5551234</span>),\n    <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(<span class=\"string\">'1st Street Cleaners'</span>, <span class=\"number\">5554321</span>),\n    <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(<span class=\"string\">'Plants R Us'</span>, <span class=\"number\">5552468</span>),\n  ];\n\n  <span class=\"comment\">// Any usage of this property will update whenever any of the names in the</span>\n  <span class=\"comment\">// entries arrays are updated</span>\n  <span class=\"keyword\">get</span> <span class=\"title function_\">names</span>() {\n    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">entries</span>.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> e.<span class=\"property\">name</span>);\n  }\n\n  <span class=\"comment\">// Any usage of this property will update whenever any of the numbers in the</span>\n  <span class=\"comment\">// entries arrays are updated</span>\n  <span class=\"keyword\">get</span> <span class=\"title function_\">numbers</span>() {\n    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">getFormattedNumbers</span>();\n  }\n\n  <span class=\"title function_\">getFormattedNumbers</span>(<span class=\"params\"></span>) {\n    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">entries</span>\n      .<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> e.<span class=\"property\">phoneNumber</span>)\n      .<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">number</span> =&gt;</span> {\n        <span class=\"keyword\">let</span> numberString = <span class=\"string\">''</span> + <span class=\"built_in\">number</span>;\n\n        <span class=\"keyword\">return</span> numberString.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>) + <span class=\"string\">'-'</span> + numberString.<span class=\"title function_\">slice</span>(<span class=\"number\">3</span>);\n      });\n  }\n}</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<p>It's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.</p>\n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n</pre></td>\n              <td class=\"code\"><pre>let entry = <span class=\"built_in\">new</span> Entry(<span class=\"string\">'Pizza Palace'</span>, <span class=\"number\">5551234</span>);\n\n// <span class=\"keyword\">if</span> entry was used <span class=\"keyword\">when</span> rendering, this would cause a rerender, even though\n// the <span class=\"type\">name</span> <span class=\"keyword\">is</span> being <span class=\"keyword\">set</span> <span class=\"keyword\">to</span> the same <span class=\"keyword\">value</span> <span class=\"keyword\">as</span> it was <span class=\"keyword\">before</span>\nentry.name = entry.name;</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<p><code>tracked</code> can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:</p>\n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n7\n</pre></td>\n              <td class=\"code\"><pre><span class=\"keyword\">import</span> <span class=\"title class_\">EmberObject</span> <span class=\"keyword\">from</span> <span class=\"string\">'@ember/object'</span>;\n<span class=\"keyword\">import</span> { tracked } <span class=\"keyword\">from</span> <span class=\"string\">'@glimmer/tracking'</span>;\n\n<span class=\"keyword\">const</span> <span class=\"title class_\">Entry</span> = <span class=\"title class_\">EmberObject</span>.<span class=\"title function_\">extend</span>({\n  <span class=\"attr\">name</span>: <span class=\"title function_\">tracked</span>(),\n  <span class=\"attr\">phoneNumber</span>: <span class=\"title function_\">tracked</span>()\n});</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<p>Often this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.</p>\n<p>This form of <code>tracked</code> also accepts an optional configuration object\ncontaining either an initial <code>value</code> or an <code>initializer</code> function (but not\nboth).</p>\n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre></td>\n              <td class=\"code\"><pre><span class=\"keyword\">import</span> EmberObject <span class=\"keyword\">from</span> <span class=\"string\">'@ember/object'</span>;\n<span class=\"keyword\">import</span> { tracked } <span class=\"keyword\">from</span> <span class=\"string\">'@glimmer/tracking'</span>;\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: <span class=\"string\">'Zoey'</span> }),\n  favoriteSongs: tracked({\n    initializer: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [<span class=\"string\">'Raspberry Beret'</span>, <span class=\"string\">'Time After Time'</span>]\n  })\n});</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n</body></html>",
          "itemtype": "method",
          "name": "tracked",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        },
        {
          "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
          "line": 158,
          "description": "<html><head></head><body><p>Gives the getter a caching behavior. The return value of the getter\nwill be cached until any of the properties it is entangled with\nare invalidated. This is useful when a getter is expensive and\nused very often.</p>\n<p>For instance, in this <code>GuestList</code> class, we have the <code>sortedGuests</code>\ngetter that sorts the guests alphabetically:</p>\n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n</pre></td>\n              <td class=\"code\"><pre>  <span class=\"keyword\">import</span> { tracked } from <span class=\"string\">'@glimmer/tracking'</span>;\n\n  <span class=\"keyword\">class</span> <span class=\"title class_\">GuestList</span> {\n    <span class=\"meta\">@tracked</span> guests = [<span class=\"string\">'Zoey'</span>, <span class=\"string\">'Tomster'</span>];\n\n    <span class=\"keyword\">get</span> sortedGuests() {\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.guests.slice().sort()\n    }\n  }</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<p>Every time <code>sortedGuests</code> is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list\nis small, like the one in the example, this is not a problem. However, if\nthe guest list were to grow very large, it would mean that we would be doing\na large amount of work each time we accessed <code>sortedGuests</code>. With <code>@cached</code>,\nwe can cache the value instead:</p>\n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n</pre></td>\n              <td class=\"code\"><pre>  <span class=\"keyword\">import</span> { tracked, cached } from <span class=\"string\">'@glimmer/tracking'</span>;\n\n  <span class=\"keyword\">class</span> <span class=\"title class_\">GuestList</span> {\n    <span class=\"meta\">@tracked</span> guests = [<span class=\"string\">'Zoey'</span>, <span class=\"string\">'Tomster'</span>];\n\n    <span class=\"meta\">@cached</span>\n    <span class=\"keyword\">get</span> sortedGuests() {\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.guests.slice().sort()\n    }\n  }</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<p>Now the <code>sortedGuests</code> getter will be cached based on autotracking.\nIt will only rerun and create a new sorted array when the guests tracked\nproperty is updated.</p>\n<h3 id=\"tradeoffs\">Tradeoffs</h3>\n<p>Overuse is discouraged.</p>\n<p>In general, you should avoid using <code>@cached</code> unless you have confirmed that\nthe getter you are decorating is computationally expensive, since <code>@cached</code>\nadds a small amount of overhead to the getter.\nWhile the individual costs are small, a systematic use of the <code>@cached</code>\ndecorator can add up to a large impact overall in your app.\nMany getters and tracked properties are only accessed once during rendering,\nand then never rerendered, so adding <code>@cached</code> when unnecessary can\nnegatively impact performance.</p>\n<p>Also, <code>@cached</code> may rerun even if the values themselves have not changed,\nsince tracked properties will always invalidate.\nFor example updating an integer value from <code>5</code> to an other <code>5</code> will trigger\na rerun of the cached properties building from this integer.</p>\n<p>Avoiding a cache invalidation in this case is not something that can\nbe achieved on the <code>@cached</code> decorator itself, but rather when updating\nthe underlying tracked values, by applying some diff checking mechanisms:</p>\n<div class=\"highlight javascript\">\n      <div class=\"ribbon\"></div>\n      <div class=\"scroller\">\n        <table class=\"CodeRay\">\n          <tbody>\n            <tr>\n              <td class=\"line-numbers\"><pre>1\n2\n3\n</pre></td>\n              <td class=\"code\"><pre><span class=\"keyword\">if</span> (nextValue !== <span class=\"keyword\">this</span>.trackedProp) {\n  <span class=\"keyword\">this</span>.trackedProp = nextValue;\n}</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    \n<p>Here equal values won't update the property, therefore not triggering\nthe subsequent cache invalidations of the <code>@cached</code> properties who were\nusing this <code>trackedProp</code>.</p>\n<p>Remember that setting tracked data should only be done during initialization,\nor as the result of a user action. Setting tracked data during render\n(such as in a getter), is not supported.</p>\n</body></html>",
          "itemtype": "method",
          "name": "cached",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        },
        {
          "file": "packages/@ember/-internals/metal/lib/cached.ts",
          "line": 7,
          "decorator": "Gives the getter a caching behavior. The return value of the getter\n will be cached until any of the properties it is entangled with\n are invalidated. This is useful when a getter is expensive and\n used very often.\n\n For instance, in this `GuestList` class, we have the `sortedGuests`\n getter that sorts the guests alphabetically:\n\n ```javascript\n   import { tracked } from '---AT-PLACEHOLDER---glimmer/tracking';\n\n   class GuestList {\n     ---AT-PLACEHOLDER---tracked guests = ['Zoey', 'Tomster'];\n\n     get sortedGuests() {\n       return this.guests.slice().sort()\n     }\n   }\n ```\n\n Every time `sortedGuests` is accessed, a new array will be created and sorted,\n because JavaScript getters do not cache by default. When the guest list\n is small, like the one in the example, this is not a problem. However, if\n the guest list were to grow very large, it would mean that we would be doing\n a large amount of work each time we accessed `sortedGuests`. With `@cached`,\n we can cache the value instead:\n\n ```javascript\n   import { tracked, cached } from '---AT-PLACEHOLDER---glimmer/tracking';\n\n   class GuestList {\n     ---AT-PLACEHOLDER---tracked guests = ['Zoey', 'Tomster'];\n\n     ---AT-PLACEHOLDER---cached\n     get sortedGuests() {\n       return this.guests.slice().sort()\n     }\n   }\n ```\n\n Now the `sortedGuests` getter will be cached based on autotracking.\n It will only rerun and create a new sorted array when the guests tracked\n property is updated.\n\n\n ### Tradeoffs\n\n Overuse is discouraged.\n\n In general, you should avoid using `@cached` unless you have confirmed that\n the getter you are decorating is computationally expensive, since `@cached`\n adds a small amount of overhead to the getter.\n While the individual costs are small, a systematic use of the `@cached`\n decorator can add up to a large impact overall in your app.\n Many getters and tracked properties are only accessed once during rendering,\n and then never rerendered, so adding `@cached` when unnecessary can\n negatively impact performance.\n\n Also, `@cached` may rerun even if the values themselves have not changed,\n since tracked properties will always invalidate.\n For example updating an integer value from `5` to an other `5` will trigger\n a rerun of the cached properties building from this integer.\n\n Avoiding a cache invalidation in this case is not something that can\n be achieved on the `@cached` decorator itself, but rather when updating\n the underlying tracked values, by applying some diff checking mechanisms:\n\n ```javascript\n if (nextValue !== this.trackedProp) {\n   this.trackedProp = nextValue;\n }\n ```\n\n Here equal values won't update the property, therefore not triggering\n the subsequent cache invalidations of the `@cached` properties who were\n using this `trackedProp`.\n\n Remember that setting tracked data should only be done during initialization, \n or as the result of a user action. Setting tracked data during render\n (such as in a getter), is not supported.",
          "itemtype": "method",
          "name": "cached",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking/primitives/cache"
        }
      ],
      "events": [],
      "properties": []
    },
    "relationships": {
      "parent-class": {
        "data": null
      },
      "descendants": {
        "data": []
      },
      "module": {
        "data": {
          "id": "ember-5.8.0-@glimmer/tracking",
          "type": "module"
        }
      },
      "project-version": {
        "data": {
          "id": "ember-5.8.0",
          "type": "project-version"
        }
      }
    }
  }
}