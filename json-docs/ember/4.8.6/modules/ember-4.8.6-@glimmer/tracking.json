{
  "data": {
    "id": "ember-4.8.6-@glimmer/tracking",
    "type": "module",
    "attributes": {
      "name": "@glimmer/tracking",
      "submodules": {},
      "elements": {},
      "fors": {
        "@glimmer/tracking": 1
      },
      "namespaces": {},
      "tag": "module",
      "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
      "line": 1,
      "description": "In order to tell Ember a value might change, we need to mark it as trackable.\nTrackable values are values that:\n\n- Can change over their componentâ€™s lifetime and\n- Should cause Ember to rerender if and when they change\n\nWe can do this by marking the field with the `@tracked` decorator.\n\n### Caching a getter value\n\nThe `@cached` decorator can be used on getters in order to cache the\nreturn value of the getter.\n\nThis method adds an extra overhead to each memoized getter, therefore caching\nthe values should not be the default strategy, but used in last resort.",
      "access": "public",
      "tagname": "",
      "parent": null,
      "publicclasses": [],
      "privateclasses": [],
      "staticfunctions": {
        "@glimmer/tracking": [
          {
            "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
            "line": 158,
            "description": "Gives the getter a caching behavior. The return value of the getter\nwill be cached until any of the properties it is entangled with\nare invalidated. This is useful when a getter is expensive and\nused very often.\n\nFor instance, in this GuestList class, we have the sortedGuests\ngetter that sorts the guests alphabetically:\n\n```javascript\n  import { tracked } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nEvery time sortedGuests is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list\nis small, like the one in the example, this is not a problem. However, if\nthe guest list were to grow very large, it would mean that we would be doing\na large amount of work each time we accessed sortedGetters. With @cached,\nwe can cache the value instead:\n\n```javascript\n  import { tracked, cached } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    @cached\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nNow the sortedGuests getter will be cached based on autotracking.\nIt will only rerun and create a new sorted array when the guests tracked\nproperty is updated.\n\n### Tradeoffs\n\nOveruse is discouraged.\n\nIn general, you should avoid using `@cached` unless you have confirmed that\nthe getter you are decorating is computationally expensive. `@cached` adds\na small amount of overhead to the getter, making it more expensive.\nWhile this overhead is small, if `@cached` is overused it can add up to a\nlarge impact overall in your app. Many getters and tracked properties\nare only accessed once, rendered, and then never rerendered, so adding\n`@cached` when it is unnecessary can negatively impact performance.\n\nAlso, `@cached` may rerun even if the values themselves have not changed,\nsince tracked properties will always invalidate even if their underlying\nvalue did not change.\nFor example updating an integer value from `5` to an other `5`.\n\nAvoiding a cache invalidation in this case is not something that can\nbe achieved on the `@cached` decorator itself, but rather when updating\nthe underlying values, by applying a diff checking mecanism:\n\n```javascript\nif (newValue !== this.trackedProp) {\n  this.trackedProp = newValue;\n}\n```\n\nHere equal values won't update the property, therefore not triggering a\ncache invalidation.\n\nThe cost of these edge-guards adds up to the tradoff calculation of using\na caching strategy, hence requiring a very sensitive approach regarding\nperformance.",
            "itemtype": "method",
            "name": "cached",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          },
          {
            "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
            "line": 22,
            "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\n\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
            "itemtype": "method",
            "name": "tracked",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          }
        ]
      },
      "allstaticfunctions": {
        "@glimmer/tracking": [
          {
            "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
            "line": 158,
            "description": "Gives the getter a caching behavior. The return value of the getter\nwill be cached until any of the properties it is entangled with\nare invalidated. This is useful when a getter is expensive and\nused very often.\n\nFor instance, in this GuestList class, we have the sortedGuests\ngetter that sorts the guests alphabetically:\n\n```javascript\n  import { tracked } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nEvery time sortedGuests is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list\nis small, like the one in the example, this is not a problem. However, if\nthe guest list were to grow very large, it would mean that we would be doing\na large amount of work each time we accessed sortedGetters. With @cached,\nwe can cache the value instead:\n\n```javascript\n  import { tracked, cached } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    @cached\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nNow the sortedGuests getter will be cached based on autotracking.\nIt will only rerun and create a new sorted array when the guests tracked\nproperty is updated.\n\n### Tradeoffs\n\nOveruse is discouraged.\n\nIn general, you should avoid using `@cached` unless you have confirmed that\nthe getter you are decorating is computationally expensive. `@cached` adds\na small amount of overhead to the getter, making it more expensive.\nWhile this overhead is small, if `@cached` is overused it can add up to a\nlarge impact overall in your app. Many getters and tracked properties\nare only accessed once, rendered, and then never rerendered, so adding\n`@cached` when it is unnecessary can negatively impact performance.\n\nAlso, `@cached` may rerun even if the values themselves have not changed,\nsince tracked properties will always invalidate even if their underlying\nvalue did not change.\nFor example updating an integer value from `5` to an other `5`.\n\nAvoiding a cache invalidation in this case is not something that can\nbe achieved on the `@cached` decorator itself, but rather when updating\nthe underlying values, by applying a diff checking mecanism:\n\n```javascript\nif (newValue !== this.trackedProp) {\n  this.trackedProp = newValue;\n}\n```\n\nHere equal values won't update the property, therefore not triggering a\ncache invalidation.\n\nThe cost of these edge-guards adds up to the tradoff calculation of using\na caching strategy, hence requiring a very sensitive approach regarding\nperformance.",
            "itemtype": "method",
            "name": "cached",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          },
          {
            "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
            "line": 22,
            "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\n\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
            "itemtype": "method",
            "name": "tracked",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          }
        ]
      },
      "version": "4.8.6"
    },
    "relationships": {
      "classes": {
        "data": []
      },
      "project-version": {
        "data": {
          "id": "ember-4.8.6",
          "type": "project-version"
        }
      }
    }
  }
}