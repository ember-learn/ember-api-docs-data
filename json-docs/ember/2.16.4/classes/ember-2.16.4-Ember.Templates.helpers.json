{
  "data": {
    "id": "ember-2.16.4-Ember.Templates.helpers",
    "type": "class",
    "attributes": {
      "name": "Ember.Templates.helpers",
      "shortname": "Ember.Templates.helpers",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "ember",
      "namespace": "",
      "file": "packages/ember-glimmer/lib/index.js",
      "line": 80,
      "methods": [
        {
          "file": "packages/ember-glimmer/lib/components/link-to.js",
          "line": 5,
          "description": "The `{{link-to}}` component renders a link to the supplied\n`routeName` passing an optionally supplied model to the\nroute as its `model` context of the route. The block\nfor `{{link-to}}` becomes the innerHTML of the rendered\nelement:\n\n```handlebars\n{{#link-to 'photoGallery'}}\n  Great Hamster Photos\n{{/link-to}}\n```\n\nYou can also use an inline form of `{{link-to}}` component by\npassing the link text as the first argument\nto the component:\n\n```handlebars\n{{link-to 'Great Hamster Photos' 'photoGallery'}}\n```\n\nBoth will result in:\n\n```html\n<a href=\"/hamster-photos\">\n  Great Hamster Photos\n</a>\n```\n\n### Supplying a tagName\nBy default `{{link-to}}` renders an `<a>` element. This can\nbe overridden for a single use of `{{link-to}}` by supplying\na `tagName` option:\n\n```handlebars\n{{#link-to 'photoGallery' tagName=\"li\"}}\n  Great Hamster Photos\n{{/link-to}}\n```\n\n```html\n<li>\n  Great Hamster Photos\n</li>\n```\n\nTo override this option for your entire application, see\n\"Overriding Application-wide Defaults\".\n\n### Disabling the `link-to` component\nBy default `{{link-to}}` is enabled.\nany passed value to the `disabled` component property will disable\nthe `link-to` component.\n\nstatic use: the `disabled` option:\n\n```handlebars\n{{#link-to 'photoGallery' disabled=true}}\n  Great Hamster Photos\n{{/link-to}}\n```\n\ndynamic use: the `disabledWhen` option:\n\n```handlebars\n{{#link-to 'photoGallery' disabledWhen=controller.someProperty}}\n  Great Hamster Photos\n{{/link-to}}\n```\n\nany passed value to `disabled` will disable it except `undefined`.\nto ensure that only `true` disable the `link-to` component you can\noverride the global behavior of `LinkComponent`.\n\n```javascript\nimport LinkComponent from '@ember/routing/link-component';\nimport { computed } from '@ember/object';\n\nLinkComponent.reopen({\n  disabled: computed(function(key, value) {\n    if (value !== undefined) {\n      this.set('_isDisabled', value === true);\n    }\n    return value === true ? get(this, 'disabledClass') : false;\n  })\n});\n```\n\nsee \"Overriding Application-wide Defaults\" for more.\n\n### Handling `href`\n`{{link-to}}` will use your application's Router to\nfill the element's `href` property with a url that\nmatches the path to the supplied `routeName` for your\nrouter's configured `Location` scheme, which defaults\nto HashLocation.\n\n### Handling current route\n`{{link-to}}` will apply a CSS class name of 'active'\nwhen the application's current route matches\nthe supplied routeName. For example, if the application's\ncurrent route is 'photoGallery.recent' the following\nuse of `{{link-to}}`:\n\n```handlebars\n{{#link-to 'photoGallery.recent'}}\n  Great Hamster Photos\n{{/link-to}}\n```\n\nwill result in\n\n```html\n<a href=\"/hamster-photos/this-week\" class=\"active\">\n  Great Hamster Photos\n</a>\n```\n\nThe CSS class name used for active classes can be customized\nfor a single use of `{{link-to}}` by passing an `activeClass`\noption:\n\n```handlebars\n{{#link-to 'photoGallery.recent' activeClass=\"current-url\"}}\n  Great Hamster Photos\n{{/link-to}}\n```\n\n```html\n<a href=\"/hamster-photos/this-week\" class=\"current-url\">\n  Great Hamster Photos\n</a>\n```\n\nTo override this option for your entire application, see\n\"Overriding Application-wide Defaults\".\n\n### Keeping a link active for other routes\n\nIf you need a link to be 'active' even when it doesn't match\nthe current route, you can use the `current-when` argument.\n\n```handlebars\n{{#link-to 'photoGallery' current-when='photos'}}\n  Photo Gallery\n{{/link-to}}\n```\n\nThis may be helpful for keeping links active for:\n\n* non-nested routes that are logically related\n* some secondary menu approaches\n* 'top navigation' with 'sub navigation' scenarios\n\nA link will be active if `current-when` is `true` or the current\nroute is the route this link would transition to.\n\nTo match multiple routes 'space-separate' the routes:\n\n```handlebars\n{{#link-to 'gallery' current-when='photos drawings paintings'}}\n  Art Gallery\n{{/link-to}}\n```\n\n### Supplying a model\nAn optional model argument can be used for routes whose\npaths contain dynamic segments. This argument will become\nthe model context of the linked route:\n\n```javascript\nRouter.map(function() {\n  this.route(\"photoGallery\", {path: \"hamster-photos/:photo_id\"});\n});\n```\n\n```handlebars\n{{#link-to 'photoGallery' aPhoto}}\n  {{aPhoto.title}}\n{{/link-to}}\n```\n\n```html\n<a href=\"/hamster-photos/42\">\n  Tomster\n</a>\n```\n\n### Supplying multiple models\nFor deep-linking to route paths that contain multiple\ndynamic segments, multiple model arguments can be used.\nAs the router transitions through the route path, each\nsupplied model argument will become the context for the\nroute with the dynamic segments:\n\n```javascript\nRouter.map(function() {\n  this.route(\"photoGallery\", { path: \"hamster-photos/:photo_id\" }, function() {\n    this.route(\"comment\", {path: \"comments/:comment_id\"});\n  });\n});\n```\nThis argument will become the model context of the linked route:\n\n```handlebars\n{{#link-to 'photoGallery.comment' aPhoto comment}}\n  {{comment.body}}\n{{/link-to}}\n```\n\n```html\n<a href=\"/hamster-photos/42/comments/718\">\n  A+++ would snuggle again.\n</a>\n```\n\n### Supplying an explicit dynamic segment value\nIf you don't have a model object available to pass to `{{link-to}}`,\nan optional string or integer argument can be passed for routes whose\npaths contain dynamic segments. This argument will become the value\nof the dynamic segment:\n\n```javascript\nRouter.map(function() {\n  this.route(\"photoGallery\", { path: \"hamster-photos/:photo_id\" });\n});\n```\n\n```handlebars\n{{#link-to 'photoGallery' aPhotoId}}\n  {{aPhoto.title}}\n{{/link-to}}\n```\n\n```html\n<a href=\"/hamster-photos/42\">\n  Tomster\n</a>\n```\n\nWhen transitioning into the linked route, the `model` hook will\nbe triggered with parameters including this passed identifier.\n\n### Allowing Default Action\n\nBy default the `{{link-to}}` component prevents the default browser action\nby calling `preventDefault()` as this sort of action bubbling is normally\nhandled internally and we do not want to take the browser to a new URL (for\nexample).\n\nIf you need to override this behavior specify `preventDefault=false` in\nyour template:\n\n```handlebars\n{{#link-to 'photoGallery' aPhotoId preventDefault=false}}\n  {{aPhotoId.title}}\n{{/link-to}}\n```\n\n### Overriding attributes\nYou can override any given property of the `LinkComponent`\nthat is generated by the `{{link-to}}` component by passing\nkey/value pairs, like so:\n\n```handlebars\n{{#link-to  aPhoto tagName='li' title='Following this link will change your life' classNames='pic sweet'}}\n  Uh-mazing!\n{{/link-to}}\n```\n\nSee [LinkComponent](/api/classes/Ember.LinkComponent.html) for a\ncomplete list of overrideable properties. Be sure to also\ncheck out inherited properties of `LinkComponent`.\n\n### Overriding Application-wide Defaults\n``{{link-to}}`` creates an instance of `LinkComponent`\nfor rendering. To override options for your entire\napplication, reopen `LinkComponent` and supply the\ndesired values:\n\n``` javascript\nimport LinkComponent from '@ember/routing/link-component';\n\nLinkComponent.reopen({\n  activeClass: \"is-active\",\n  tagName: 'li'\n})\n```\n\nIt is also possible to override the default event in\nthis manner:\n\n``` javascript\nimport LinkCompoennt from '@ember/routing/link-component';\n\nLinkComponent.reopen({\n  eventName: 'customEventName'\n});\n```",
          "itemtype": "method",
          "name": "link-to",
          "params": [
            {
              "name": "routeName",
              "description": "",
              "type": "String"
            },
            {
              "name": "context",
              "description": "",
              "type": "Object",
              "optional": true,
              "multiple": true
            },
            {
              "name": "options",
              "description": "Handlebars key/value pairs of options, you can override any property of Ember.LinkComponent",
              "type": "Object",
              "optional": true
            }
          ],
          "return": {
            "description": "HTML string",
            "type": "String"
          },
          "see": [
            "{LinkComponent}"
          ],
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/components/text_area.js",
          "line": 8,
          "description": "`{{textarea}}` inserts a new instance of `<textarea>` tag into the template.\nThe attributes of `{{textarea}}` match those of the native HTML tags as\nclosely as possible.\n\nThe following HTML attributes can be set:\n\n  * `value`\n  * `name`\n  * `rows`\n  * `cols`\n  * `placeholder`\n  * `disabled`\n  * `maxlength`\n  * `tabindex`\n  * `selectionEnd`\n  * `selectionStart`\n  * `selectionDirection`\n  * `wrap`\n  * `readonly`\n  * `autofocus`\n  * `form`\n  * `spellcheck`\n  * `required`\n\nWhen set to a quoted string, these value will be directly applied to the HTML\nelement. When left unquoted, these values will be bound to a property on the\ntemplate's current rendering context (most typically a controller instance).\n\nUnbound:\n\n```handlebars\n{{textarea value=\"Lots of static text that ISN'T bound\"}}\n```\n\nWould result in the following HTML:\n\n```html\n<textarea class=\"ember-text-area\">\n  Lots of static text that ISN'T bound\n</textarea>\n```\n\nBound:\n\nIn the following example, the `writtenWords` property on the application\nController will be updated live as the user types 'Lots of text that IS\nbound' into the text area of their browser's window.\n\n```js {data-filename=app/controllers/application.js}\nimport Controller from '@ember/controller';\n\nexport default Controller.extend({\n  writtenWords: \"Lots of text that IS bound\"\n});\n```\n\n```handlebars\n{{textarea value=writtenWords}}\n```\n\nWould result in the following HTML:\n\n```html\n<textarea class=\"ember-text-area\">\n  Lots of text that IS bound\n</textarea>\n```\n\nIf you wanted a one way binding between the text area and a div tag\nsomewhere else on your screen, you could use `oneWay`:\n\n```js {data-filename=app/controllers/application.js}\nimport Controller from '@ember/controller';\nimport { oneWay } from '@ember/object/computed';\n\nexport default Controller.extend({\n  writtenWords: \"Lots of text that IS bound\",\n\n  outputWrittenWords: oneWay(\"writtenWords\")\n});\n```\n\n```handlebars\n{{textarea value=writtenWords}}\n<div>\n  {{outputWrittenWords}}\n</div>\n```\n\nWould result in the following HTML:\n\n```html\n<textarea class=\"ember-text-area\">\n  Lots of text that IS bound\n</textarea>\n<-- the following div will be updated in real time as you type -->\n<div>\n  Lots of text that IS bound\n</div>\n```\n\nFinally, this example really shows the power and ease of Ember when two\nproperties are bound to eachother via `alias`. Type into\neither text area box and they'll both stay in sync. Note that\n`alias` costs more in terms of performance, so only use it when\nyour really binding in both directions:\n\n```js {data-filename=app/controllers/application.js}\nimport Controller from '@ember/controller';\nimport { alias } from '@ember/object/computed';\n\nexport default Controller.extend({\n  writtenWords: \"Lots of text that IS bound\",\n\n  twoWayWrittenWords: alias(\"writtenWords\")\n});\n```\n\n```handlebars\n{{textarea value=writtenWords}}\n{{textarea value=twoWayWrittenWords}}\n```\n\n```html\n<textarea id=\"ember1\" class=\"ember-text-area\">\n  Lots of text that IS bound\n</textarea>\n<-- both updated in real time -->\n<textarea id=\"ember2\" class=\"ember-text-area\">\n  Lots of text that IS bound\n</textarea>\n```\n\n### Actions\n\nThe helper can send multiple actions based on user events.\nThe action property defines the action which is send when\nthe user presses the return key.\n\n```handlebars\n{{input action=\"submit\"}}\n```\n\nThe helper allows some user events to send actions.\n\n* `enter`\n* `insert-newline`\n* `escape-press`\n* `focus-in`\n* `focus-out`\n* `key-press`\n\nFor example, if you desire an action to be sent when the input is blurred,\nyou only need to setup the action name to the event name property.\n\n```handlebars\n{{textarea focus-out=\"alertMessage\"}}\n```\n\nSee more about [Text Support Actions](/api/classes/Ember.TextArea.html)\n\n### Extension\n\nInternally, `{{textarea}}` creates an instance of `TextArea`, passing\narguments from the helper to `TextArea`'s `create` method. You can\nextend the capabilities of text areas in your application by reopening this\nclass. For example, if you are building a Bootstrap project where `data-*`\nattributes are used, you can globally add support for a `data-*` attribute\non all `{{textarea}}`s' in your app by reopening `TextArea` or\n`TextSupport` and adding it to the `attributeBindings` concatenated\nproperty:\n\n```javascript\nimport TextArea from '@ember/component/text-area';\n\nTextArea.reopen({\n  attributeBindings: ['data-error']\n});\n```\n\nKeep in mind when writing `TextArea` subclasses that `TextArea`\nitself extends `Component`. Expect isolated component semantics, not\nlegacy 1.x view semantics (like `controller` being present).\n\nSee more about [Ember components](/api/classes/Ember.Component.html)",
          "itemtype": "method",
          "name": "textarea",
          "params": [
            {
              "name": "options",
              "description": "",
              "type": "Hash"
            }
          ],
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "@ember/component"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/action.js",
          "line": 19,
          "description": "The `{{action}}` helper provides a way to pass triggers for behavior (usually\njust a function) between components, and into components from controllers.\n\n### Passing functions with the action helper\n\nThere are three contexts an action helper can be used in. The first two\ncontexts to discuss are attribute context, and Handlebars value context.\n\n```handlebars\n{{! An example of attribute context }}\n<div onclick={{action \"save\"}}></div>\n{{! Examples of Handlebars value context }}\n{{input on-input=(action \"save\")}}\n{{yield (action \"refreshData\") andAnotherParam}}\n```\n\nIn these contexts,\nthe helper is called a \"closure action\" helper. Its behavior is simple:\nIf passed a function name, read that function off the `actions` property\nof the current context. Once that function is read (or if a function was\npassed), create a closure over that function and any arguments.\nThe resulting value of an action helper used this way is simply a function.\n\nFor example, in the attribute context:\n\n```handlebars\n{{! An example of attribute context }}\n<div onclick={{action \"save\"}}></div>\n```\n\nThe resulting template render logic would be:\n\n```js\nvar div = document.createElement('div');\nvar actionFunction = (function(context){\n  return function() {\n    return context.actions.save.apply(context, arguments);\n  };\n})(context);\ndiv.onclick = actionFunction;\n```\n\nThus when the div is clicked, the action on that context is called.\nBecause the `actionFunction` is just a function, closure actions can be\npassed between components and still execute in the correct context.\n\nHere is an example action handler on a component:\n\n```js {data-filename=app/components/my-component.js}\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  actions: {\n    save() {\n      this.get('model').save();\n    }\n  }\n});\n```\n\nActions are always looked up on the `actions` property of the current context.\nThis avoids collisions in the naming of common actions, such as `destroy`.\nTwo options can be passed to the `action` helper when it is used in this way.\n\n* `target=someProperty` will look to `someProperty` instead of the current\n  context for the `actions` hash. This can be useful when targeting a\n  service for actions.\n* `value=\"target.value\"` will read the path `target.value` off the first\n  argument to the action when it is called and rewrite the first argument\n  to be that value. This is useful when attaching actions to event listeners.\n\n### Invoking an action\n\nClosure actions curry both their scope and any arguments. When invoked, any\nadditional arguments are added to the already curried list.\nActions should be invoked using the [sendAction](/api/classes/Ember.Component.html#method_sendAction)\nmethod. The first argument to `sendAction` is the action to be called, and\nadditional arguments are passed to the action function. This has interesting\nproperties combined with currying of arguments. For example:\n\n```js {data-filename=app/components/my-component.js}\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  actions: {\n    // Usage {{input on-input=(action (action 'setName' model) value=\"target.value\")}}\n    setName(model, name) {\n      model.set('name', name);\n    }\n  }\n});\n```\n\nThe first argument (`model`) was curried over, and the run-time argument (`event`)\nbecomes a second argument. Action calls can be nested this way because each simply\nreturns a function. Any function can be passed to the `{{action}}` helper, including\nother actions.\n\nActions invoked with `sendAction` have the same currying behavior as demonstrated\nwith `on-input` above. For example:\n\n```js {data-filename=app/components/my-input.js}\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  actions: {\n    setName(model, name) {\n      model.set('name', name);\n    }\n  }\n});\n```\n\n```handlebars\n{{my-input submit=(action 'setName' model)}}\n```\n\n```js {data-filename=app/components/my-component.js}\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  click() {\n    // Note that model is not passed, it was curried in the template\n    this.sendAction('submit', 'bob');\n  }\n});\n```\n\n### Attaching actions to DOM elements\n\nThe third context of the `{{action}}` helper can be called \"element space\".\nFor example:\n\n```handlebars\n{{! An example of element space }}\n<div {{action \"save\"}}></div>\n```\n\nUsed this way, the `{{action}}` helper provides a useful shortcut for\nregistering an HTML element in a template for a single DOM event and\nforwarding that interaction to the template's context (controller or component).\nIf the context of a template is a controller, actions used this way will\nbubble to routes when the controller does not implement the specified action.\nOnce an action hits a route, it will bubble through the route hierarchy.\n\n### Event Propagation\n\n`{{action}}` helpers called in element space can control event bubbling. Note\nthat the closure style actions cannot.\n\nEvents triggered through the action helper will automatically have\n`.preventDefault()` called on them. You do not need to do so in your event\nhandlers. If you need to allow event propagation (to handle file inputs for\nexample) you can supply the `preventDefault=false` option to the `{{action}}` helper:\n\n```handlebars\n<div {{action \"sayHello\" preventDefault=false}}>\n  <input type=\"file\" />\n  <input type=\"checkbox\" />\n</div>\n```\n\nTo disable bubbling, pass `bubbles=false` to the helper:\n\n```handlebars\n<button {{action 'edit' post bubbles=false}}>Edit</button>\n```\n\nTo disable bubbling with closure style actions you must create your own\nwrapper helper that makes use of `event.stopPropagation()`:\n\n```handlebars\n<div onclick={{disable-bubbling (action \"sayHello\")}}>Hello</div>\n```\n\n```js {data-filename=app/helpers/disable-bubbling.js}\nimport { helper } from '@ember/component/helper';\n\nexport function disableBubbling([action]) {\n  return function(event) {\n    event.stopPropagation();\n    return action(event);\n  };\n}\nexport default helper(disableBubbling);\n```\n\nIf you need the default handler to trigger you should either register your\nown event handler, or use event methods on your view class. See\n[\"Responding to Browser Events\"](/api/classes/Ember.Component#responding-to-browser-events)\nin the documentation for `Component` for more information.\n\n### Specifying DOM event type\n\n`{{action}}` helpers called in element space can specify an event type.\nBy default the `{{action}}` helper registers for DOM `click` events. You can\nsupply an `on` option to the helper to specify a different DOM event name:\n\n```handlebars\n<div {{action \"anActionName\" on=\"doubleClick\"}}>\n  click me\n</div>\n```\n\nSee [\"Event Names\"](/api/classes/Ember.Component#event-names) for a list of\nacceptable DOM event names.\n\n### Specifying whitelisted modifier keys\n\n`{{action}}` helpers called in element space can specify modifier keys.\nBy default the `{{action}}` helper will ignore click events with pressed modifier\nkeys. You can supply an `allowedKeys` option to specify which keys should not be ignored.\n\n```handlebars\n<div {{action \"anActionName\" allowedKeys=\"alt\"}}>\n  click me\n</div>\n```\n\nThis way the action will fire when clicking with the alt key pressed down.\nAlternatively, supply \"any\" to the `allowedKeys` option to accept any combination of modifier keys.\n\n```handlebars\n<div {{action \"anActionName\" allowedKeys=\"any\"}}>\n  click me with any key pressed\n</div>\n```\n\n### Specifying a Target\n\nA `target` option can be provided to the helper to change\nwhich object will receive the method call. This option must be a path\nto an object, accessible in the current context:\n\n```handlebars {data-filename=app/templates/application.hbs}\n<div {{action \"anActionName\" target=someService}}>\n  click me\n</div>\n```\n\n```js {data-filename=app/controllers/application.js}\nimport Controller from '@ember/controller';\nimport { inject as service } from '@ember/service';\n\nexport default Controller.extend({\n  someService: service()\n});\n```",
          "itemtype": "method",
          "name": "action",
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/component.js",
          "line": 17,
          "description": "The `{{component}}` helper lets you add instances of `Component` to a\ntemplate. See [Component](/api/classes/Ember.Component.html) for\nadditional information on how a `Component` functions.\n`{{component}}`'s primary use is for cases where you want to dynamically\nchange which type of component is rendered as the state of your application\nchanges. This helper has three modes: inline, block, and nested.\n\n### Inline Form\n\nGiven the following template:\n\n```handlebars {data-filename=app/application.hbs}\n{{component infographicComponentName}}\n```\n\nAnd the following application code:\n\n```js {data-filename=app/controllers/application.js}\nimport Controller from '@ember/controller';\nimport { computed } from '@ember/object';\n\nexport default Controller.extend({\n  infographicComponentName: computed('isMarketOpen', {\n    get() {\n      if (this.get('isMarketOpen')) {\n        return 'live-updating-chart';\n      } else {\n        return 'market-close-summary';\n      }\n    }\n  })\n});\n```\n\nThe `live-updating-chart` component will be appended when `isMarketOpen` is\n`true`, and the `market-close-summary` component will be appended when\n`isMarketOpen` is `false`. If the value changes while the app is running,\nthe component will be automatically swapped out accordingly.\nNote: You should not use this helper when you are consistently rendering the same\ncomponent. In that case, use standard component syntax, for example:\n\n```handlebars {data-filename=app/templates/application.hbs}\n{{live-updating-chart}}\n```\n\n### Block Form\n\nUsing the block form of this helper is similar to using the block form\nof a component. Given the following application template:\n\n```handlebars {data-filename=app/templates/application.hbs}\n{{#component infographicComponentName}}\n  Last update: {{lastUpdateTimestamp}}\n{{/component}}\n```\n\nThe following controller code:\n\n```js {data-filename=app/controllers/application.js}\nimport Controller from '@ember/controller';\nimport { computed } from '@ember/object';\n\nexport default Controller.extend({\n  lastUpdateTimestamp: computed(function() {\n    return new Date();\n  }),\n\n  infographicComponentName: computed('isMarketOpen', {\n    get() {\n      if (this.get('isMarketOpen')) {\n        return 'live-updating-chart';\n      } else {\n        return 'market-close-summary';\n      }\n    }\n  })\n});\n```\n\nAnd the following component template:\n\n```handlebars {data-filename=app/templates/components/live-updating-chart.hbs}\n{{! chart }}\n{{yield}}\n```\n\nThe `Last Update: {{lastUpdateTimestamp}}` will be rendered in place of the `{{yield}}`.\n\n### Nested Usage\n\nThe `component` helper can be used to package a component path with initial attrs.\nThe included attrs can then be merged during the final invocation.\nFor example, given a `person-form` component with the following template:\n\n```handlebars {data-filename=app/templates/components/person-form.hbs}\n{{yield (hash\n  nameInput=(component \"my-input-component\" value=model.name placeholder=\"First Name\")\n)}}\n```\n\nWhen yielding the component via the `hash` helper, the component is invoked directly.\nSee the following snippet:\n\n```\n{{#person-form as |form|}}\n  {{form.nameInput placeholder=\"Username\"}}\n{{/person-form}}\n```\n\nWhich outputs an input whose value is already bound to `model.name` and `placeholder`\nis \"Username\".\n\nWhen yielding the component without the hash helper use the `component` helper.\nFor example, below is a `full-name` component template:\n\n```handlebars\n{{yield (component \"my-input-component\" value=model.name placeholder=\"Name\")}}\n```\n\n```\n{{#full-name as |field|}}\n  {{component field placeholder=\"Full name\"}}\n{{/full-name}}\n```",
          "itemtype": "method",
          "name": "component",
          "since": "1.11.0",
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/concat.js",
          "line": 8,
          "description": "Concatenates the given arguments into a string.\n\nExample:\n\n```handlebars\n{{some-component name=(concat firstName \" \" lastName)}}\n\n{{! would pass name=\"<first name value> <last name value>\" to the component}}\n```",
          "access": "public",
          "tagname": "",
          "itemtype": "method",
          "name": "concat",
          "since": "1.13.0",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/each-in.js",
          "line": 6,
          "description": "The `{{#each}}` helper loops over elements in a collection. It is an extension\nof the base Handlebars `{{#each}}` helper.\nThe default behavior of `{{#each}}` is to yield its inner block once for every\nitem in an array passing the item as the first block parameter.\n\n```javascript\nvar developers = [{ name: 'Yehuda' },{ name: 'Tom' }, { name: 'Paul' }];\n```\n\n```handlebars\n{{#each developers key=\"name\" as |person|}}\n  {{person.name}}\n  {{! `this` is whatever it was outside the #each }}\n{{/each}}\n```\n\nThe same rules apply to arrays of primitives.\n\n```javascript\nvar developerNames = ['Yehuda', 'Tom', 'Paul']\n```\n\n```handlebars\n{{#each developerNames key=\"@index\" as |name|}}\n  {{name}}\n{{/each}}\n```\n\nDuring iteration, the index of each item in the array is provided as a second block parameter.\n\n```handlebars\n<ul>\n  {{#each people as |person index|}}\n    <li>Hello, {{person.name}}! You're number {{index}} in line</li>\n  {{/each}}\n</ul>\n```\n\n### Specifying Keys\n\nThe `key` option is used to tell Ember how to determine if the array being\niterated over with `{{#each}}` has changed between renders. By helping Ember\ndetect that some elements in the array are the same, DOM elements can be\nre-used, significantly improving rendering speed.\n\nFor example, here's the `{{#each}}` helper with its `key` set to `id`:\n\n```handlebars\n{{#each model key=\"id\" as |item|}}\n{{/each}}\n```\n\nWhen this `{{#each}}` re-renders, Ember will match up the previously rendered\nitems (and reorder the generated DOM elements) based on each item's `id`\nproperty.\nBy default the item's own reference is used.\n\n### {{else}} condition\n\n`{{#each}}` can have a matching `{{else}}`. The contents of this block will render\nif the collection is empty.\n\n```handlebars\n{{#each developers as |person|}}\n  {{person.name}}\n{{else}}\n  <p>Sorry, nobody is available for this task.</p>\n{{/each}}\n```",
          "itemtype": "method",
          "name": "each",
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/each-in.js",
          "line": 82,
          "description": "The `{{each-in}}` helper loops over properties on an object.\n\nFor example, given a `user` object that looks like:\n\n```javascript\n{\n  \"name\": \"Shelly Sails\",\n  \"age\": 42\n}\n```\n\nThis template would display all properties on the `user`\nobject in a list:\n\n```handlebars\n<ul>\n{{#each-in user as |key value|}}\n  <li>{{key}}: {{value}}</li>\n{{/each-in}}\n</ul>\n```\n\nOutputting their name and age.",
          "itemtype": "method",
          "name": "each-in",
          "access": "public",
          "tagname": "",
          "since": "2.1.0",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/get.js",
          "line": 15,
          "description": "Dynamically look up a property on an object. The second argument to `{{get}}`\nshould have a string value, although it can be bound.\n\nFor example, these two usages are equivalent:\n\n```handlebars\n{{person.height}}\n{{get person \"height\"}}\n```\n\nIf there were several facts about a person, the `{{get}}` helper can dynamically\npick one:\n\n```handlebars\n{{get person factName}}\n```\n\nFor a more complex example, this template would allow the user to switch\nbetween showing the user's height and weight with a click:\n\n```handlebars\n{{get person factName}}\n<button {{action (action (mut factName)) \"height\"}}>Show height</button>\n<button {{action (action (mut factName)) \"weight\"}}>Show weight</button>\n```\n\nThe `{{get}}` helper can also respect mutable values itself. For example:\n\n```handlebars\n{{input value=(mut (get person factName)) type=\"text\"}}\n<button {{action (action (mut factName)) \"height\"}}>Show height</button>\n<button {{action (action (mut factName)) \"weight\"}}>Show weight</button>\n```\n\nWould allow the user to swap what fact is being displayed, and also edit\nthat fact via a two-way mutable binding.",
          "access": "public",
          "tagname": "",
          "itemtype": "method",
          "name": "get",
          "since": "2.1.0",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/hash.js",
          "line": 5,
          "description": "Use the `{{hash}}` helper to create a hash to pass as an option to your\ncomponents. This is specially useful for contextual components where you can\njust yield a hash:\n\n```handlebars\n{{yield (hash\n   name='Sarah'\n   title=office\n)}}\n```\n\nWould result in an object such as:\n\n```js\n{ name: 'Sarah', title: this.get('office') }\n```\n\nWhere the `title` is bound to updates of the `office` property.\n\nNote that the hash is an empty object with no prototype chain, therefore\ncommon methods like `toString` are not available in the resulting hash.\nIf you need to use such a method, you can use the `call` or `apply`\napproach:\n\n```js\nfunction toString(obj) {\n  return Object.prototype.toString.apply(obj);\n}\n```",
          "itemtype": "method",
          "name": "hash",
          "params": [
            {
              "name": "options",
              "description": "",
              "type": "Object"
            }
          ],
          "return": {
            "description": "Hash",
            "type": "Object"
          },
          "since": "2.3.0",
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/if-unless.js",
          "line": 47,
          "description": "The `if` helper allows you to conditionally render one of two branches,\ndepending on the \"truthiness\" of a property.\nFor example the following values are all falsey: `false`, `undefined`, `null`, `\"\"`, `0`, `NaN` or an empty array.\n\nThis helper has two forms, block and inline.\n\n## Block form\n\nYou can use the block form of `if` to conditionally render a section of the template.\n\nTo use it, pass the conditional value to the `if` helper,\nusing the block form to wrap the section of template you want to conditionally render.\nLike so:\n\n```handlebars\n{{! will not render if foo is falsey}}\n{{#if foo}}\n  Welcome to the {{foo.bar}}\n{{/if}}\n```\n\nYou can also specify a template to show if the property is falsey by using\nthe `else` helper.\n\n```handlebars\n{{! is it raining outside?}}\n{{#if isRaining}}\n  Yes, grab an umbrella!\n{{else}}\n  No, it's lovely outside!\n{{/if}}\n```\n\nYou are also able to combine `else` and `if` helpers to create more complex\nconditional logic.\n\n```handlebars\n{{#if isMorning}}\n  Good morning\n{{else if isAfternoon}}\n  Good afternoon\n{{else}}\n  Good night\n{{/if}}\n```\n\n## Inline form\n\nThe inline `if` helper conditionally renders a single property or string.\n\nIn this form, the `if` helper receives three arguments, the conditional value,\nthe value to render when truthy, and the value to render when falsey.\n\nFor example, if `useLongGreeting` is truthy, the following:\n\n```handlebars\n{{if useLongGreeting \"Hello\" \"Hi\"}} Alex\n```\n\nWill render:\n\n```html\nHello Alex\n```\n\n### Nested `if`\n\nYou can use the `if` helper inside another helper as a nested helper:\n\n```handlebars\n{{some-component height=(if isBig \"100\" \"10\")}}\n```\n\nOne detail to keep in mind is that both branches of the `if` helper will be evaluated,\nso if you have `{{if condition \"foo\" (expensive-operation \"bar\")`,\n`expensive-operation` will always calculate.",
          "itemtype": "method",
          "name": "if",
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/if-unless.js",
          "line": 138,
          "description": "The inline `unless` helper conditionally renders a single property or string.\nThis helper acts like a ternary operator. If the first property is falsy,\nthe second argument will be displayed, otherwise, the third argument will be\ndisplayed\n\n```handlebars\n{{unless useLongGreeting \"Hi\" \"Hello\"}} Ben\n```\n\nYou can use the `unless` helper inside another helper as a subexpression.\n\n```handlebars\n{{some-component height=(unless isBig \"10\" \"100\")}}\n```",
          "itemtype": "method",
          "name": "unless",
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/loc.js",
          "line": 8,
          "description": "Calls [loc](/api/classes/Ember.String.html#method_loc) with the\nprovided string. This is a convenient way to localize text within a template.\nFor example:\n\n```javascript\nEmber.STRINGS = {\n  '_welcome_': 'Bonjour'\n};\n```\n\n```handlebars\n<div class='message'>\n  {{loc '_welcome_'}}\n</div>\n```\n\n```html\n<div class='message'>\n  Bonjour\n</div>\n```\n\nSee [Ember.String.loc](/api/classes/Ember.String.html#method_loc) for how to\nset up localized string references.",
          "itemtype": "method",
          "name": "loc",
          "params": [
            {
              "name": "str",
              "description": "The string to format.",
              "type": "String"
            }
          ],
          "see": [
            "{Ember.String#loc}"
          ],
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/log.js",
          "line": 8,
          "description": "`log` allows you to output the value of variables in the current rendering\ncontext. `log` also accepts primitive types such as strings or numbers.\n\n```handlebars\n{{log \"myVariable:\" myVariable }}\n```",
          "itemtype": "method",
          "name": "log",
          "params": [
            {
              "name": "params",
              "description": "",
              "type": "Array"
            }
          ],
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/mut.js",
          "line": 9,
          "description": "The `mut` helper lets you __clearly specify__ that a child `Component` can update the\n(mutable) value passed to it, which will __change the value of the parent component__.\n\nTo specify that a parameter is mutable, when invoking the child `Component`:\n\n```handlebars\n{{my-child childClickCount=(mut totalClicks)}}\n```\n\nThe child `Component` can then modify the parent's value just by modifying its own\nproperty:\n\n```javascript\n// my-child.js\nexport default Component.extend({\n  click() {\n    this.incrementProperty('childClickCount');\n  }\n});\n```\n\nNote that for curly components (`{{my-component}}`) the bindings are already mutable,\nmaking the `mut` unnecessary.\n\nAdditionally, the `mut` helper can be combined with the `action` helper to\nmutate a value. For example:\n\n```handlebars\n{{my-child childClickCount=totalClicks click-count-change=(action (mut totalClicks))}}\n```\n\nThe child `Component` would invoke the action with the new click value:\n\n```javascript\n// my-child.js\nexport default Component.extend({\n  click() {\n    this.get('click-count-change')(this.get('childClickCount') + 1);\n  }\n});\n```\n\nThe `mut` helper changes the `totalClicks` value to what was provided as the action argument.\n\nThe `mut` helper, when used with `action`, will return a function that\nsets the value passed to `mut` to its first argument. This works like any other\nclosure action and interacts with the other features `action` provides.\nAs an example, we can create a button that increments a value passing the value\ndirectly to the `action`:\n\n```handlebars\n{{! inc helper is not provided by Ember }}\n<button onclick={{action (mut count) (inc count)}}>\n  Increment count\n</button>\n```\n\nYou can also use the `value` option:\n\n```handlebars\n<input value={{name}} oninput={{action (mut name) value=\"target.value\"}}>\n```",
          "itemtype": "method",
          "name": "mut",
          "params": [
            {
              "name": "attr",
              "description": "the \"two-way\" attribute that can be modified.",
              "type": "Object",
              "optional": true
            }
          ],
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/query-param.js",
          "line": 9,
          "description": "This is a helper to be used in conjunction with the link-to helper.\nIt will supply url query parameters to the target route.\n\nExample\n\n```handlebars\n{{#link-to 'posts' (query-params direction=\"asc\")}}Sort{{/link-to}}\n```",
          "itemtype": "method",
          "name": "query-params",
          "params": [
            {
              "name": "hash",
              "description": "takes a hash of query parameters",
              "type": "Object"
            }
          ],
          "return": {
            "description": "A `QueryParams` object for `{{link-to}}`",
            "type": "Object"
          },
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/readonly.js",
          "line": 8,
          "description": "The `readonly` helper let's you specify that a binding is one-way only,\ninstead of two-way.\nWhen you pass a `readonly` binding from an outer context (e.g. parent component),\nto to an inner context (e.g. child component), you are saying that changing that\nproperty in the inner context does not change the value in the outer context.\n\nTo specify that a binding is read-only, when invoking the child `Component`:\n\n```js {data-filename=app/components/my-parent.js}\nexport default Component.extend({\n  totalClicks: 3\n});\n```\n\n```handlebars {data-filename=app/templates/components/my-parent.hbs}\n{{log totalClicks}} // -> 3\n{{my-child childClickCount=(readonly totalClicks)}}\n```\n\nNow, when you update `childClickCount`:\n\n```js {data-filename=app/components/my-child.js}\nexport default Component.extend({\n  click() {\n    this.incrementProperty('childClickCount');\n  }\n});\n```\n\nThe value updates in the child component, but not the parent component:\n\n```handlebars {data-filename=app/templates/components/my-child.hbs}\n{{log childClickCount}} //-> 4\n```\n\n```handlebars {data-filename=app/templates/components/my-parent.hbs}\n{{log totalClicks}} //-> 3\n{{my-child childClickCount=(readonly totalClicks)}}\n```\n\n### Objects and Arrays\n\nWhen passing a property that is a complex object (e.g. object, array) instead of a primitive object (e.g. number, string),\nonly the reference to the object is protected using the readonly helper.\nThis means that you can change properties of the object both on the parent component, as well as the child component.\nThe `readonly` binding behaves similar to the `const` keyword in JavaScript.\n\nLet's look at an example:\n\nFirst let's set up the parent component:\n\n```js {data-filename=app/components/my-parent.js}\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  clicks: null,\n\n  init() {\n    this._super(...arguments);\n    this.set('clicks', { total: 3 });\n  }\n});\n```\n\n```handlebars {data-filename=app/templates/components/my-parent.hbs}\n{{log clicks.total}} //-> 3\n{{my-child childClicks=(readonly clicks)}}\n```\n\nNow, if you update the `total` property of `childClicks`:\n\n```js {data-filename=app/components/my-child.js}\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  click() {\n    this.get('clicks').incrementProperty('total');\n  }\n});\n```\n\nYou will see the following happen:\n\n```handlebars {data-filename=app/templates/components/my-parent.hbs}\n{{log clicks.total}} //-> 4\n{{my-child childClicks=(readonly clicks)}}\n```\n\n```handlebars {data-filename=app/templates/components/my-child.hbs}\n{{log childClicks.total}} //-> 4\n```",
          "itemtype": "method",
          "name": "readonly",
          "params": [
            {
              "name": "attr",
              "description": "the read-only attribute.",
              "type": "Object",
              "optional": true
            }
          ],
          "access": "private",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/helpers/unbound.js",
          "line": 8,
          "description": "The `{{unbound}}` helper disconnects the one-way binding of a property,\nessentially freezing its value at the moment of rendering. For example,\nin this example the display of the variable `name` will not change even\nif it is set with a new value:\n\n```handlebars\n{{unbound name}}\n```\n\nLike any helper, the `unbound` helper can accept a nested helper expression.\nThis allows for custom helpers to be rendered unbound:\n\n```handlebars\n{{unbound (some-custom-helper)}}\n{{unbound (capitalize name)}}\n{{! You can use any helper, including unbound, in a nested expression }}\n{{capitalize (unbound name)}}\n```\n\nThe `unbound` helper only accepts a single argument, and it return an\nunbound value.",
          "itemtype": "method",
          "name": "unbound",
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/syntax/input.js",
          "line": 15,
          "description": "The `{{input}}` helper lets you create an HTML `<input />` component.\nIt causes an `TextField` component to be rendered.  For more info,\nsee the [TextField](/api/classes/Ember.TextField.html) docs and\nthe [templates guide](https://emberjs.com/guides/templates/input-helpers/).\n\n```handlebars\n{{input value=\"987\"}}\n```\n\nrenders as:\n\n```HTML\n<input type=\"text\" value=\"987\" />\n```\n\n### Text field\n\nIf no `type` option is specified, a default of type 'text' is used.\nMany of the standard HTML attributes may be passed to this helper.\n<table>\n  <tr><td>`readonly`</td><td>`required`</td><td>`autofocus`</td></tr>\n  <tr><td>`value`</td><td>`placeholder`</td><td>`disabled`</td></tr>\n  <tr><td>`size`</td><td>`tabindex`</td><td>`maxlength`</td></tr>\n  <tr><td>`name`</td><td>`min`</td><td>`max`</td></tr>\n  <tr><td>`pattern`</td><td>`accept`</td><td>`autocomplete`</td></tr>\n  <tr><td>`autosave`</td><td>`formaction`</td><td>`formenctype`</td></tr>\n  <tr><td>`formmethod`</td><td>`formnovalidate`</td><td>`formtarget`</td></tr>\n  <tr><td>`height`</td><td>`inputmode`</td><td>`multiple`</td></tr>\n  <tr><td>`step`</td><td>`width`</td><td>`form`</td></tr>\n  <tr><td>`selectionDirection`</td><td>`spellcheck`</td><td>&nbsp;</td></tr>\n</table>\nWhen set to a quoted string, these values will be directly applied to the HTML\nelement. When left unquoted, these values will be bound to a property on the\ntemplate's current rendering context (most typically a controller instance).\nA very common use of this helper is to bind the `value` of an input to an Object's attribute:\n\n```handlebars\nSearch:\n{{input value=searchWord}}\n```\n\nIn this example, the initial value in the `<input />` will be set to the value of `searchWord`.\nIf the user changes the text, the value of `searchWord` will also be updated.\n\n### Actions\n\nThe helper can send multiple actions based on user events.\nThe action property defines the action which is sent when\nthe user presses the return key.\n\n```handlebars\n{{input action=\"submit\"}}\n```\n\nThe helper allows some user events to send actions.\n\n* `enter`\n* `insert-newline`\n* `escape-press`\n* `focus-in`\n* `focus-out`\n* `key-press`\n* `key-up`\n\nFor example, if you desire an action to be sent when the input is blurred,\nyou only need to setup the action name to the event name property.\n\n```handlebars\n{{input focus-out=\"alertMessage\"}}\n```\nSee more about [Text Support Actions](/api/classes/Ember.TextField.html)\n\n### Extending `TextField`\n\nInternally, `{{input type=\"text\"}}` creates an instance of `TextField`, passing\narguments from the helper to `TextField`'s `create` method. You can extend the\ncapabilities of text inputs in your applications by reopening this class. For example,\nif you are building a Bootstrap project where `data-*` attributes are used, you\ncan add one to the `TextField`'s `attributeBindings` property:\n\n```javascript\nimport TextField from '@ember/component/text-field';\nTextField.reopen({\n  attributeBindings: ['data-error']\n});\n```\n\nKeep in mind when writing `TextField` subclasses that `TextField`\nitself extends `Component`. Expect isolated component semantics, not\nlegacy 1.x view semantics (like `controller` being present).\nSee more about [Ember components](/api/classes/Ember.Component.html)\n\n### Checkbox\n\nCheckboxes are special forms of the `{{input}}` helper.  To create a `<checkbox />`:\n\n```handlebars\nEmberize Everything:\n{{input type=\"checkbox\" name=\"isEmberized\" checked=isEmberized}}\n```\n\nThis will bind checked state of this checkbox to the value of `isEmberized`  -- if either one changes,\nit will be reflected in the other.\n\nThe following HTML attributes can be set via the helper:\n\n* `checked`\n* `disabled`\n* `tabindex`\n* `indeterminate`\n* `name`\n* `autofocus`\n* `form`\n\n### Extending `Checkbox`\n\nInternally, `{{input type=\"checkbox\"}}` creates an instance of `Checkbox`, passing\narguments from the helper to `Checkbox`'s `create` method. You can extend the\ncapablilties of checkbox inputs in your applications by reopening this class. For example,\nif you wanted to add a css class to all checkboxes in your application:\n\n```javascript\nimport Checkbox from '@ember/component/checkbox';\n\nCheckbox.reopen({\n  classNames: ['my-app-checkbox']\n});\n```",
          "itemtype": "method",
          "name": "input",
          "params": [
            {
              "name": "options",
              "description": "",
              "type": "Hash"
            }
          ],
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/syntax/mount.js",
          "line": 17,
          "description": "The `{{mount}}` helper lets you embed a routeless engine in a template.\nMounting an engine will cause an instance to be booted and its `application`\ntemplate to be rendered.\n\nFor example, the following template mounts the `ember-chat` engine:\n\n```handlebars\n{{! application.hbs }}\n{{mount \"ember-chat\"}}\n```\n\nAdditionally, you can also pass in a `model` argument that will be\nset as the engines model. This can be an existing object:\n\n```\n<div>\n  {{mount 'admin' model=userSettings}}\n</div>\n```\n\nOr an inline `hash`, and you can even pass components:\n\n```\n<div>\n  <h1>Application template!</h1>\n  {{mount 'admin' model=(hash\n      title='Secret Admin'\n      signInButton=(component 'sign-in-button')\n  )}}\n</div>\n```",
          "itemtype": "method",
          "name": "mount",
          "params": [
            {
              "name": "name",
              "description": "Name of the engine to mount.",
              "type": "String"
            },
            {
              "name": "model",
              "description": "Object that will be set as\n                        the model of the engine.",
              "type": "Object",
              "optional": true
            }
          ],
          "category": [
            "ember-application-engines"
          ],
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/syntax/outlet.js",
          "line": 73,
          "description": "The `{{outlet}}` helper lets you specify where a child route will render in\nyour template. An important use of the `{{outlet}}` helper is in your\napplication's `application.hbs` file:\n\n```handlebars\n{{! app/templates/application.hbs }}\n<!-- header content goes here, and will always display -->\n{{my-header}}\n<div class=\"my-dynamic-content\">\n  <!-- this content will change based on the current route, which depends on the current URL -->\n  {{outlet}}\n</div>\n<!-- footer content goes here, and will always display -->\n{{my-footer}}\n```\n\nSee [templates guide](https://emberjs.com/guides/templates/the-application-template/) for\nadditional information on using `{{outlet}}` in `application.hbs`.\nYou may also specify a name for the `{{outlet}}`, which is useful when using more than one\n`{{outlet}}` in a template:\n\n```handlebars\n{{outlet \"menu\"}}\n{{outlet \"sidebar\"}}\n{{outlet \"main\"}}\n```\n\nYour routes can then render into a specific one of these `outlet`s by specifying the `outlet`\nattribute in your `renderTemplate` function:\n\n```js {data-filename=app/routes/menu.js}\nimport Route from '@ember/routing/route';\n\nexport default Route.extend({\n  renderTemplate() {\n    this.render({ outlet: 'menu' });\n  }\n});\n```\n\nSee the [routing guide](https://emberjs.com/guides/routing/rendering-a-template/) for more\ninformation on how your `route` interacts with the `{{outlet}}` helper.\nNote: Your content __will not render__ if there isn't an `{{outlet}}` for it.",
          "itemtype": "method",
          "name": "outlet",
          "params": [
            {
              "name": "name",
              "description": "",
              "type": "String",
              "optional": true
            }
          ],
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/syntax/render.js",
          "line": 49,
          "description": "Calling ``{{render}}`` from within a template will insert another\ntemplate that matches the provided name. The inserted template will\naccess its properties on its own controller (rather than the controller\nof the parent template).\n\nIf a view class with the same name exists, the view class also will be used.\nNote: A given controller may only be used *once* in your app in this manner.\nA singleton instance of the controller will be created for you.\n\nExample:\n\n```js {data-filename=app/controllers/navigation.js}\nimport Controller from '@ember/controller';\n\nexport default Controller.extend({\n  who: \"world\"\n});\n```\n\n```handlebars\n<!-- navigation.hbs -->\nHello, {{who}}.\n```\n\n```handlebars\n<!-- application.hbs -->\n<h1>My great app</h1>\n{{render \"navigation\"}}\n```\n\n```html\n<h1>My great app</h1>\n<div class='ember-view'>\n  Hello, world.\n</div>\n```\n\nOptionally you may provide a second argument: a property path\nthat will be bound to the `model` property of the controller.\nIf a `model` property path is specified, then a new instance of the\ncontroller will be created and `{{render}}` can be used multiple times\nwith the same name.\n\nFor example if you had this `author` template.\n\n```handlebars\n<div class=\"author\">\n  Written by {{firstName}} {{lastName}}.\n  Total Posts: {{postCount}}\n</div>\n```\n\nYou could render it inside the `post` template using the `render` helper.\n\n```handlebars\n<div class=\"post\">\n  <h1>{{title}}</h1>\n  <div>{{body}}</div>\n  {{render \"author\" author}}\n</div>\n```",
          "itemtype": "method",
          "name": "render",
          "params": [
            {
              "name": "name",
              "description": "",
              "type": "String"
            },
            {
              "name": "context",
              "description": "",
              "type": "Object?"
            },
            {
              "name": "options",
              "description": "",
              "type": "Hash"
            }
          ],
          "return": {
            "description": "HTML string",
            "type": "String"
          },
          "access": "public",
          "tagname": "",
          "deprecated": true,
          "deprecationMessage": "Use a component instead",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/index.js",
          "line": 86,
          "description": "Use the `{{with}}` helper when you want to alias a property to a new name. This is helpful\nfor semantic clarity as it allows you to retain default scope or to reference a property from another\n`{{with}}` block.\n\nIf the aliased property is \"falsey\", for example: `false`, `undefined` `null`, `\"\"`, `0`, `NaN` or\nan empty array, the block will not be rendered.\n\n```handlebars\n{{! Will only render if user.posts contains items}}\n{{#with user.posts as |blogPosts|}}\n  <div class=\"notice\">\n    There are {{blogPosts.length}} blog posts written by {{user.name}}.\n  </div>\n  {{#each blogPosts as |post|}}\n    <li>{{post.title}}</li>\n  {{/each}}\n{{/with}}\n```\n\nNOTE: The alias should not reuse a name from the bound property path.\n\nFor example: `{{#with foo.bar as |foo|}}` is not supported because it attempts to alias using\nthe first part of the property path, `foo`. Instead, use `{{#with foo.bar as |baz|}}`.",
          "itemtype": "method",
          "name": "with",
          "params": [
            {
              "name": "options",
              "description": "",
              "type": "Object"
            }
          ],
          "return": {
            "description": "HTML string",
            "type": "String"
          },
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/index.js",
          "line": 118,
          "description": "`{{yield}}` denotes an area of a template that will be rendered inside\nof another template.\n\n### Use with `Component`\n\nWhen designing components `{{yield}}` is used to denote where, inside the component's\ntemplate, an optional block passed to the component should render:\n\n```handlebars {data-filename=app/templates/application.hbs}\n{{#labeled-textfield value=someProperty}}\n  First name:\n{{/labeled-textfield}}\n```\n\n```handlebars {data-filename=app/templates/components/labeled-textfield.hbs}\n<label>\n  {{yield}} {{input value=value}}\n</label>\n```\n\nResult:\n\n```html\n<label>\n  First name: <input type=\"text\" />\n</label>\n```\n\nAdditionally you can `yield` properties into the context for use by the consumer:\n\n```handlebars {data-filename=app/templates/application.hbs}\n{{#labeled-textfield value=someProperty validator=(action 'firstNameValidator') as |validationError|}}\n  {{#if validationError}}\n    <p class=\"error\">{{ValidationError}}</p>\n  {{/if}}\n  First name:\n{{/labeled-textfield}}\n```\n\n```handlebars {data-filename=app/templates/components/labeled-textfield.hbs}\n<label>\n  {{yield validationError}} {{input value=value}}\n</label>\n```\n\nResult:\n\n```html\n<label>\n  <p class=\"error\">First Name must be at least 3 characters long.</p>\n  First name: <input type=\"text\" />\n</label>\n```",
          "itemtype": "method",
          "name": "yield",
          "params": [
            {
              "name": "options",
              "description": "",
              "type": "Hash"
            }
          ],
          "return": {
            "description": "HTML string",
            "type": "String"
          },
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/index.js",
          "line": 179,
          "description": "Execute the `debugger` statement in the current template's context.\n\n```handlebars\n{{debugger}}\n```\n\nWhen using the debugger helper you will have access to a `get` function. This\nfunction retrieves values available in the context of the template.\nFor example, if you're wondering why a value `{{foo}}` isn't rendering as\nexpected within a template, you could place a `{{debugger}}` statement and,\nwhen the `debugger;` breakpoint is hit, you can attempt to retrieve this value:\n\n```\n> get('foo')\n```\n\n`get` is also aware of keywords. So in this situation\n\n```handlebars\n{{#each items as |item|}}\n  {{debugger}}\n{{/each}}\n```\n\nYou'll be able to get values from the current item:\n\n```\n> get('item.name')\n```\n\nYou can also access the context of the view to make sure it is the object that\nyou expect:\n\n```\n> context\n```",
          "itemtype": "method",
          "name": "debugger",
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        },
        {
          "file": "packages/ember-glimmer/lib/index.js",
          "line": 222,
          "description": "The `partial` helper renders another template without\nchanging the template context:\n\n```handlebars\n{{foo}}\n{{partial \"nav\"}}\n```\n\nThe above example template will render a template named\n\"-nav\", which has the same context as the parent template\nit's rendered into, so if the \"-nav\" template also referenced\n`{{foo}}`, it would print the same thing as the `{{foo}}`\nin the above example.\n\nIf a \"-nav\" template isn't found, the `partial` helper will\nfall back to a template named \"nav\".\n\n### Bound template names\n\nThe parameter supplied to `partial` can also be a path\nto a property containing a template name, e.g.:\n\n```handlebars\n{{partial someTemplateName}}\n```\n\nThe above example will look up the value of `someTemplateName`\non the template context (e.g. a controller) and use that\nvalue as the name of the template to render. If the resolved\nvalue is falsy, nothing will be rendered. If `someTemplateName`\nchanges, the partial will be re-rendered using the new template\nname.",
          "itemtype": "method",
          "name": "partial",
          "params": [
            {
              "name": "partialName",
              "description": "The name of the template to render minus the leading underscore.",
              "type": "String"
            }
          ],
          "access": "public",
          "tagname": "",
          "class": "Ember.Templates.helpers",
          "module": "ember"
        }
      ],
      "events": [],
      "properties": []
    },
    "relationships": {
      "parent-class": {
        "data": null
      },
      "descendants": {
        "data": []
      },
      "module": {
        "data": {
          "id": "ember-2.16.4-ember",
          "type": "module"
        }
      },
      "project-version": {
        "data": {
          "id": "ember-2.16.4",
          "type": "project-version"
        }
      }
    }
  }
}