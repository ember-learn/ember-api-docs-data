{
  "data": {
    "id": "ember-6.4.0-@glimmer/component",
    "type": "module",
    "attributes": {
      "name": "@glimmer/component",
      "submodules": {},
      "elements": {},
      "fors": {},
      "namespaces": {},
      "tag": "module",
      "file": "packages/@glimmer/component/src/index.ts",
      "line": 7,
      "description": "A component is a reusable UI element that consists of a `.hbs` template and an\noptional JavaScript class that defines its behavior. For example, someone\nmight make a `button` in the template and handle the click behavior in the\nJavaScript file that shares the same name as the template.\n\nComponents are broken down into two categories:\n\n- Components _without_ JavaScript, that are based only on a template. These\n  are called Template-only or TO components.\n- Components _with_ JavaScript, which consist of a template and a backing\n  class.\n\nEmber ships with two types of JavaScript classes for components:\n\n1. Glimmer components, imported from `@glimmer/component`, which are the\n   default components for Ember Octane (3.15) and more recent editions.\n2. Classic components, imported from `@ember/component`, which were the\n   default for older editions of Ember (pre 3.15).\n\nBelow is the documentation for Template-only and Glimmer components. If you\nare looking for the API documentation for Classic components, it is\n[available here](/ember/release/classes/Component). The source code for\nGlimmer components can be found in [`@glimmer/component`](https://github.com/glimmerjs/glimmer.js/tree/master/packages/%40glimmer/component).\n\n## Defining a Template-only Component\n\nThe simplest way to create a component is to create a template file in\n`app/templates/components`. For example, if you name a template\n`app/templates/components/person-profile.hbs`:\n\n```handlebars {data-filename=app/templates/components/person-profile.hbs}\n<h1>{{@person.name}}</h1>\n<img src={{@person.avatar}}>\n<p class='signature'>{{@person.signature}}</p>\n```\n\nYou will be able to use `<PersonProfile />` to invoke this component elsewhere\nin your application:\n\n```handlebars {data-filename=app/templates/application.hbs}\n<PersonProfile @person={{this.currentUser}} />\n```\n\nNote that component names are capitalized here in order to distinguish them\nfrom regular HTML elements, but they are dasherized in the file system.\n\nWhile the angle bracket invocation form is generally preferred, it is also\npossible to invoke the same component with the `{{person-profile}}` syntax:\n\n```handlebars {data-filename=app/templates/application.hbs}\n{{person-profile person=this.currentUser}}\n```\n\nNote that with this syntax, you use dashes in the component name and\narguments are passed without the `@` sign.\n\nIn both cases, Ember will render the content of the component template we\ncreated above. The end result will be something like this:\n\n```html\n<h1>Tomster</h1>\n<img src=\"https://emberjs.com/tomster.jpg\">\n<p class='signature'>Out of office this week</p>\n```\n\n## File System Nesting\n\nComponents can be nested inside sub-folders for logical groupping. For\nexample, if we placed our template in\n`app/templates/components/person/short-profile.hbs`, we can invoke it as\n`<Person::ShortProfile />`:\n\n```handlebars {data-filename=app/templates/application.hbs}\n<Person::ShortProfile @person={{this.currentUser}} />\n```\n\nOr equivalently, `{{person/short-profile}}`:\n\n```handlebars {data-filename=app/templates/application.hbs}\n{{person/short-profile person=this.currentUser}}\n```\n\n## Using Blocks\n\nYou can use `yield` inside a template to include the **contents** of any block\nattached to the component. For instance, if we added a `{{yield}}` to our\ncomponent like so:\n\n```handlebars {data-filename=app/templates/components/person-profile.hbs}\n<h1>{{@person.name}}</h1>\n{{yield}}\n```\n\nWe could then invoke it like this:\n\n```handlebars\n<PersonProfile @person={{this.currentUser}}>\n  <p>Admin mode</p>\n</PersonProfile>\n```\n\nor with curly syntax like this:\n\n```handlebars\n{{#person-profile person=this.currentUser}}\n  <p>Admin mode</p>\n{{/person-profile}}\n```\n\nAnd the content passed in between the brackets of the component would be\nrendered in the same place as the `{{yield}}` within it, replacing it.\n\nBlocks are executed in their original context, meaning they have access to the\nscope and any in-scope variables where they were defined.\n\n### Passing parameters to blocks\n\nYou can also pass positional parameters to `{{yield}}`, which are then made\navailable in the block:\n\n```handlebars {data-filename=app/templates/components/person-profile.hbs}\n<h1>{{@person.name}}</h1>\n{{yield @person.signature}}\n```\n\nWe can then use this value in the block like so:\n\n```handlebars\n<PersonProfile @person={{this.currentUser}} as |signature|>\n  {{signature}}\n</PersonProfile>\n```\n\n### Passing multiple blocks\n\nYou can pass multiple blocks to a component by giving them names, and\nspecifying which block you are yielding to with `{{yield}}`. For instance, if\nwe wanted to add a way for users to customize the title of our\n`<PersonProfile>` component, we could add a named block inside of the header:\n\n```handlebars {data-filename=app/templates/components/person-profile.hbs}\n<h1>{{yield to=\"title\"}}</h1>\n{{yield}}\n```\n\nThis component could then be invoked like so:\n\n```handlebars\n<PersonProfile @person={{this.currentUser}}>\n  <:title>{{this.currentUser.name}}</:title>\n  <:default>{{this.currentUser.signature}}</:default>\n</PersonProfile>\n```\n\nWhen passing named blocks, you must name every block, including the `default`\nblock, which is the block that is defined if you do not pass a `to` parameter\nto `{{yield}}`. Whenever you invoke a component without passing explicitly\nnamed blocks, the passed block is considered the `default` block.\n\n### Passing parameters to named blocks\n\nYou can also pass parameters to named blocks:\n\n```handlebars {data-filename=app/templates/components/person-profile.hbs}\n<h1>{{yield @person.name to=\"title\"}}</h1>\n{{yield @person.signature}}\n```\n\nThese parameters can then be used like so:\n\n```handlebars\n<PersonProfile @person={{this.currentUser}}>\n  <:title as |name|>{{name}}</:title>\n  <:default as |signature|>{{signature}}</:default>\n</PersonProfile>\n```\n\n### Checking to see if a block exists\n\nYou can also check to see if a block exists using the `(has-block)` keyword,\nand conditionally use it, or provide a default template instead.\n\n```handlebars {data-filename=app/templates/components/person-profile.hbs}\n<h1>\n  {{#if (has-block \"title\")}}\n    {{yield @person.name to=\"title\"}}\n  {{else}}\n    {{@person.name}}\n  {{/if}}\n</h1>\n\n{{#if (has-block)}}\n  {{yield @person.signature}}\n{{else}}\n  {{@person.signature}}\n{{/if}}\n```\n\nWith this template, we can then optionally pass in one block, both blocks, or\nnone at all:\n\n```handlebars\n{{! passing both blocks }}\n<PersonProfile @person={{this.currentUser}}>\n  <:title as |name|>{{name}}</:title>\n  <:default as |signature|>{{signature}}</:default>\n</PersonProfile>\n\n{{! passing just the title block }}\n<PersonProfile @person={{this.currentUser}}>\n  <:title as |name|>{{name}}</:title>\n</PersonProfile>\n\n{{! passing just the default block }}\n<PersonProfile @person={{this.currentUser}} as |signature|>\n  {{signature}}\n</PersonProfile>\n\n{{! not passing any blocks }}\n<PersonProfile @person={{this.currentUser}}/>\n```\n\n### Checking to see if a block has parameters\n\nWe can also check if a block receives parameters using the `(has-block-params)`\nkeyword, and conditionally yield different values if so.\n\n```handlebars {data-filename=app/templates/components/person-profile.hbs}\n{{#if (has-block-params)}}\n  {{yield @person.signature}}\n{{else}}\n  {{yield}}\n{{/if}}\n```\n\n## Customizing Components With JavaScript\n\nTo add JavaScript to a component, create a JavaScript file in the same\nlocation as the template file, with the same name, and export a subclass\nof `Component` as the default value. For example, to add Javascript to the\n`PersonProfile` component which we defined above, we would create\n`app/components/person-profile.js` and export our class as the default, like\nso:\n\n```js {data-filename=app/components/person-profile.js}\nimport Component from '@glimmer/component';\n\nexport default class PersonProfileComponent extends Component {\n  get displayName() {\n    let { title, firstName, lastName } = this.args.person;\n\n    if (title) {\n      return `${title} ${lastName}`;\n    } else {\n      return `${firstName} ${lastName}`;\n    }\n  })\n}\n```\n\nYou can add your own properties, methods, and lifecycle hooks to this\nsubclass to customize its behavior, and you can reference the instance of the\nclass in your template using `{{this}}`. For instance, we could access the\n`displayName` property of our `PersonProfile` component instance in the\ntemplate like this:\n\n```handlebars {data-filename=app/templates/components/person-profile.hbs}\n<h1>{{this.displayName}}</h1>\n{{yield}}\n```\n\n## `constructor`\n\nparams: `owner` object and `args` object\n\nConstructs a new component and assigns itself the passed properties. The\nconstructor is run whenever a new instance of the component is created, and\ncan be used to setup the initial state of the component.\n\n```javascript\nimport Component from '@glimmer/component';\n\nexport default class SomeComponent extends Component {\n  constructor(owner, args) {\n    super(owner, args);\n\n    if (this.args.displayMode === 'list') {\n      this.items = [];\n    }\n  }\n}\n```\n\nService injections and arguments are available in the constructor.\n\n```javascript\nimport Component from '@glimmer/component';\nimport { service } from '@ember/service';\n\nexport default class SomeComponent extends Component {\n  @service myAnimations;\n\n  constructor(owner, args) {\n    super(owner, args);\n\n    if (this.args.fadeIn === true) {\n      this.myAnimations.register(this, 'fade-in');\n    }\n  }\n}\n```\n\n## `willDestroy`\n\n`willDestroy` is called after the component has been removed from the DOM, but\nbefore the component is fully destroyed. This lifecycle hook can be used to\ncleanup the component and any related state.\n\n```javascript\nimport Component from '@glimmer/component';\nimport { service } from '@ember/service';\n\nexport default class SomeComponent extends Component {\n  @service myAnimations;\n\n  willDestroy() {\n    super.willDestroy(...arguments);\n\n    this.myAnimations.unregister(this);\n  }\n}\n```\n\n## `args`\n\nThe `args` property of Glimmer components is an object that contains the\n_arguments_ that are passed to the component. For instance, the\nfollowing component usage:\n\n```handlebars\n<SomeComponent @fadeIn={{true}} />\n```\n\nWould result in the following `args` object to be passed to the component:\n\n```javascript\n{ fadeIn: true }\n```\n\n`args` can be accessed at any point in the component lifecycle, including\n`constructor` and `willDestroy`. They are also automatically marked as tracked\nproperties, and they can be depended on as computed property dependencies:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { computed } from '@ember/object';\n\nexport default class SomeComponent extends Component {\n\n  @computed('args.someValue')\n  get computedGetter() {\n    // updates whenever args.someValue updates\n    return this.args.someValue;\n  }\n\n  get standardGetter() {\n    // updates whenever args.anotherValue updates (Ember 3.13+)\n    return this.args.anotherValue;\n  }\n}\n```\n\n## `isDestroying`\n\nA boolean flag to tell if the component is in the process of destroying. This is set to\ntrue before `willDestroy` is called.\n\n## `isDestroyed`\nA boolean to tell if the component has been fully destroyed. This is set to true\nafter `willDestroy` is called.",
      "access": "public",
      "tagname": "",
      "parent": null,
      "publicclasses": [],
      "privateclasses": [],
      "staticfunctions": {},
      "allstaticfunctions": {},
      "version": "6.4.0"
    },
    "relationships": {
      "classes": {
        "data": []
      },
      "project-version": {
        "data": {
          "id": "ember-6.4.0",
          "type": "project-version"
        }
      }
    }
  }
}