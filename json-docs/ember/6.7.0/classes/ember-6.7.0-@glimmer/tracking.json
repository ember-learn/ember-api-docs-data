{
  "data": {
    "id": "ember-6.7.0-@glimmer/tracking",
    "type": "class",
    "attributes": {
      "name": "@glimmer/tracking",
      "shortname": "@glimmer/tracking",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@glimmer/tracking",
      "namespace": "",
      "methods": [
        {
          "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
          "line": 22,
          "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\n\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
          "itemtype": "method",
          "name": "tracked",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        },
        {
          "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
          "line": 158,
          "description": "Gives the getter a caching behavior. The return value of the getter\nwill be cached until any of the properties it is entangled with\nare invalidated. This is useful when a getter is expensive and\nused very often.\n\nFor instance, in this `GuestList` class, we have the `sortedGuests`\ngetter that sorts the guests alphabetically:\n\n```javascript\n  import { tracked } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nEvery time `sortedGuests` is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list\nis small, like the one in the example, this is not a problem. However, if\nthe guest list were to grow very large, it would mean that we would be doing\na large amount of work each time we accessed `sortedGuests`. With `@cached`,\nwe can cache the value instead:\n\n```javascript\n  import { tracked, cached } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    @cached\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nNow the `sortedGuests` getter will be cached based on autotracking.\nIt will only rerun and create a new sorted array when the guests tracked\nproperty is updated.\n\n\n### Tradeoffs\n\nOveruse is discouraged.\n\nIn general, you should avoid using `@cached` unless you have confirmed that\nthe getter you are decorating is computationally expensive, since `@cached`\nadds a small amount of overhead to the getter.\nWhile the individual costs are small, a systematic use of the `@cached`\ndecorator can add up to a large impact overall in your app.\nMany getters and tracked properties are only accessed once during rendering,\nand then never rerendered, so adding `@cached` when unnecessary can\nnegatively impact performance.\n\nAlso, `@cached` may rerun even if the values themselves have not changed,\nsince tracked properties will always invalidate.\nFor example updating an integer value from `5` to an other `5` will trigger\na rerun of the cached properties building from this integer.\n\nAvoiding a cache invalidation in this case is not something that can\nbe achieved on the `@cached` decorator itself, but rather when updating\nthe underlying tracked values, by applying some diff checking mechanisms:\n\n```javascript\nif (nextValue !== this.trackedProp) {\n  this.trackedProp = nextValue;\n}\n```\n\nHere equal values won't update the property, therefore not triggering\nthe subsequent cache invalidations of the `@cached` properties who were\nusing this `trackedProp`.\n\nRemember that setting tracked data should only be done during initialization,\nor as the result of a user action. Setting tracked data during render\n(such as in a getter), is not supported.",
          "itemtype": "method",
          "name": "cached",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        },
        {
          "file": "packages/@ember/-internals/metal/lib/cached.ts",
          "line": 7,
          "decorator": "Gives the getter a caching behavior. The return value of the getter\n will be cached until any of the properties it is entangled with\n are invalidated. This is useful when a getter is expensive and\n used very often.\n\n For instance, in this `GuestList` class, we have the `sortedGuests`\n getter that sorts the guests alphabetically:\n\n ```javascript\n   import { tracked } from '---AT-PLACEHOLDER---glimmer/tracking';\n\n   class GuestList {\n     ---AT-PLACEHOLDER---tracked guests = ['Zoey', 'Tomster'];\n\n     get sortedGuests() {\n       return this.guests.slice().sort()\n     }\n   }\n ```\n\n Every time `sortedGuests` is accessed, a new array will be created and sorted,\n because JavaScript getters do not cache by default. When the guest list\n is small, like the one in the example, this is not a problem. However, if\n the guest list were to grow very large, it would mean that we would be doing\n a large amount of work each time we accessed `sortedGuests`. With `@cached`,\n we can cache the value instead:\n\n ```javascript\n   import { tracked, cached } from '---AT-PLACEHOLDER---glimmer/tracking';\n\n   class GuestList {\n     ---AT-PLACEHOLDER---tracked guests = ['Zoey', 'Tomster'];\n\n     ---AT-PLACEHOLDER---cached\n     get sortedGuests() {\n       return this.guests.slice().sort()\n     }\n   }\n ```\n\n Now the `sortedGuests` getter will be cached based on autotracking.\n It will only rerun and create a new sorted array when the guests tracked\n property is updated.\n\n\n ### Tradeoffs\n\n Overuse is discouraged.\n\n In general, you should avoid using `@cached` unless you have confirmed that\n the getter you are decorating is computationally expensive, since `@cached`\n adds a small amount of overhead to the getter.\n While the individual costs are small, a systematic use of the `@cached`\n decorator can add up to a large impact overall in your app.\n Many getters and tracked properties are only accessed once during rendering,\n and then never rerendered, so adding `@cached` when unnecessary can\n negatively impact performance.\n\n Also, `@cached` may rerun even if the values themselves have not changed,\n since tracked properties will always invalidate.\n For example updating an integer value from `5` to an other `5` will trigger\n a rerun of the cached properties building from this integer.\n\n Avoiding a cache invalidation in this case is not something that can\n be achieved on the `@cached` decorator itself, but rather when updating\n the underlying tracked values, by applying some diff checking mechanisms:\n\n ```javascript\n if (nextValue !== this.trackedProp) {\n   this.trackedProp = nextValue;\n }\n ```\n\n Here equal values won't update the property, therefore not triggering\n the subsequent cache invalidations of the `@cached` properties who were\n using this `trackedProp`.\n\n Remember that setting tracked data should only be done during initialization, \n or as the result of a user action. Setting tracked data during render\n (such as in a getter), is not supported.",
          "itemtype": "method",
          "name": "cached",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking/primitives/cache"
        },
        {
          "file": "packages/@glimmer/tracking/index.ts",
          "line": 16,
          "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
          "itemtype": "method",
          "name": "tracked",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        },
        {
          "file": "packages/@glimmer/tracking/index.ts",
          "line": 150,
          "description": "The `@cached` decorator can be used on getters in order to cache the return\nvalue of the getter. This is useful when a getter is expensive and used very\noften. For instance, in this guest list class, we have the `sortedGuests`\ngetter that sorts the guests alphabetically:\n\n```js\nimport { tracked } from '@glimmer/tracking';\n\nclass GuestList {\n  @tracked guests = ['Zoey', 'Tomster'];\n\n  get sortedGuests() {\n    return this.guests.slice().sort()\n  }\n}\n```\n\nEvery time `sortedGuests` is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list is\nsmall, like the one in the example, this is not a problem. However, if the guest\nlist were to grow very large, it would mean that we would be doing a large\namount of work each time we accessed `sortedGetters`. With `@cached`, we can\ncache the value instead:\n\n```js\nimport { tracked, cached } from '@glimmer/tracking';\n\nclass GuestList {\n  @tracked guests = ['Zoey', 'Tomster'];\n\n  @cached\n  get sortedGuests() {\n    return this.guests.slice().sort()\n  }\n}\n```\n\nNow the `sortedGuests` getter will be cached based on _autotracking_. It will\nonly rerun and create a new sorted array when the `guests` tracked property is\nupdated.\n\nIn general, you should avoid using `@cached` unless you have confirmed that the\ngetter you are decorating is computationally expensive. `@cached` adds a small\namount of overhead to the getter, making it more expensive. While this overhead\nis small, if `@cached` is overused it can add up to a large impact overall in\nyour app. Many getters and tracked properties are only accessed once, rendered,\nand then never rerendered, so adding `@cached` when it is unnecessary can\nnegatively impact performance.",
          "itemtype": "method",
          "name": "cached",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        }
      ],
      "events": [],
      "properties": []
    },
    "relationships": {
      "parent-class": {
        "data": null
      },
      "descendants": {
        "data": []
      },
      "module": {
        "data": {
          "id": "ember-6.7.0-@glimmer/tracking",
          "type": "module"
        }
      },
      "project-version": {
        "data": {
          "id": "ember-6.7.0",
          "type": "project-version"
        }
      }
    }
  }
}