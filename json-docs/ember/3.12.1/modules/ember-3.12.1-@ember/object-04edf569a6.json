{
  "data": {
    "id": "ember-3.12.1-@ember/object",
    "type": "module",
    "attributes": {
      "name": "@ember/object",
      "submodules": {},
      "elements": {},
      "fors": {
        "@ember/object": 1,
        "@ember/debug": 1,
        "@ember/object/internals": 1,
        "@ember/object/events": 1,
        "@ember/object/evented": 1,
        "@ember/object/computed": 1,
        "@ember/object/mixin": 1,
        "@ember/object/observers": 1,
        "Ember": 1
      },
      "namespaces": {},
      "tag": "module",
      "file": "packages/@ember/-internals/runtime/lib/system/object_proxy.js",
      "line": 4,
      "parent": null,
      "publicclasses": [
        "ComputedProperty",
        "Mixin",
        "Evented",
        "Observable",
        "PromiseProxyMixin",
        "CoreObject",
        "EmberObject",
        "ObjectProxy"
      ],
      "privateclasses": [
        "Descriptor",
        "ObserverSet"
      ],
      "staticfunctions": {
        "@ember/object/events": [
          {
            "file": "packages/@ember/-internals/metal/lib/events.ts",
            "line": 26,
            "description": "Add an event listener",
            "itemtype": "method",
            "name": "addListener",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "eventName",
                "description": "",
                "type": "String"
              },
              {
                "name": "target",
                "description": "A target object or a function",
                "type": "Object|Function"
              },
              {
                "name": "method",
                "description": "A function or the name of a function to be called on `target`",
                "type": "Function|String"
              },
              {
                "name": "once",
                "description": "A flag whether a function should only be called once",
                "type": "Boolean"
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/events",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/events.ts",
            "line": 60,
            "description": "Remove an event listener\n\nArguments should match those passed to `addListener`.",
            "itemtype": "method",
            "name": "removeListener",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "eventName",
                "description": "",
                "type": "String"
              },
              {
                "name": "target",
                "description": "A target object or a function",
                "type": "Object|Function"
              },
              {
                "name": "method",
                "description": "A function or the name of a function to be called on `target`",
                "type": "Function|String"
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/events",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/events.ts",
            "line": 103,
            "description": "Send an event. The execution of suspended listeners\nis skipped, and once listeners are removed. A listener without\na target is executed on the passed object. If an array of actions\nis not passed, the actions stored on the passed object are invoked.",
            "itemtype": "method",
            "name": "sendEvent",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "eventName",
                "description": "",
                "type": "String"
              },
              {
                "name": "params",
                "description": "Optional parameters for each listener.",
                "type": "Array"
              }
            ],
            "return": {
              "description": "if the event was delivered to one or more actions",
              "type": "Boolean"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/events",
            "module": "@ember/object"
          }
        ],
        "@ember/object/observers": [
          {
            "file": "packages/@ember/-internals/metal/lib/observer.ts",
            "line": 27,
            "itemtype": "method",
            "name": "addObserver",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "path",
                "description": "",
                "type": "String"
              },
              {
                "name": "target",
                "description": "",
                "type": "Object|Function"
              },
              {
                "name": "method",
                "description": "",
                "type": "Function|String",
                "optional": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/observers",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/observer.ts",
            "line": 59,
            "itemtype": "method",
            "name": "removeObserver",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "path",
                "description": "",
                "type": "String"
              },
              {
                "name": "target",
                "description": "",
                "type": "Object|Function"
              },
              {
                "name": "method",
                "description": "",
                "type": "Function|String",
                "optional": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/observers",
            "module": "@ember/object"
          }
        ],
        "@ember/object/computed": [
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 934,
            "itemtype": "method",
            "description": "Creates a new property that is an alias for another property on an object.\nCalls to `get` or `set` this property behave as though they were called on the\noriginal property.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { alias } from '@ember/object/computed';\n\nclass Person {\n  name = 'Alex Matchneer';\n  @alias('name') nomen;\n}\n\nlet alex = new Person();\n\nalex.nomen; // 'Alex Matchneer'\nalex.name;  // 'Alex Matchneer'\n\nset(alex, 'nomen', '@machty');\nalex.name;  // '@machty'\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { alias } from '@ember/object/computed';\n\nlet Person = EmberObject.extend({\n  name: 'Alex Matchneer',\n\n  nomen: alias('name')\n});\n\nlet alex = Person.create();\n\nalex.nomen; // 'Alex Matchneer'\nalex.name;  // 'Alex Matchneer'\n\nset(alex, 'nomen', '@machty');\nalex.name;  // '@machty'\n```\n",
            "name": "alias",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which creates an alias to the\noriginal value for property.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 792,
            "itemtype": "method",
            "description": "A computed property that performs a logical `and` on the original values for\nthe provided dependent properties.\n\nYou may pass in more than two properties and even use property brace\nexpansion.  The computed property will return the first falsy value or last\ntruthy value just like JavaScript's `&&` operator.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { and } from '@ember/object/computed';\n\nclass Hamster {\n  @and('hasWalkingStick', 'hasBackpack') readyForHike;\n}\n\nlet tomster = new Hamster();\n\ntomster.readyForCamp; // false\n\nset(tomster, 'hasTent', true);\ntomster.readyForCamp; // false\n\nset(tomster, 'hasBackpack', true);\ntomster.readyForCamp; // true\n\nset(tomster, 'hasBackpack', 'Yes');\ntomster.readyForCamp; // 'Yes'\n\nset(tomster, 'hasWalkingStick', null);\ntomster.readyForHike; // null\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { and } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  readyForCamp: and('hasTent', 'hasBackpack'),\n  readyForHike: and('hasWalkingStick', 'hasBackpack')\n});\n\nlet tomster = Hamster.create();\n\ntomster.readyForCamp; // false\n\nset(tomster, 'hasTent', true);\ntomster.readyForCamp; // false\n\nset(tomster, 'hasBackpack', true);\ntomster.readyForCamp; // true\n\nset(tomster, 'hasBackpack', 'Yes');\ntomster.readyForCamp; // 'Yes'\n\nset(tomster, 'hasWalkingStick', null);\ntomster.readyForHike; // null\n```\n",
            "name": "and",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computed property which performs a logical `and` on\nthe values of all the original values for properties.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 321,
            "itemtype": "method",
            "description": "A computed property that converts the provided dependent property into a\nboolean value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { bool } from '@ember/object/computed';\n\n\nclass Hamster {\n  @bool('numBananas') hasBananas\n}\n\nlet hamster = new Hamster();\n\nhamster.hasBananas; // false\n\nset(hamster, 'numBananas', 0);\nhamster.hasBananas; // false\n\nset(hamster, 'numBananas', 1);\nhamster.hasBananas; // true\n\nset(hamster, 'numBananas', null);\nhamster.hasBananas; // false\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { bool } from '@ember/object/computed';\n\n\nlet Hamster = EmberObject.extend({\n  hasBananas: bool('numBananas')\n});\n\nlet hamster = Hamster.create();\n\nhamster.hasBananas; // false\n\nset(hamster, 'numBananas', 0);\nhamster.hasBananas; // false\n\nset(hamster, 'numBananas', 1);\nhamster.hasBananas; // true\n\nset(hamster, 'numBananas', null);\nhamster.hasBananas; // false\n```\n",
            "name": "bool",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which converts to boolean the\noriginal value for property",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 1197,
            "itemtype": "method",
            "description": "A computed property that returns the array of values for the provided\ndependent properties.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { collect } from '@ember/object/computed';\n\nclass Hamster {\n  @collect('hat', 'shirt') clothes;\n}\n\nlet hamster = new Hamster();\n\nhamster.clothes; // [null, null]\n\nset(hamster, 'hat', 'Camp Hat');\nset(hamster, 'shirt', 'Camp Shirt');\nhamster.clothes; // ['Camp Hat', 'Camp Shirt']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { collect } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  clothes: collect('hat', 'shirt')\n});\n\nlet hamster = Hamster.create();\n\nhamster.clothes; // [null, null]\n\nset(hamster, 'hat', 'Camp Hat');\nset(hamster, 'shirt', 'Camp Shirt');\nhamster.clothes; // ['Camp Hat', 'Camp Shirt']\n```\n",
            "name": "collect",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computed property which maps values of all passed\nin properties to an array.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 1152,
            "itemtype": "method",
            "description": "Creates a new property that is an alias for another property on an object.\nCalls to `get` or `set` this property behave as though they were called on the\noriginal property, but also print a deprecation warning.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { deprecatingAlias } from '@ember/object/computed';\n\nclass Hamster {\n  @deprecatingAlias('cavendishCount', {\n    id: 'hamster.deprecate-banana',\n    until: '3.0.0'\n  })\n  bananaCount;\n}\n\nlet hamster = new Hamster();\n\nset(hamster, 'bananaCount', 5); // Prints a deprecation warning.\nhamster.cavendishCount; // 5\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { deprecatingAlias } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  bananaCount: deprecatingAlias('cavendishCount', {\n    id: 'hamster.deprecate-banana',\n    until: '3.0.0'\n  })\n});\n\nlet hamster = Hamster.create();\n\nset(hamster, 'bananaCount', 5); // Prints a deprecation warning.\nhamster.cavendishCount; // 5\n```\n",
            "name": "deprecatingAlias",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "options",
                "description": "Options for `deprecate`.",
                "type": "Object"
              }
            ],
            "return": {
              "description": "computed property which creates an alias with a\ndeprecation to the original value for property.",
              "type": "ComputedProperty"
            },
            "since": "1.7.0",
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 63,
            "since": "1.6.0",
            "description": "A computed property macro that returns true if the value of the dependent\nproperty is null, an empty string, empty array, or empty function.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { empty } from '@ember/object/computed';\n\nclass ToDoList {\n  constructor(todos) {\n    set(this, 'todos', todos);\n  }\n\n  @empty('todos') isDone;\n}\n\nlet todoList = new ToDoList(\n  ['Unit Test', 'Documentation', 'Release']\n);\n\ntodoList.isDone; // false\nset(todoList, 'todos', []);\ntodoList.isDone; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { empty } from '@ember/object/computed';\n\nlet ToDoList = EmberObject.extend({\n  isDone: empty('todos')\n});\n\nlet todoList = ToDoList.create({\n  todos: ['Unit Test', 'Documentation', 'Release']\n});\n\ntodoList.isDone; // false\nset(todoList, 'todos', []);\ntodoList.isDone; // true\n```\n",
            "itemtype": "method",
            "name": "empty",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which returns true if the value\nof the dependent property is null, an empty string, empty array, or empty\nfunction and false if the underlying value is not empty.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 462,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\nequal to the given value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { equal } from '@ember/object/computed';\n\nclass Hamster {\n  @equal('percentCarrotsEaten', 100) satisfied;\n}\n\nlet hamster = new Hamster();\n\nhamster.satisfied; // false\n\nset(hamster, 'percentCarrotsEaten', 100);\nhamster.satisfied; // true\n\nset(hamster, 'percentCarrotsEaten', 50);\nhamster.satisfied; // false\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { equal } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  satisfied: equal('percentCarrotsEaten', 100)\n});\n\nlet hamster = Hamster.create();\n\nhamster.satisfied; // false\n\nset(hamster, 'percentCarrotsEaten', 100);\nhamster.satisfied; // true\n\nset(hamster, 'percentCarrotsEaten', 50);\nhamster.satisfied; // false\n```\n",
            "name": "equal",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "String|Number|Object"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is equal to the given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/expand_properties.ts",
            "line": 9,
            "description": "Expands `pattern`, invoking `callback` for each expansion.\n\nThe only pattern supported is brace-expansion, anything else will be passed\nonce to `callback` directly.\n\nExample\n\n```js\nimport { expandProperties } from '@ember/object/computed';\n\nfunction echo(arg){ console.log(arg); }\n\nexpandProperties('foo.bar', echo);              //=> 'foo.bar'\nexpandProperties('{foo,bar}', echo);            //=> 'foo', 'bar'\nexpandProperties('foo.{bar,baz}', echo);        //=> 'foo.bar', 'foo.baz'\nexpandProperties('{foo,bar}.baz', echo);        //=> 'foo.baz', 'bar.baz'\nexpandProperties('foo.{bar,baz}.[]', echo)      //=> 'foo.bar.[]', 'foo.baz.[]'\nexpandProperties('{foo,bar}.{spam,eggs}', echo) //=> 'foo.spam', 'foo.eggs', 'bar.spam', 'bar.eggs'\nexpandProperties('{foo}.bar.{baz}')             //=> 'foo.bar.baz'\n```",
            "itemtype": "method",
            "name": "expandProperties",
            "static": 1,
            "access": "public",
            "tagname": "",
            "params": [
              {
                "name": "pattern",
                "description": "The property pattern to expand.",
                "type": "String"
              },
              {
                "name": "callback",
                "description": "The callback to invoke.  It is invoked once per\nexpansion, and is passed the expansion.",
                "type": "Function"
              }
            ],
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 540,
            "itemtype": "method",
            "description": "Filters the array by the callback.\n\nThe callback method you provide should have the following signature:\n- `item` is the current item in the iteration.\n- `index` is the integer index of the current item in the iteration.\n- `array` is the dependant array itself.\n\n```javascript\nfunction filterCallback(item, index, array);\n```\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { filter } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(chores) {\n    set(this, 'chores', chores);\n  }\n\n  @filter('chores', ['doneKey'], function(chore, index, array) {\n    return !chore[this.doneKey];\n  })\n  remainingChores;\n}\n\nlet hamster = new Hamster([\n  { name: 'cook', finished: true },\n  { name: 'clean', finished: true },\n  { name: 'write more unit tests', finished: false }\n]);\n\nhamster.remainingChores; // [{name: 'write more unit tests', finished: false}]\n```\n",
            "name": "filter",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "additionalDependentKeys",
                "description": "optional array of additional dependent keys",
                "type": "Array",
                "optional": true
              },
              {
                "name": "callback",
                "description": "",
                "type": "Function"
              }
            ],
            "return": {
              "description": "the filtered array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 694,
            "itemtype": "method",
            "description": "Filters the array by the property and value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { filterBy } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(chores) {\n    set(this, 'chores', chores);\n  }\n\n  @filterBy('chores', 'done', false) remainingChores;\n}\n\nlet hamster = new Hamster([\n  { name: 'cook', done: true },\n  { name: 'clean', done: true },\n  { name: 'write more unit tests', done: false }\n]);\n\nhamster.remainingChores; // [{ name: 'write more unit tests', done: false }]\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { filterBy } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  remainingChores: filterBy('chores', 'done', false)\n});\n\nlet hamster = Hamster.create({\n  chores: [\n    { name: 'cook', done: true },\n    { name: 'clean', done: true },\n    { name: 'write more unit tests', done: false }\n  ]\n});\n\nhamster.remainingChores; // [{ name: 'write more unit tests', done: false }]\n```\n",
            "name": "filterBy",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "propertyKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "*"
              }
            ],
            "return": {
              "description": "the filtered array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 528,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\ngreater than the provided value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { gt } from '@ember/object/computed';\n\nclass Hamster {\n  @gt('numBananas', 10) hasTooManyBananas;\n}\n\nlet hamster = new Hamster();\n\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 11);\nhamster.hasTooManyBananas; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { gt } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  hasTooManyBananas: gt('numBananas', 10)\n});\n\nlet hamster = Hamster.create();\n\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 11);\nhamster.hasTooManyBananas; // true\n```\n",
            "name": "gt",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "Number"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is greater than given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 594,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\ngreater than or equal to the provided value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { gte } from '@ember/object/computed';\n\nclass Hamster {\n  @gte('numBananas', 10) hasTooManyBananas;\n}\n\nlet hamster = new Hamster();\n\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 10);\nhamster.hasTooManyBananas; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { gte } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  hasTooManyBananas: gte('numBananas', 10)\n});\n\nlet hamster = Hamster.create();\n\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 10);\nhamster.hasTooManyBananas; // true\n```\n",
            "name": "gte",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "Number"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is greater or equal then given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 1010,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the elements\ntwo or more dependent arrays have in common.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { intersect } from '@ember/object/computed';\n\nclass FriendGroups {\n  constructor(adaFriends, charlesFriends) {\n    set(this, 'adaFriends', adaFriends);\n    set(this, 'charlesFriends', charlesFriends);\n  }\n\n  @intersect('adaFriends', 'charlesFriends') friendsInCommon;\n}\n\nlet groups = new FriendGroups(\n  ['Charles Babbage', 'John Hobhouse', 'William King', 'Mary Somerville'],\n  ['William King', 'Mary Somerville', 'Ada Lovelace', 'George Peacock']\n);\n\ngroups.friendsInCommon; // ['William King', 'Mary Somerville']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { intersect } from '@ember/object/computed';\n\nlet FriendGroups = EmberObject.extend({\n  friendsInCommon: intersect('adaFriends', 'charlesFriends')\n});\n\nlet groups = FriendGroups.create({\n  adaFriends: ['Charles Babbage', 'John Hobhouse', 'William King', 'Mary Somerville'],\n  charlesFriends: ['William King', 'Mary Somerville', 'Ada Lovelace', 'George Peacock']\n});\n\ngroups.friendsInCommon; // ['William King', 'Mary Somerville']\n```\n",
            "name": "intersect",
            "static": 1,
            "params": [
              {
                "name": "propertyKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computes a new array with all the duplicated\nelements from the dependent arrays",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 660,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\nless than the provided value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { lt } from '@ember/object/computed';\n\nclass Hamster {\n  @lt('numBananas', 3) needsMoreBananas;\n}\n\nlet hamster = new Hamster();\n\nhamster.needsMoreBananas; // true\n\nset(hamster, 'numBananas', 3);\nhamster.needsMoreBananas; // false\n\nset(hamster, 'numBananas', 2);\nhamster.needsMoreBananas; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { lt } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  needsMoreBananas: lt('numBananas', 3)\n});\n\nlet hamster = Hamster.create();\n\nhamster.needsMoreBananas; // true\n\nset(hamster, 'numBananas', 3);\nhamster.needsMoreBananas; // false\n\nset(hamster, 'numBananas', 2);\nhamster.needsMoreBananas; // true\n```\n",
            "name": "lt",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "Number"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is less then given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 726,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\nless than or equal to the provided value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { lte } from '@ember/object/computed';\n\nclass Hamster {\n  @lte('numBananas', 3) needsMoreBananas;\n}\n\nlet hamster = new Hamster();\n\nhamster.needsMoreBananas; // true\n\nset(hamster, 'numBananas', 5);\nhamster.needsMoreBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.needsMoreBananas; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { lte } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  needsMoreBananas: lte('numBananas', 3)\n});\n\nlet hamster = Hamster.create();\n\nhamster.needsMoreBananas; // true\n\nset(hamster, 'numBananas', 5);\nhamster.needsMoreBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.needsMoreBananas; // true\n```\n",
            "name": "lte",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "Number"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is less or equal than given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 318,
            "itemtype": "method",
            "description": "Returns an array mapped via the callback\n\nThe callback method you provide should have the following signature:\n- `item` is the current item in the iteration.\n- `index` is the integer index of the current item in the iteration.\n\n```javascript\nfunction mapCallback(item, index);\n```\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { map } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(chores) {\n    set(this, 'chores', chores);\n  }\n\n  @map('chores', ['shouldUpperCase'], function(chore, index) {\n    if (this.shouldUpperCase) {\n      return `${chore.toUpperCase()}!`;\n    } else {\n      return `${chore}!`;\n    }\n  })\n  excitingChores;\n}\n\nlet hamster = new Hamster(['clean', 'write more unit tests']);\n\nhamster.excitingChores; // ['clean!', 'write more unit tests!']\n\nset(hamster, 'shouldUpperCase', true);\nhamster.excitingChores; // ['CLEAN!', 'WRITE MORE UNIT TESTS!']\n```\n",
            "name": "map",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "additionalDependentKeys",
                "description": "optional array of additional\ndependent keys",
                "type": "Array",
                "optional": true
              },
              {
                "name": "callback",
                "description": "",
                "type": "Function"
              }
            ],
            "return": {
              "description": "an array mapped via the callback",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 438,
            "itemtype": "method",
            "description": "Returns an array mapped to the specified key.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { mapBy } from '@ember/object/computed';\n\nclass Person {\n  children = [];\n  @mapBy('children', 'age') childAges;\n}\n\nlet lordByron = new Person();\n\nlordByron.childAges; // []\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.childAges; // [7]\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.childAges; // [7, 5, 8]\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { mapBy } from '@ember/object/computed';\n\nlet Person = EmberObject.extend({\n  childAges: mapBy('children', 'age')\n});\n\nlet lordByron = Person.create({ children: [] });\n\nlordByron.childAges; // []\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.childAges; // [7]\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.childAges; // [7, 5, 8]\n```\n",
            "name": "mapBy",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "propertyKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "an array mapped to the specified key",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 394,
            "itemtype": "method",
            "description": "A computed property which matches the original value for the dependent\nproperty against a given RegExp, returning `true` if the value matches the\nRegExp and `false` if it does not.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { match } from '@ember/object/computed';\n\nclass User {\n  @match('email', /^.+@.+\\..+$/) hasValidEmail;\n}\n\nlet user = new User();\n\nuser.hasValidEmail; // false\n\nset(user, 'email', '');\nuser.hasValidEmail; // false\n\nset(user, 'email', 'ember_hamster@example.com');\nuser.hasValidEmail; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { match } from '@ember/object/computed';\n\nlet User = EmberObject.extend({\n  hasValidEmail: match('email', /^.+@.+\\..+$/)\n});\n\nlet user = User.create();\n\nuser.hasValidEmail; // false\n\nset(user, 'email', '');\nuser.hasValidEmail; // false\n\nset(user, 'email', 'ember_hamster@example.com');\nuser.hasValidEmail; // true\n```\n",
            "name": "match",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "regexp",
                "description": "",
                "type": "RegExp"
              }
            ],
            "return": {
              "description": "computed property which match the original value\nfor property against a given RegExp",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 119,
            "itemtype": "method",
            "description": "A computed property that calculates the maximum value in the dependent array.\nThis will return `-Infinity` when the dependent array is empty.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { mapBy, max } from '@ember/object/computed';\n\nclass Person {\n  children = [];\n  @mapBy('children', 'age') childAges;\n  @max('childAges') maxChildAge;\n}\n\nlet lordByron = new Person();\n\nlordByron.maxChildAge; // -Infinity\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.maxChildAge; // 7\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.maxChildAge; // 8\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { mapBy, max } from '@ember/object/computed';\n\nlet Person = EmberObject.extend({\n  childAges: mapBy('children', 'age'),\n  maxChildAge: max('childAges')\n});\n\nlet lordByron = Person.create({ children: [] });\n\nlordByron.maxChildAge; // -Infinity\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.maxChildAge; // 7\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.maxChildAge; // 8\n```\n\nIf the types of the arguments are not numbers, they will be converted to\nnumbers and the type of the return value will always be `Number`. For example,\nthe max of a list of Date objects will be the highest timestamp as a `Number`.\nThis behavior is consistent with `Math.max`.\n",
            "name": "max",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes the largest value in the dependentKey's\narray",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 219,
            "itemtype": "method",
            "description": "A computed property that calculates the minimum value in the dependent array.\nThis will return `Infinity` when the dependent array is empty.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { mapBy, min } from '@ember/object/computed';\n\nclass Person {\n  children = [];\n  @mapBy('children', 'age') childAges;\n  @min('childAges') minChildAge;\n}\n\nlet lordByron = Person.create({ children: [] });\n\nlordByron.minChildAge; // Infinity\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.minChildAge; // 7\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.minChildAge; // 5\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { mapBy, min } from '@ember/object/computed';\n\nlet Person = EmberObject.extend({\n  childAges: mapBy('children', 'age'),\n  minChildAge: min('childAges')\n});\n\nlet lordByron = Person.create({ children: [] });\n\nlordByron.minChildAge; // Infinity\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.minChildAge; // 7\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.minChildAge; // 5\n```\n\nIf the types of the arguments are not numbers, they will be converted to\nnumbers and the type of the return value will always be `Number`. For example,\nthe min of a list of Date objects will be the lowest timestamp as a `Number`.\nThis behavior is consistent with `Math.min`.\n",
            "name": "min",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes the smallest value in the dependentKey's array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 196,
            "itemtype": "method",
            "description": "A computed property that returns true if the value of the dependent property\nis null or undefined. This avoids errors from JSLint complaining about use of\n==, which can be technically confusing.\n\n```javascript\nimport { set } from '@ember/object';\nimport { none } from '@ember/object/computed';\n\nclass Hamster {\n  @none('food') isHungry;\n}\n\nlet hamster = new Hamster();\n\nhamster.isHungry; // true\n\nset(hamster, 'food', 'Banana');\nhamster.isHungry; // false\n\nset(hamster, 'food', null);\nhamster.isHungry; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { none } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  isHungry: none('food')\n});\n\nlet hamster = Hamster.create();\n\nhamster.isHungry; // true\n\nset(hamster, 'food', 'Banana');\nhamster.isHungry; // false\n\nset(hamster, 'food', null);\nhamster.isHungry; // true\n```\n",
            "name": "none",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which returns true if original\nvalue for property is null or undefined.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 260,
            "itemtype": "method",
            "description": "A computed property that returns the inverse boolean value of the original\nvalue for the dependent property.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { not } from '@ember/object/computed';\n\nclass User {\n  loggedIn = false;\n  @not('loggedIn') isAnonymous;\n}\n\nlet user = new User();\n\nuser.isAnonymous; // true\nset(user, 'loggedIn', true);\nuser.isAnonymous; // false\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { not } from '@ember/object/computed';\n\nlet User = EmberObject.extend({\n  loggedIn: false,\n\n  isAnonymous: not('loggedIn')\n});\n\nlet user = User.create();\n\nuser.isAnonymous; // true\nset(user, 'loggedIn', true);\nuser.isAnonymous; // false\n```\n",
            "name": "not",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which returns inverse of the\noriginal value for property",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 131,
            "itemtype": "method",
            "description": "A computed property that returns true if the value of the dependent property\nis NOT null, an empty string, empty array, or empty function.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { notEmpty } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(backpack) {\n    set(this, 'backpack', backpack);\n  }\n\n  @notEmpty('backpack') hasStuff\n}\n\nlet hamster = new Hamster(\n  ['Food', 'Sleeping Bag', 'Tent']\n);\n\nhamster.hasStuff; // true\nset(hamster, 'backpack', []);\nhamster.hasStuff; // false\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { notEmpty } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  hasStuff: notEmpty('backpack')\n});\n\nlet hamster = Hamster.create({\n  backpack: ['Food', 'Sleeping Bag', 'Tent']\n});\n\nhamster.hasStuff; // true\nset(hamster, 'backpack', []);\nhamster.hasStuff; // false\n```\n",
            "name": "notEmpty",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which returns true if original\nvalue for property is not empty.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 990,
            "itemtype": "method",
            "description": "Where `computed.alias` aliases `get` and `set`, and allows for bidirectional\ndata flow, `computed.oneWay` only provides an aliased `get`. The `set` will\nnot mutate the upstream property, rather causes the current property to become\nthe value set. This causes the downstream property to permanently diverge from\nthe upstream property.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { oneWay }from '@ember/object/computed';\n\nclass User {\n  constructor(firstName, lastName) {\n    set(this, 'firstName', firstName);\n    set(this, 'lastName', lastName);\n  }\n\n  @oneWay('firstName') nickName;\n}\n\nlet teddy = new User('Teddy', 'Zeenny');\n\nteddy.nickName; // 'Teddy'\n\nset(teddy, 'nickName', 'TeddyBear');\nteddy.firstName; // 'Teddy'\nteddy.nickName; // 'TeddyBear'\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { oneWay } from '@ember/object/computed';\n\nlet User = EmberObject.extend({\n  firstName: null,\n  lastName: null,\n\n  nickName: oneWay('firstName')\n});\n\nlet teddy = User.create({\n  firstName: 'Teddy',\n  lastName: 'Zeenny'\n});\n\nteddy.nickName; // 'Teddy'\n\nset(teddy, 'nickName', 'TeddyBear'); // 'TeddyBear'\nteddy.firstName; // 'Teddy'\nteddy.nickName; // 'TeddyBear'\n```\n",
            "name": "oneWay",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which creates a one way computed\nproperty to the original value for property.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 866,
            "itemtype": "method",
            "description": "A computed property which performs a logical `or` on the original values for\nthe provided dependent properties.\n\nYou may pass in more than two properties and even use property brace\nexpansion.  The computed property will return the first truthy value or last\nfalsy value just like JavaScript's `||` operator.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { or } from '@ember/object/computed';\n\nclass Hamster {\n  @or('hasSunscreen', 'hasUmbrella') readyForBeach;\n}\n\nlet tomster = new Hamster();\n\ntomster.readyForRain; // undefined\n\nset(tomster, 'hasUmbrella', true);\ntomster.readyForRain; // true\n\nset(tomster, 'hasJacket', 'Yes');\ntomster.readyForRain; // 'Yes'\n\nset(tomster, 'hasSunscreen', 'Check');\ntomster.readyForBeach; // 'Check'\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { or } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  readyForRain: or('hasJacket', 'hasUmbrella'),\n  readyForBeach: or('hasSunscreen', 'hasUmbrella')\n});\n\nlet tomster = Hamster.create();\n\ntomster.readyForRain; // undefined\n\nset(tomster, 'hasUmbrella', true);\ntomster.readyForRain; // true\n\nset(tomster, 'hasJacket', 'Yes');\ntomster.readyForRain; // 'Yes'\n\nset(tomster, 'hasSunscreen', 'Check');\ntomster.readyForBeach; // 'Check'\n```\n",
            "name": "or",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computed property which performs a logical `or` on\nthe values of all the original values for properties.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 1076,
            "itemtype": "method",
            "description": "Where `computed.oneWay` provides oneWay bindings, `computed.readOnly` provides\na readOnly one way binding. Very often when using `computed.oneWay` one does\nnot also want changes to propagate back up, as they will replace the value.\n\nThis prevents the reverse flow, and also throws an exception when it occurs.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { readOnly } from '@ember/object/computed';\n\nclass User {\n  constructor(firstName, lastName) {\n    set(this, 'firstName', firstName);\n    set(this, 'lastName', lastName);\n  }\n\n  @readOnly('firstName') nickName;\n});\n\nlet teddy = new User('Teddy', 'Zeenny');\n\nteddy.nickName; // 'Teddy'\n\nset(teddy, 'nickName', 'TeddyBear'); // throws Exception\n// throw new EmberError('Cannot Set: nickName on: <User:ember27288>' );`\n\nteddy.firstName; // 'Teddy'\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { readOnly } from '@ember/object/computed';\n\nlet User = EmberObject.extend({\n  firstName: null,\n  lastName: null,\n\n  nickName: readOnly('firstName')\n});\n\nlet teddy = User.create({\n  firstName: 'Teddy',\n  lastName:  'Zeenny'\n});\n\nteddy.nickName; // 'Teddy'\n\nset(teddy, 'nickName', 'TeddyBear'); // throws Exception\n// throw new EmberError('Cannot Set: nickName on: <User:ember27288>' );`\n\nteddy.firstName; // 'Teddy'\n```\n",
            "name": "readOnly",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which creates a one way computed\nproperty to the original value for property.",
              "type": "ComputedProperty"
            },
            "since": "1.5.0",
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 1063,
            "description": "This is a more semantically meaningful alias of `computed.oneWay`, whose name\nis somewhat ambiguous as to which direction the data flows.",
            "itemtype": "method",
            "name": "reads",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which creates a one way computed\n  property to the original value for property.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 1102,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the properties from the\nfirst dependent array that are not in the second dependent array.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { setDiff } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(likes, fruits) {\n    set(this, 'likes', likes);\n    set(this, 'fruits', fruits);\n  }\n\n  @setDiff('likes', 'fruits') wants;\n}\n\nlet hamster = new Hamster(\n  [\n    'banana',\n    'grape',\n    'kale'\n  ],\n  [\n    'grape',\n    'kale',\n  ]\n);\n\nhamster.wants; // ['banana']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { setDiff } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  wants: setDiff('likes', 'fruits')\n});\n\nlet hamster = Hamster.create({\n  likes: [\n    'banana',\n    'grape',\n    'kale'\n  ],\n  fruits: [\n    'grape',\n    'kale',\n  ]\n});\n\nhamster.wants; // ['banana']\n```\n",
            "name": "setDiff",
            "static": 1,
            "params": [
              {
                "name": "setAProperty",
                "description": "",
                "type": "String"
              },
              {
                "name": "setBProperty",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes a new array with all the items from the\nfirst dependent array that are not in the second dependent array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 1267,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the properties from the\nfirst dependent array sorted based on a property or sort function. The sort\nmacro can be used in two different ways:\n\n1. By providing a sort callback function\n2. By providing an array of keys to sort the array\n\nIn the first form, the callback method you provide should have the following\nsignature:\n\n```javascript\nfunction sortCallback(itemA, itemB);\n```\n\n- `itemA` the first item to compare.\n- `itemB` the second item to compare.\n\nThis function should return negative number (e.g. `-1`) when `itemA` should\ncome before `itemB`. It should return positive number (e.g. `1`) when `itemA`\nshould come after `itemB`. If the `itemA` and `itemB` are equal this function\nshould return `0`.\n\nTherefore, if this function is comparing some numeric values, simple `itemA -\nitemB` or `itemA.get( 'foo' ) - itemB.get( 'foo' )` can be used instead of\nseries of `if`.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { sort } from '@ember/object/computed';\n\nclass ToDoList {\n  constructor(todos) {\n    set(this, 'todos', todos);\n  }\n\n  // using a custom sort function\n  @sort('todos', 'todosSortingDesc') sortedTodosDesc;\n}\n\nlet todoList = new ToDoList([\n  { name: 'Unit Test', priority: 2 },\n  { name: 'Documentation', priority: 3 },\n  { name: 'Release', priority: 1 }\n]);\n\ntodoList.sortedTodos; // [{ name:'Documentation', priority:3 }, { name:'Release', priority:1 }, { name:'Unit Test', priority:2 }]\ntodoList.sortedTodosDesc; // [{ name:'Unit Test', priority:2 }, { name:'Release', priority:1 }, { name:'Documentation', priority:3 }]\n```\n",
            "name": "sort",
            "static": 1,
            "params": [
              {
                "name": "itemsKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "additionalDependentKeys",
                "description": "optional array of additional\ndependent keys",
                "type": "Array",
                "optional": true
              },
              {
                "name": "sortDefinition",
                "description": "a dependent key to an array of sort\nproperties (add `:desc` to the arrays sort properties to sort descending) or a\nfunction to use when sorting",
                "type": "String or Function"
              }
            ],
            "return": {
              "description": "computes a new sorted array based on the sort\nproperty array or callback function",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 65,
            "itemtype": "method",
            "description": "A computed property that returns the sum of the values in the dependent array.\n\nExample:\n\n```javascript\nimport { sum } from '@ember/object/computed';\n\nclass Invoice {\n  lineItems = [1.00, 2.50, 9.99];\n  @sum('lineItems') total;\n}\n\nlet invoice = new Invoice();\n\ninvoice.total; // 13.49\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { sum } from '@ember/object/computed';\n\nlet Invoice = EmberObject.extend({\n  lineItems: [1.00, 2.50, 9.99],\n\n  total: sum('lineItems')\n})\n\nlet invoice = Invoice.create();\n\ninvoice.total; // 13.49\n```\n",
            "name": "sum",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes the sum of all values in the\ndependentKey's array",
              "type": "ComputedProperty"
            },
            "since": "1.4.0",
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 935,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the unique elements\nfrom one or more dependent arrays.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { union } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(fruits, vegetables) {\n    set(this, 'fruits', fruits);\n    set(this, 'vegetables', vegetables);\n  }\n\n  @union('fruits', 'vegetables') ediblePlants;\n});\n\nlet hamster = new, Hamster(\n  [\n    'banana',\n    'grape',\n    'kale',\n    'banana',\n    'tomato'\n  ],\n  [\n    'tomato',\n    'carrot',\n    'lettuce'\n  ]\n);\n\nhamster.uniqueFruits; // ['banana', 'grape', 'kale', 'tomato', 'carrot', 'lettuce']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { union } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  uniqueFruits: union('fruits', 'vegetables')\n});\n\nlet hamster = Hamster.create({\n  fruits: [\n    'banana',\n    'grape',\n    'kale',\n    'banana',\n    'tomato'\n  ],\n  vegetables: [\n    'tomato',\n    'carrot',\n    'lettuce'\n  ]\n});\n\nhamster.uniqueFruits; // ['banana', 'grape', 'kale', 'tomato', 'carrot', 'lettuce']\n```\n",
            "name": "union",
            "static": 1,
            "params": [
              {
                "name": "propertyKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computes a new array with all the unique elements\nfrom one or more dependent arrays.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 771,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the unique elements\nfrom one or more dependent arrays.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { uniq } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(fruits) {\n    set(this, 'fruits', fruits);\n  }\n\n  @uniq('fruits') uniqueFruits;\n}\n\nlet hamster = new Hamster([\n  'banana',\n  'grape',\n  'kale',\n  'banana'\n]);\n\nhamster.uniqueFruits; // ['banana', 'grape', 'kale']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { uniq } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  uniqueFruits: uniq('fruits')\n});\n\nlet hamster = Hamster.create({\n  fruits: [\n    'banana',\n    'grape',\n    'kale',\n    'banana'\n  ]\n});\n\nhamster.uniqueFruits; // ['banana', 'grape', 'kale']\n```\n",
            "name": "uniq",
            "static": 1,
            "params": [
              {
                "name": "propertyKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computes a new array with all the\nunique elements from the dependent array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 859,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the unique elements\nfrom an array, with uniqueness determined by specific key.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { uniqBy } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(fruits) {\n    set(this, 'fruits', fruits);\n  }\n\n  @uniqBy('fruits', 'id') uniqueFruits;\n}\n\nlet hamster = new Hamster([\n  { id: 1, 'banana' },\n  { id: 2, 'grape' },\n  { id: 3, 'peach' },\n  { id: 1, 'banana' }\n]);\n\nhamster.uniqueFruits; // [ { id: 1, 'banana' }, { id: 2, 'grape' }, { id: 3, 'peach' }]\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { uniqBy } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  uniqueFruits: uniqBy('fruits', 'id')\n});\n\nlet hamster = Hamster.create({\n  fruits: [\n    { id: 1, 'banana' },\n    { id: 2, 'grape' },\n    { id: 3, 'peach' },\n    { id: 1, 'banana' }\n  ]\n});\n\nhamster.uniqueFruits; // [ { id: 1, 'banana' }, { id: 2, 'grape' }, { id: 3, 'peach' }]\n```\n",
            "name": "uniqBy",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "propertyKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes a new array with all the\nunique elements from the dependent array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          }
        ],
        "@ember/object": [
          {
            "file": "packages/@ember/-internals/metal/lib/mixin.ts",
            "line": 796,
            "description": "Makes a method available via an additional name.\n\n```app/utils/person.js\nimport EmberObject, {\n  aliasMethod\n} from '@ember/object';\n\nexport default EmberObject.extend({\n  name() {\n    return 'Tomhuda Katzdale';\n  },\n  moniker: aliasMethod('name')\n});\n```\n\n```javascript\nlet goodGuy = Person.create();\n\ngoodGuy.name();    // 'Tomhuda Katzdale'\ngoodGuy.moniker(); // 'Tomhuda Katzdale'\n```",
            "itemtype": "method",
            "name": "aliasMethod",
            "static": 1,
            "deprecated": true,
            "deprecationMessage": "Use a shared utility method instead",
            "params": [
              {
                "name": "methodName",
                "description": "name of the method to alias",
                "type": "String"
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/computed.ts",
            "line": 764,
            "description": "This helper returns a new property descriptor that wraps the passed\ncomputed property function. You can use this helper to define properties\nwith mixins or via `defineProperty()`.\n\nIf you pass a function as an argument, it will be used as a getter. A computed\nproperty defined in this way might look like this:\n\n```js\nimport EmberObject, { computed } from '@ember/object';\n\nlet Person = EmberObject.extend({\n  init() {\n    this._super(...arguments);\n\n    this.firstName = 'Betty';\n    this.lastName = 'Jones';\n  },\n\n  fullName: computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  })\n});\n\nlet client = Person.create();\n\nclient.get('fullName'); // 'Betty Jones'\n\nclient.set('lastName', 'Fuller');\nclient.get('fullName'); // 'Betty Fuller'\n```\n\nYou can pass a hash with two functions, `get` and `set`, as an\nargument to provide both a getter and setter:\n\n```js\nimport EmberObject, { computed } from '@ember/object';\n\nlet Person = EmberObject.extend({\n  init() {\n    this._super(...arguments);\n\n    this.firstName = 'Betty';\n    this.lastName = 'Jones';\n  },\n\n  fullName: computed('firstName', 'lastName', {\n    get(key) {\n      return `${this.get('firstName')} ${this.get('lastName')}`;\n    },\n    set(key, value) {\n      let [firstName, lastName] = value.split(/\\s+/);\n      this.setProperties({ firstName, lastName });\n      return value;\n    }\n  })\n});\n\nlet client = Person.create();\nclient.get('firstName'); // 'Betty'\n\nclient.set('fullName', 'Carroll Fuller');\nclient.get('firstName'); // 'Carroll'\n```\n\nThe `set` function should accept two parameters, `key` and `value`. The value\nreturned from `set` will be the new value of the property.\n\n_Note: This is the preferred way to define computed properties when writing third-party\nlibraries that depend on or use Ember, since there is no guarantee that the user\nwill have [prototype Extensions](https://guides.emberjs.com/release/configuring-ember/disabling-prototype-extensions/) enabled._\n\nThe alternative syntax, with prototype extensions, might look like:\n\n```js\nfullName: function() {\n  return this.get('firstName') + ' ' + this.get('lastName');\n}.property('firstName', 'lastName')\n```",
            "itemtype": "method",
            "name": "computed",
            "static": 1,
            "params": [
              {
                "name": "dependentKeys*",
                "description": "Optional dependent keys that trigger this computed property.",
                "type": "String",
                "optional": true
              },
              {
                "name": "func",
                "description": "The computed property function.",
                "type": "Function"
              }
            ],
            "return": {
              "description": "property decorator instance",
              "type": "ComputedDecorator"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 747,
            "description": "Creates an instance of a class. Accepts either no arguments, or an object\ncontaining values to initialize the newly instantiated object with.\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst Person = EmberObject.extend({\n  helloWorld() {\n    alert(`Hi, my name is ${this.get('name')}`);\n  }\n});\n\nlet tom = Person.create({\n  name: 'Tom Dale'\n});\n\ntom.helloWorld(); // alerts \"Hi, my name is Tom Dale\".\n```\n\n`create` will call the `init` function if defined during\n`AnyObject.extend`\n\nIf no arguments are passed to `create`, it will not set values to the new\ninstance during initialization:\n\n```javascript\nlet noName = Person.create();\nnoName.helloWorld(); // alerts undefined\n```\n\nNOTE: For performance reasons, you cannot declare methods or computed\nproperties during `create`. You should instead declare methods and computed\nproperties when using `extend`.",
            "itemtype": "method",
            "name": "create",
            "static": 1,
            "params": [
              {
                "name": "arguments",
                "description": "",
                "optional": true,
                "multiple": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/properties.ts",
            "line": 76,
            "description": "NOTE: This is a low-level method used by other parts of the API. You almost\nnever want to call this method directly. Instead you should use\n`mixin()` to define new properties.\n\nDefines a property on an object. This method works much like the ES5\n`Object.defineProperty()` method except that it can also accept computed\nproperties and other special descriptors.\n\nNormally this method takes only three parameters. However if you pass an\ninstance of `Descriptor` as the third param then you can pass an\noptional value as the fourth parameter. This is often more efficient than\ncreating new descriptor hashes for each property.\n\n## Examples\n\n```javascript\nimport { defineProperty, computed } from '@ember/object';\n\n// ES5 compatible mode\ndefineProperty(contact, 'firstName', {\n  writable: true,\n  configurable: false,\n  enumerable: true,\n  value: 'Charles'\n});\n\n// define a simple property\ndefineProperty(contact, 'lastName', undefined, 'Jolley');\n\n// define a computed property\ndefineProperty(contact, 'fullName', computed('firstName', 'lastName', function() {\n  return this.firstName+' '+this.lastName;\n}));\n```",
            "access": "public",
            "tagname": "",
            "itemtype": "method",
            "name": "defineProperty",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "the object to define this property on. This may be a prototype.",
                "type": "Object"
              },
              {
                "name": "keyName",
                "description": "the name of the property",
                "type": "String"
              },
              {
                "name": "desc",
                "description": "an instance of `Descriptor` (typically a\n  computed property) or an ES5 descriptor.\n  You must provide this or `data` but not both.",
                "type": "Descriptor",
                "optional": true
              },
              {
                "name": "data",
                "description": "something other than a descriptor, that will\n  become the explicit value of this property.",
                "type": "*",
                "optional": true
              }
            ],
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 647,
            "description": "Creates a new subclass.\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst Person = EmberObject.extend({\n  say(thing) {\n    alert(thing);\n   }\n});\n```\n\nThis defines a new subclass of EmberObject: `Person`. It contains one method: `say()`.\n\nYou can also create a subclass from any existing class by calling its `extend()` method.\nFor example, you might want to create a subclass of Ember's built-in `Component` class:\n\n```javascript\nimport Component from '@ember/component';\n\nconst PersonComponent = Component.extend({\n  tagName: 'li',\n  classNameBindings: ['isAdministrator']\n});\n```\n\nWhen defining a subclass, you can override methods but still access the\nimplementation of your parent class by calling the special `_super()` method:\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst Person = EmberObject.extend({\n  say(thing) {\n    let name = this.get('name');\n    alert(`${name} says: ${thing}`);\n  }\n});\n\nconst Soldier = Person.extend({\n  say(thing) {\n    this._super(`${thing}, sir!`);\n  },\n  march(numberOfHours) {\n    alert(`${this.get('name')} marches for ${numberOfHours} hours.`);\n  }\n});\n\nlet yehuda = Soldier.create({\n  name: 'Yehuda Katz'\n});\n\nyehuda.say('Yes');  // alerts \"Yehuda Katz says: Yes, sir!\"\n```\n\nThe `create()` on line #17 creates an *instance* of the `Soldier` class.\nThe `extend()` on line #8 creates a *subclass* of `Person`. Any instance\nof the `Person` class will *not* have the `march()` method.\n\nYou can also pass `Mixin` classes to add additional properties to the subclass.\n\n```javascript\nimport EmberObject from '@ember/object';\nimport Mixin from '@ember/object/mixin';\n\nconst Person = EmberObject.extend({\n  say(thing) {\n    alert(`${this.get('name')} says: ${thing}`);\n  }\n});\n\nconst SingingMixin = Mixin.create({\n  sing(thing) {\n    alert(`${this.get('name')} sings: la la la ${thing}`);\n  }\n});\n\nconst BroadwayStar = Person.extend(SingingMixin, {\n  dance() {\n    alert(`${this.get('name')} dances: tap tap tap tap `);\n  }\n});\n```\n\nThe `BroadwayStar` class contains three methods: `say()`, `sing()`, and `dance()`.",
            "itemtype": "method",
            "name": "extend",
            "static": 1,
            "params": [
              {
                "name": "mixins",
                "description": "One or more Mixin classes",
                "type": "Mixin",
                "optional": true,
                "multiple": true
              },
              {
                "name": "arguments",
                "description": "Object containing values to use within the new class",
                "type": "Object",
                "optional": true,
                "multiple": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/property_get.ts",
            "line": 44,
            "description": "Gets the value of a property on an object. If the property is computed,\nthe function will be invoked. If the property is not defined but the\nobject implements the `unknownProperty` method then that will be invoked.\n\n```javascript\nimport { get } from '@ember/object';\nget(obj, \"name\");\n```\n\nIf you plan to run on IE8 and older browsers then you should use this\nmethod anytime you want to retrieve a property on an object that you don't\nknow for sure is private. (Properties beginning with an underscore '_'\nare considered private.)\n\nOn all newer browsers, you only need to use this method to retrieve\nproperties if the property might not be defined on the object and you want\nto respect the `unknownProperty` handler. Otherwise you can ignore this\nmethod.\n\nNote that if the object itself is `undefined`, this method will throw\nan error.",
            "itemtype": "method",
            "name": "get",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "The object to retrieve from.",
                "type": "Object"
              },
              {
                "name": "keyName",
                "description": "The property key to retrieve",
                "type": "String"
              }
            ],
            "return": {
              "description": "the property value or `null`.",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/get_properties.ts",
            "line": 6,
            "description": "To get multiple properties at once, call `getProperties`\nwith an object followed by a list of strings or an array:\n\n```javascript\nimport { getProperties } from '@ember/object';\n\ngetProperties(record, 'firstName', 'lastName', 'zipCode');\n// { firstName: 'John', lastName: 'Doe', zipCode: '10011' }\n```\n\nis equivalent to:\n\n```javascript\nimport { getProperties } from '@ember/object';\n\ngetProperties(record, ['firstName', 'lastName', 'zipCode']);\n// { firstName: 'John', lastName: 'Doe', zipCode: '10011' }\n```",
            "itemtype": "method",
            "name": "getProperties",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "",
                "type": "Object"
              },
              {
                "name": "list",
                "description": "of keys to get",
                "type": "String...|Array"
              }
            ],
            "return": {
              "description": "",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/property_get.ts",
            "line": 165,
            "description": "Retrieves the value of a property from an Object, or a default value in the\ncase that the property returns `undefined`.\n\n```javascript\nimport { getWithDefault } from '@ember/object';\ngetWithDefault(person, 'lastName', 'Doe');\n```",
            "itemtype": "method",
            "name": "getWithDefault",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "The object to retrieve from.",
                "type": "Object"
              },
              {
                "name": "keyName",
                "description": "The name of the property to retrieve",
                "type": "String"
              },
              {
                "name": "defaultValue",
                "description": "The value to return if the property value is undefined",
                "type": "Object"
              }
            ],
            "return": {
              "description": "The property value or the defaultValue.",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/mixin.ts",
            "line": 849,
            "description": "Specify a method that observes property changes.\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { observer } from '@ember/object';\n\nexport default EmberObject.extend({\n  valueObserver: observer('value', function() {\n    // Executes whenever the \"value\" property changes\n  })\n});\n```\n\nAlso available as `Function.prototype.observes` if prototype extensions are\nenabled.",
            "itemtype": "method",
            "name": "observer",
            "params": [
              {
                "name": "propertyNames",
                "description": "",
                "type": "String",
                "multiple": true
              },
              {
                "name": "func",
                "description": "",
                "type": "Function"
              }
            ],
            "return": {
              "description": "func"
            },
            "access": "public",
            "tagname": "",
            "static": 1,
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 822,
            "description": "Augments a constructor's prototype with additional\nproperties and functions:\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst MyObject = EmberObject.extend({\n  name: 'an object'\n});\n\no = MyObject.create();\no.get('name'); // 'an object'\n\nMyObject.reopen({\n  say(msg) {\n    console.log(msg);\n  }\n});\n\no2 = MyObject.create();\no2.say('hello'); // logs \"hello\"\n\no.say('goodbye'); // logs \"goodbye\"\n```\n\nTo add functions and properties to the constructor itself,\nsee `reopenClass`",
            "itemtype": "method",
            "name": "reopen",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 876,
            "description": "Augments a constructor's own properties and functions:\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst MyObject = EmberObject.extend({\n  name: 'an object'\n});\n\nMyObject.reopenClass({\n  canBuild: false\n});\n\nMyObject.canBuild; // false\no = MyObject.create();\n```\n\nIn other words, this creates static properties and functions for the class.\nThese are only available on the class and not on any instance of that class.\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst Person = EmberObject.extend({\n  name: '',\n  sayHello() {\n    alert(`Hello. My name is ${this.get('name')}`);\n  }\n});\n\nPerson.reopenClass({\n  species: 'Homo sapiens',\n\n  createPerson(name) {\n    return Person.create({ name });\n  }\n});\n\nlet tom = Person.create({\n  name: 'Tom Dale'\n});\nlet yehuda = Person.createPerson('Yehuda Katz');\n\ntom.sayHello(); // \"Hello. My name is Tom Dale\"\nyehuda.sayHello(); // \"Hello. My name is Yehuda Katz\"\nalert(Person.species); // \"Homo sapiens\"\n```\n\nNote that `species` and `createPerson` are *not* valid on the `tom` and `yehuda`\nvariables. They are only valid on `Person`.\n\nTo add functions and properties to instances of\na constructor by extending the constructor's prototype\nsee `reopen`",
            "itemtype": "method",
            "name": "reopenClass",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/property_set.ts",
            "line": 35,
            "description": "Sets the value of a property on an object, respecting computed properties\nand notifying observers and other listeners of the change.\nIf the specified property is not defined on the object and the object\nimplements the `setUnknownProperty` method, then instead of setting the\nvalue of the property on the object, its `setUnknownProperty` handler\nwill be invoked with the two parameters `keyName` and `value`.\n\n```javascript\nimport { set } from '@ember/object';\nset(obj, \"name\", value);\n```",
            "itemtype": "method",
            "name": "set",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "The object to modify.",
                "type": "Object"
              },
              {
                "name": "keyName",
                "description": "The property key to set",
                "type": "String"
              },
              {
                "name": "value",
                "description": "The value to set",
                "type": "Object"
              }
            ],
            "return": {
              "description": "the passed value.",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/set_properties.ts",
            "line": 6,
            "description": "Set a list of properties on an object. These properties are set inside\na single `beginPropertyChanges` and `endPropertyChanges` batch, so\nobservers will be buffered.\n\n```javascript\nimport EmberObject from '@ember/object';\nlet anObject = EmberObject.create();\n\nanObject.setProperties({\n  firstName: 'Stanley',\n  lastName: 'Stuart',\n  age: 21\n});\n```",
            "itemtype": "method",
            "name": "setProperties",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "properties",
                "description": "",
                "type": "Object"
              }
            ],
            "return": {
              "description": "properties"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/property_set.ts",
            "line": 170,
            "description": "Error-tolerant form of `set`. Will not blow up if any part of the\nchain is `undefined`, `null`, or destroyed.\n\nThis is primarily used when syncing bindings, which may try to update after\nan object has been destroyed.\n\n```javascript\nimport { trySet } from '@ember/object';\n\nlet obj = { name: \"Zoey\" };\ntrySet(obj, \"contacts.twitter\", \"@emberjs\");\n```",
            "itemtype": "method",
            "name": "trySet",
            "static": 1,
            "params": [
              {
                "name": "root",
                "description": "The object to modify.",
                "type": "Object"
              },
              {
                "name": "path",
                "description": "The property path to set",
                "type": "String"
              },
              {
                "name": "value",
                "description": "The value to set",
                "type": "Object"
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          }
        ],
        "@ember/object/internals": [
          {
            "file": "packages/@ember/-internals/metal/lib/computed_cache.ts",
            "line": 7,
            "description": "Returns the cached value for a property, if one exists.\nThis can be useful for peeking at the value of a computed\nproperty that is generated lazily, without accidentally causing\nit to be created.",
            "itemtype": "method",
            "name": "cacheFor",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "the object whose property you want to check",
                "type": "Object"
              },
              {
                "name": "key",
                "description": "the name of the property whose cached value you want\n  to return",
                "type": "String"
              }
            ],
            "return": {
              "description": "the cached value",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/internals",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/copy.js",
            "line": 79,
            "description": "Creates a shallow copy of the passed object. A deep copy of the object is\nreturned if the optional `deep` argument is `true`.\n\nIf the passed object implements the `Copyable` interface, then this\nfunction will delegate to the object's `copy()` method and return the\nresult. See `Copyable` for further details.\n\nFor primitive values (which are immutable in JavaScript), the passed object\nis simply returned.",
            "itemtype": "method",
            "name": "copy",
            "deprecated": true,
            "deprecationMessage": "Use 'ember-copy' addon instead",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "The object to clone",
                "type": "Object"
              },
              {
                "name": "deep",
                "description": "If true, a deep copy of the object is made.",
                "type": "Boolean",
                "optional": true,
                "optdefault": "false"
              }
            ],
            "return": {
              "description": "The copied object",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/internals",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/utils/lib/guid.ts",
            "line": 86,
            "description": "Returns a unique id for the object. If the object does not yet have a guid,\none will be assigned to it. You can call this on any object,\n`EmberObject`-based or not.\n\nYou can also use this method on DOM Element objects.",
            "access": "public",
            "tagname": "",
            "static": 1,
            "itemtype": "method",
            "name": "guidFor",
            "params": [
              {
                "name": "obj",
                "description": "any object, string, number, Element, or primitive",
                "type": "Object"
              }
            ],
            "return": {
              "description": "the unique guid for this instance.",
              "type": "String"
            },
            "class": "@ember/object/internals",
            "module": "@ember/object"
          }
        ],
        "@ember/object/mixin": [
          {
            "file": "packages/@ember/-internals/metal/lib/mixin.ts",
            "line": 610,
            "itemtype": "method",
            "name": "create",
            "static": 1,
            "params": [
              {
                "name": "arguments",
                "description": "",
                "multiple": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/mixin",
            "module": "@ember/object"
          }
        ],
        "@ember/object/evented": [
          {
            "file": "packages/@ember/-internals/metal/lib/events.ts",
            "line": 177,
            "description": "Define a property as a function that should be executed when\na specified event or events are triggered.\n\n``` javascript\nimport EmberObject from '@ember/object';\nimport { on } from '@ember/object/evented';\nimport { sendEvent } from '@ember/object/events';\n\nlet Job = EmberObject.extend({\n  logCompleted: on('completed', function() {\n    console.log('Job completed!');\n  })\n});\n\nlet job = Job.create();\n\nsendEvent(job, 'completed'); // Logs 'Job completed!'\n ```",
            "itemtype": "method",
            "name": "on",
            "static": 1,
            "params": [
              {
                "name": "eventNames",
                "description": "",
                "type": "String",
                "multiple": true
              },
              {
                "name": "func",
                "description": "",
                "type": "Function"
              }
            ],
            "return": {
              "description": "the listener function, passed as last argument to on(...)",
              "type": "Function"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/evented",
            "module": "@ember/object"
          }
        ]
      },
      "allstaticfunctions": {
        "@ember/object": [
          {
            "file": "packages/@ember/object/index.js",
            "line": 6,
            "itemtype": "method",
            "description": "Decorator that turns the target function into an Action which can be accessed\ndirectly by reference.\n\n```js\nimport Component from '@ember/component';\nimport { action, set } from '@ember/object';\n\nexport default class Tooltip extends Component {\n  @action toggleShowing() {\n    set(this, 'isShowing', !this.isShowing);\n  }\n}\n```\n\nThis is considered best practice, since it means that methods will be bound\ncorrectly no matter where they are used. By contrast, the `{{action}}` helper\nand modifier can also be used to bind context, but it will be required for\nevery usage of the method:\n\n```hbs\n<!-- template.hbs -->\n<button\n  {{did-insert (action this.toggleShowing)}}\n  {{on \"click\" (action this.toggleShowing)}}\n>\n  Show tooltip\n</button>\n\n{{#if isShowing}}\n  <div class=\"tooltip\">\n    I'm a tooltip!\n  </div>\n{{/if}}\n```\n\nThey also do not have equivalents in JavaScript directly, so they cannot be\nused for other situations where binding would be useful.\n",
            "name": "action",
            "category": [
              "EMBER_NATIVE_DECORATOR_SUPPORT"
            ],
            "static": 1,
            "params": [
              {
                "name": "elementDesc",
                "description": "the descriptor of the element to decorate"
              }
            ],
            "return": {
              "description": "the decorated descriptor",
              "type": "ElementDescriptor"
            },
            "access": "private",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/mixin.ts",
            "line": 796,
            "description": "Makes a method available via an additional name.\n\n```app/utils/person.js\nimport EmberObject, {\n  aliasMethod\n} from '@ember/object';\n\nexport default EmberObject.extend({\n  name() {\n    return 'Tomhuda Katzdale';\n  },\n  moniker: aliasMethod('name')\n});\n```\n\n```javascript\nlet goodGuy = Person.create();\n\ngoodGuy.name();    // 'Tomhuda Katzdale'\ngoodGuy.moniker(); // 'Tomhuda Katzdale'\n```",
            "itemtype": "method",
            "name": "aliasMethod",
            "static": 1,
            "deprecated": true,
            "deprecationMessage": "Use a shared utility method instead",
            "params": [
              {
                "name": "methodName",
                "description": "name of the method to alias",
                "type": "String"
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/computed.ts",
            "line": 764,
            "description": "This helper returns a new property descriptor that wraps the passed\ncomputed property function. You can use this helper to define properties\nwith mixins or via `defineProperty()`.\n\nIf you pass a function as an argument, it will be used as a getter. A computed\nproperty defined in this way might look like this:\n\n```js\nimport EmberObject, { computed } from '@ember/object';\n\nlet Person = EmberObject.extend({\n  init() {\n    this._super(...arguments);\n\n    this.firstName = 'Betty';\n    this.lastName = 'Jones';\n  },\n\n  fullName: computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  })\n});\n\nlet client = Person.create();\n\nclient.get('fullName'); // 'Betty Jones'\n\nclient.set('lastName', 'Fuller');\nclient.get('fullName'); // 'Betty Fuller'\n```\n\nYou can pass a hash with two functions, `get` and `set`, as an\nargument to provide both a getter and setter:\n\n```js\nimport EmberObject, { computed } from '@ember/object';\n\nlet Person = EmberObject.extend({\n  init() {\n    this._super(...arguments);\n\n    this.firstName = 'Betty';\n    this.lastName = 'Jones';\n  },\n\n  fullName: computed('firstName', 'lastName', {\n    get(key) {\n      return `${this.get('firstName')} ${this.get('lastName')}`;\n    },\n    set(key, value) {\n      let [firstName, lastName] = value.split(/\\s+/);\n      this.setProperties({ firstName, lastName });\n      return value;\n    }\n  })\n});\n\nlet client = Person.create();\nclient.get('firstName'); // 'Betty'\n\nclient.set('fullName', 'Carroll Fuller');\nclient.get('firstName'); // 'Carroll'\n```\n\nThe `set` function should accept two parameters, `key` and `value`. The value\nreturned from `set` will be the new value of the property.\n\n_Note: This is the preferred way to define computed properties when writing third-party\nlibraries that depend on or use Ember, since there is no guarantee that the user\nwill have [prototype Extensions](https://guides.emberjs.com/release/configuring-ember/disabling-prototype-extensions/) enabled._\n\nThe alternative syntax, with prototype extensions, might look like:\n\n```js\nfullName: function() {\n  return this.get('firstName') + ' ' + this.get('lastName');\n}.property('firstName', 'lastName')\n```",
            "itemtype": "method",
            "name": "computed",
            "static": 1,
            "params": [
              {
                "name": "dependentKeys*",
                "description": "Optional dependent keys that trigger this computed property.",
                "type": "String",
                "optional": true
              },
              {
                "name": "func",
                "description": "The computed property function.",
                "type": "Function"
              }
            ],
            "return": {
              "description": "property decorator instance",
              "type": "ComputedDecorator"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 747,
            "description": "Creates an instance of a class. Accepts either no arguments, or an object\ncontaining values to initialize the newly instantiated object with.\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst Person = EmberObject.extend({\n  helloWorld() {\n    alert(`Hi, my name is ${this.get('name')}`);\n  }\n});\n\nlet tom = Person.create({\n  name: 'Tom Dale'\n});\n\ntom.helloWorld(); // alerts \"Hi, my name is Tom Dale\".\n```\n\n`create` will call the `init` function if defined during\n`AnyObject.extend`\n\nIf no arguments are passed to `create`, it will not set values to the new\ninstance during initialization:\n\n```javascript\nlet noName = Person.create();\nnoName.helloWorld(); // alerts undefined\n```\n\nNOTE: For performance reasons, you cannot declare methods or computed\nproperties during `create`. You should instead declare methods and computed\nproperties when using `extend`.",
            "itemtype": "method",
            "name": "create",
            "static": 1,
            "params": [
              {
                "name": "arguments",
                "description": "",
                "optional": true,
                "multiple": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/properties.ts",
            "line": 76,
            "description": "NOTE: This is a low-level method used by other parts of the API. You almost\nnever want to call this method directly. Instead you should use\n`mixin()` to define new properties.\n\nDefines a property on an object. This method works much like the ES5\n`Object.defineProperty()` method except that it can also accept computed\nproperties and other special descriptors.\n\nNormally this method takes only three parameters. However if you pass an\ninstance of `Descriptor` as the third param then you can pass an\noptional value as the fourth parameter. This is often more efficient than\ncreating new descriptor hashes for each property.\n\n## Examples\n\n```javascript\nimport { defineProperty, computed } from '@ember/object';\n\n// ES5 compatible mode\ndefineProperty(contact, 'firstName', {\n  writable: true,\n  configurable: false,\n  enumerable: true,\n  value: 'Charles'\n});\n\n// define a simple property\ndefineProperty(contact, 'lastName', undefined, 'Jolley');\n\n// define a computed property\ndefineProperty(contact, 'fullName', computed('firstName', 'lastName', function() {\n  return this.firstName+' '+this.lastName;\n}));\n```",
            "access": "public",
            "tagname": "",
            "itemtype": "method",
            "name": "defineProperty",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "the object to define this property on. This may be a prototype.",
                "type": "Object"
              },
              {
                "name": "keyName",
                "description": "the name of the property",
                "type": "String"
              },
              {
                "name": "desc",
                "description": "an instance of `Descriptor` (typically a\n  computed property) or an ES5 descriptor.\n  You must provide this or `data` but not both.",
                "type": "Descriptor",
                "optional": true
              },
              {
                "name": "data",
                "description": "something other than a descriptor, that will\n  become the explicit value of this property.",
                "type": "*",
                "optional": true
              }
            ],
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 1002,
            "description": "Iterate over each computed property for the class, passing its name\nand any associated metadata (see `metaForProperty`) to the callback.",
            "static": 1,
            "itemtype": "method",
            "name": "eachComputedProperty",
            "params": [
              {
                "name": "callback",
                "description": "",
                "type": "Function"
              },
              {
                "name": "binding",
                "description": "",
                "type": "Object"
              }
            ],
            "access": "private",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 647,
            "description": "Creates a new subclass.\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst Person = EmberObject.extend({\n  say(thing) {\n    alert(thing);\n   }\n});\n```\n\nThis defines a new subclass of EmberObject: `Person`. It contains one method: `say()`.\n\nYou can also create a subclass from any existing class by calling its `extend()` method.\nFor example, you might want to create a subclass of Ember's built-in `Component` class:\n\n```javascript\nimport Component from '@ember/component';\n\nconst PersonComponent = Component.extend({\n  tagName: 'li',\n  classNameBindings: ['isAdministrator']\n});\n```\n\nWhen defining a subclass, you can override methods but still access the\nimplementation of your parent class by calling the special `_super()` method:\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst Person = EmberObject.extend({\n  say(thing) {\n    let name = this.get('name');\n    alert(`${name} says: ${thing}`);\n  }\n});\n\nconst Soldier = Person.extend({\n  say(thing) {\n    this._super(`${thing}, sir!`);\n  },\n  march(numberOfHours) {\n    alert(`${this.get('name')} marches for ${numberOfHours} hours.`);\n  }\n});\n\nlet yehuda = Soldier.create({\n  name: 'Yehuda Katz'\n});\n\nyehuda.say('Yes');  // alerts \"Yehuda Katz says: Yes, sir!\"\n```\n\nThe `create()` on line #17 creates an *instance* of the `Soldier` class.\nThe `extend()` on line #8 creates a *subclass* of `Person`. Any instance\nof the `Person` class will *not* have the `march()` method.\n\nYou can also pass `Mixin` classes to add additional properties to the subclass.\n\n```javascript\nimport EmberObject from '@ember/object';\nimport Mixin from '@ember/object/mixin';\n\nconst Person = EmberObject.extend({\n  say(thing) {\n    alert(`${this.get('name')} says: ${thing}`);\n  }\n});\n\nconst SingingMixin = Mixin.create({\n  sing(thing) {\n    alert(`${this.get('name')} sings: la la la ${thing}`);\n  }\n});\n\nconst BroadwayStar = Person.extend(SingingMixin, {\n  dance() {\n    alert(`${this.get('name')} dances: tap tap tap tap `);\n  }\n});\n```\n\nThe `BroadwayStar` class contains three methods: `say()`, `sing()`, and `dance()`.",
            "itemtype": "method",
            "name": "extend",
            "static": 1,
            "params": [
              {
                "name": "mixins",
                "description": "One or more Mixin classes",
                "type": "Mixin",
                "optional": true,
                "multiple": true
              },
              {
                "name": "arguments",
                "description": "Object containing values to use within the new class",
                "type": "Object",
                "optional": true,
                "multiple": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/property_get.ts",
            "line": 44,
            "description": "Gets the value of a property on an object. If the property is computed,\nthe function will be invoked. If the property is not defined but the\nobject implements the `unknownProperty` method then that will be invoked.\n\n```javascript\nimport { get } from '@ember/object';\nget(obj, \"name\");\n```\n\nIf you plan to run on IE8 and older browsers then you should use this\nmethod anytime you want to retrieve a property on an object that you don't\nknow for sure is private. (Properties beginning with an underscore '_'\nare considered private.)\n\nOn all newer browsers, you only need to use this method to retrieve\nproperties if the property might not be defined on the object and you want\nto respect the `unknownProperty` handler. Otherwise you can ignore this\nmethod.\n\nNote that if the object itself is `undefined`, this method will throw\nan error.",
            "itemtype": "method",
            "name": "get",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "The object to retrieve from.",
                "type": "Object"
              },
              {
                "name": "keyName",
                "description": "The property key to retrieve",
                "type": "String"
              }
            ],
            "return": {
              "description": "the property value or `null`.",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/get_properties.ts",
            "line": 6,
            "description": "To get multiple properties at once, call `getProperties`\nwith an object followed by a list of strings or an array:\n\n```javascript\nimport { getProperties } from '@ember/object';\n\ngetProperties(record, 'firstName', 'lastName', 'zipCode');\n// { firstName: 'John', lastName: 'Doe', zipCode: '10011' }\n```\n\nis equivalent to:\n\n```javascript\nimport { getProperties } from '@ember/object';\n\ngetProperties(record, ['firstName', 'lastName', 'zipCode']);\n// { firstName: 'John', lastName: 'Doe', zipCode: '10011' }\n```",
            "itemtype": "method",
            "name": "getProperties",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "",
                "type": "Object"
              },
              {
                "name": "list",
                "description": "of keys to get",
                "type": "String...|Array"
              }
            ],
            "return": {
              "description": "",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/property_get.ts",
            "line": 165,
            "description": "Retrieves the value of a property from an Object, or a default value in the\ncase that the property returns `undefined`.\n\n```javascript\nimport { getWithDefault } from '@ember/object';\ngetWithDefault(person, 'lastName', 'Doe');\n```",
            "itemtype": "method",
            "name": "getWithDefault",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "The object to retrieve from.",
                "type": "Object"
              },
              {
                "name": "keyName",
                "description": "The name of the property to retrieve",
                "type": "String"
              },
              {
                "name": "defaultValue",
                "description": "The value to return if the property value is undefined",
                "type": "Object"
              }
            ],
            "return": {
              "description": "The property value or the defaultValue.",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 959,
            "description": "In some cases, you may want to annotate computed properties with additional\nmetadata about how they function or what values they operate on. For\nexample, computed property functions may close over variables that are then\nno longer available for introspection.\n\nYou can pass a hash of these values to a computed property like this:\n\n```javascript\nimport { computed } from '@ember/object';\n\nperson: computed(function() {\n  let personId = this.get('personId');\n  return Person.create({ id: personId });\n}).meta({ type: Person })\n```\n\nOnce you've done this, you can retrieve the values saved to the computed\nproperty from your class like this:\n\n```javascript\nMyClass.metaForProperty('person');\n```\n\nThis will return the original hash that was passed to `meta()`.",
            "static": 1,
            "itemtype": "method",
            "name": "metaForProperty",
            "params": [
              {
                "name": "key",
                "description": "property name",
                "type": "String"
              }
            ],
            "access": "private",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/mixin.ts",
            "line": 849,
            "description": "Specify a method that observes property changes.\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { observer } from '@ember/object';\n\nexport default EmberObject.extend({\n  valueObserver: observer('value', function() {\n    // Executes whenever the \"value\" property changes\n  })\n});\n```\n\nAlso available as `Function.prototype.observes` if prototype extensions are\nenabled.",
            "itemtype": "method",
            "name": "observer",
            "params": [
              {
                "name": "propertyNames",
                "description": "",
                "type": "String",
                "multiple": true
              },
              {
                "name": "func",
                "description": "",
                "type": "Function"
              }
            ],
            "return": {
              "description": "func"
            },
            "access": "public",
            "tagname": "",
            "static": 1,
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 822,
            "description": "Augments a constructor's prototype with additional\nproperties and functions:\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst MyObject = EmberObject.extend({\n  name: 'an object'\n});\n\no = MyObject.create();\no.get('name'); // 'an object'\n\nMyObject.reopen({\n  say(msg) {\n    console.log(msg);\n  }\n});\n\no2 = MyObject.create();\no2.say('hello'); // logs \"hello\"\n\no.say('goodbye'); // logs \"goodbye\"\n```\n\nTo add functions and properties to the constructor itself,\nsee `reopenClass`",
            "itemtype": "method",
            "name": "reopen",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/system/core_object.js",
            "line": 876,
            "description": "Augments a constructor's own properties and functions:\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst MyObject = EmberObject.extend({\n  name: 'an object'\n});\n\nMyObject.reopenClass({\n  canBuild: false\n});\n\nMyObject.canBuild; // false\no = MyObject.create();\n```\n\nIn other words, this creates static properties and functions for the class.\nThese are only available on the class and not on any instance of that class.\n\n```javascript\nimport EmberObject from '@ember/object';\n\nconst Person = EmberObject.extend({\n  name: '',\n  sayHello() {\n    alert(`Hello. My name is ${this.get('name')}`);\n  }\n});\n\nPerson.reopenClass({\n  species: 'Homo sapiens',\n\n  createPerson(name) {\n    return Person.create({ name });\n  }\n});\n\nlet tom = Person.create({\n  name: 'Tom Dale'\n});\nlet yehuda = Person.createPerson('Yehuda Katz');\n\ntom.sayHello(); // \"Hello. My name is Tom Dale\"\nyehuda.sayHello(); // \"Hello. My name is Yehuda Katz\"\nalert(Person.species); // \"Homo sapiens\"\n```\n\nNote that `species` and `createPerson` are *not* valid on the `tom` and `yehuda`\nvariables. They are only valid on `Person`.\n\nTo add functions and properties to instances of\na constructor by extending the constructor's prototype\nsee `reopen`",
            "itemtype": "method",
            "name": "reopenClass",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/property_set.ts",
            "line": 35,
            "description": "Sets the value of a property on an object, respecting computed properties\nand notifying observers and other listeners of the change.\nIf the specified property is not defined on the object and the object\nimplements the `setUnknownProperty` method, then instead of setting the\nvalue of the property on the object, its `setUnknownProperty` handler\nwill be invoked with the two parameters `keyName` and `value`.\n\n```javascript\nimport { set } from '@ember/object';\nset(obj, \"name\", value);\n```",
            "itemtype": "method",
            "name": "set",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "The object to modify.",
                "type": "Object"
              },
              {
                "name": "keyName",
                "description": "The property key to set",
                "type": "String"
              },
              {
                "name": "value",
                "description": "The value to set",
                "type": "Object"
              }
            ],
            "return": {
              "description": "the passed value.",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/set_properties.ts",
            "line": 6,
            "description": "Set a list of properties on an object. These properties are set inside\na single `beginPropertyChanges` and `endPropertyChanges` batch, so\nobservers will be buffered.\n\n```javascript\nimport EmberObject from '@ember/object';\nlet anObject = EmberObject.create();\n\nanObject.setProperties({\n  firstName: 'Stanley',\n  lastName: 'Stuart',\n  age: 21\n});\n```",
            "itemtype": "method",
            "name": "setProperties",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "properties",
                "description": "",
                "type": "Object"
              }
            ],
            "return": {
              "description": "properties"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/property_set.ts",
            "line": 170,
            "description": "Error-tolerant form of `set`. Will not blow up if any part of the\nchain is `undefined`, `null`, or destroyed.\n\nThis is primarily used when syncing bindings, which may try to update after\nan object has been destroyed.\n\n```javascript\nimport { trySet } from '@ember/object';\n\nlet obj = { name: \"Zoey\" };\ntrySet(obj, \"contacts.twitter\", \"@emberjs\");\n```",
            "itemtype": "method",
            "name": "trySet",
            "static": 1,
            "params": [
              {
                "name": "root",
                "description": "The object to modify.",
                "type": "Object"
              },
              {
                "name": "path",
                "description": "The property path to set",
                "type": "String"
              },
              {
                "name": "value",
                "description": "The value to set",
                "type": "Object"
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object",
            "module": "@ember/object"
          }
        ],
        "@ember/object/events": [
          {
            "file": "packages/@ember/-internals/metal/lib/events.ts",
            "line": 26,
            "description": "Add an event listener",
            "itemtype": "method",
            "name": "addListener",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "eventName",
                "description": "",
                "type": "String"
              },
              {
                "name": "target",
                "description": "A target object or a function",
                "type": "Object|Function"
              },
              {
                "name": "method",
                "description": "A function or the name of a function to be called on `target`",
                "type": "Function|String"
              },
              {
                "name": "once",
                "description": "A flag whether a function should only be called once",
                "type": "Boolean"
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/events",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/events.ts",
            "line": 159,
            "access": "private",
            "tagname": "",
            "itemtype": "method",
            "name": "hasListeners",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "eventName",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "if `obj` has listeners for event `eventName`",
              "type": "Boolean"
            },
            "class": "@ember/object/events",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/events.ts",
            "line": 60,
            "description": "Remove an event listener\n\nArguments should match those passed to `addListener`.",
            "itemtype": "method",
            "name": "removeListener",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "eventName",
                "description": "",
                "type": "String"
              },
              {
                "name": "target",
                "description": "A target object or a function",
                "type": "Object|Function"
              },
              {
                "name": "method",
                "description": "A function or the name of a function to be called on `target`",
                "type": "Function|String"
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/events",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/events.ts",
            "line": 103,
            "description": "Send an event. The execution of suspended listeners\nis skipped, and once listeners are removed. A listener without\na target is executed on the passed object. If an array of actions\nis not passed, the actions stored on the passed object are invoked.",
            "itemtype": "method",
            "name": "sendEvent",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "eventName",
                "description": "",
                "type": "String"
              },
              {
                "name": "params",
                "description": "Optional parameters for each listener.",
                "type": "Array"
              }
            ],
            "return": {
              "description": "if the event was delivered to one or more actions",
              "type": "Boolean"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/events",
            "module": "@ember/object"
          }
        ],
        "@ember/object/observers": [
          {
            "file": "packages/@ember/-internals/metal/lib/observer.ts",
            "line": 27,
            "itemtype": "method",
            "name": "addObserver",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "path",
                "description": "",
                "type": "String"
              },
              {
                "name": "target",
                "description": "",
                "type": "Object|Function"
              },
              {
                "name": "method",
                "description": "",
                "type": "Function|String",
                "optional": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/observers",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/observer.ts",
            "line": 59,
            "itemtype": "method",
            "name": "removeObserver",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": ""
              },
              {
                "name": "path",
                "description": "",
                "type": "String"
              },
              {
                "name": "target",
                "description": "",
                "type": "Object|Function"
              },
              {
                "name": "method",
                "description": "",
                "type": "Function|String",
                "optional": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/observers",
            "module": "@ember/object"
          }
        ],
        "@ember/object/computed": [
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 934,
            "itemtype": "method",
            "description": "Creates a new property that is an alias for another property on an object.\nCalls to `get` or `set` this property behave as though they were called on the\noriginal property.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { alias } from '@ember/object/computed';\n\nclass Person {\n  name = 'Alex Matchneer';\n  @alias('name') nomen;\n}\n\nlet alex = new Person();\n\nalex.nomen; // 'Alex Matchneer'\nalex.name;  // 'Alex Matchneer'\n\nset(alex, 'nomen', '@machty');\nalex.name;  // '@machty'\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { alias } from '@ember/object/computed';\n\nlet Person = EmberObject.extend({\n  name: 'Alex Matchneer',\n\n  nomen: alias('name')\n});\n\nlet alex = Person.create();\n\nalex.nomen; // 'Alex Matchneer'\nalex.name;  // 'Alex Matchneer'\n\nset(alex, 'nomen', '@machty');\nalex.name;  // '@machty'\n```\n",
            "name": "alias",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which creates an alias to the\noriginal value for property.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 792,
            "itemtype": "method",
            "description": "A computed property that performs a logical `and` on the original values for\nthe provided dependent properties.\n\nYou may pass in more than two properties and even use property brace\nexpansion.  The computed property will return the first falsy value or last\ntruthy value just like JavaScript's `&&` operator.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { and } from '@ember/object/computed';\n\nclass Hamster {\n  @and('hasWalkingStick', 'hasBackpack') readyForHike;\n}\n\nlet tomster = new Hamster();\n\ntomster.readyForCamp; // false\n\nset(tomster, 'hasTent', true);\ntomster.readyForCamp; // false\n\nset(tomster, 'hasBackpack', true);\ntomster.readyForCamp; // true\n\nset(tomster, 'hasBackpack', 'Yes');\ntomster.readyForCamp; // 'Yes'\n\nset(tomster, 'hasWalkingStick', null);\ntomster.readyForHike; // null\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { and } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  readyForCamp: and('hasTent', 'hasBackpack'),\n  readyForHike: and('hasWalkingStick', 'hasBackpack')\n});\n\nlet tomster = Hamster.create();\n\ntomster.readyForCamp; // false\n\nset(tomster, 'hasTent', true);\ntomster.readyForCamp; // false\n\nset(tomster, 'hasBackpack', true);\ntomster.readyForCamp; // true\n\nset(tomster, 'hasBackpack', 'Yes');\ntomster.readyForCamp; // 'Yes'\n\nset(tomster, 'hasWalkingStick', null);\ntomster.readyForHike; // null\n```\n",
            "name": "and",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computed property which performs a logical `and` on\nthe values of all the original values for properties.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 321,
            "itemtype": "method",
            "description": "A computed property that converts the provided dependent property into a\nboolean value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { bool } from '@ember/object/computed';\n\n\nclass Hamster {\n  @bool('numBananas') hasBananas\n}\n\nlet hamster = new Hamster();\n\nhamster.hasBananas; // false\n\nset(hamster, 'numBananas', 0);\nhamster.hasBananas; // false\n\nset(hamster, 'numBananas', 1);\nhamster.hasBananas; // true\n\nset(hamster, 'numBananas', null);\nhamster.hasBananas; // false\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { bool } from '@ember/object/computed';\n\n\nlet Hamster = EmberObject.extend({\n  hasBananas: bool('numBananas')\n});\n\nlet hamster = Hamster.create();\n\nhamster.hasBananas; // false\n\nset(hamster, 'numBananas', 0);\nhamster.hasBananas; // false\n\nset(hamster, 'numBananas', 1);\nhamster.hasBananas; // true\n\nset(hamster, 'numBananas', null);\nhamster.hasBananas; // false\n```\n",
            "name": "bool",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which converts to boolean the\noriginal value for property",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 1197,
            "itemtype": "method",
            "description": "A computed property that returns the array of values for the provided\ndependent properties.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { collect } from '@ember/object/computed';\n\nclass Hamster {\n  @collect('hat', 'shirt') clothes;\n}\n\nlet hamster = new Hamster();\n\nhamster.clothes; // [null, null]\n\nset(hamster, 'hat', 'Camp Hat');\nset(hamster, 'shirt', 'Camp Shirt');\nhamster.clothes; // ['Camp Hat', 'Camp Shirt']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { collect } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  clothes: collect('hat', 'shirt')\n});\n\nlet hamster = Hamster.create();\n\nhamster.clothes; // [null, null]\n\nset(hamster, 'hat', 'Camp Hat');\nset(hamster, 'shirt', 'Camp Shirt');\nhamster.clothes; // ['Camp Hat', 'Camp Shirt']\n```\n",
            "name": "collect",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computed property which maps values of all passed\nin properties to an array.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 1152,
            "itemtype": "method",
            "description": "Creates a new property that is an alias for another property on an object.\nCalls to `get` or `set` this property behave as though they were called on the\noriginal property, but also print a deprecation warning.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { deprecatingAlias } from '@ember/object/computed';\n\nclass Hamster {\n  @deprecatingAlias('cavendishCount', {\n    id: 'hamster.deprecate-banana',\n    until: '3.0.0'\n  })\n  bananaCount;\n}\n\nlet hamster = new Hamster();\n\nset(hamster, 'bananaCount', 5); // Prints a deprecation warning.\nhamster.cavendishCount; // 5\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { deprecatingAlias } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  bananaCount: deprecatingAlias('cavendishCount', {\n    id: 'hamster.deprecate-banana',\n    until: '3.0.0'\n  })\n});\n\nlet hamster = Hamster.create();\n\nset(hamster, 'bananaCount', 5); // Prints a deprecation warning.\nhamster.cavendishCount; // 5\n```\n",
            "name": "deprecatingAlias",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "options",
                "description": "Options for `deprecate`.",
                "type": "Object"
              }
            ],
            "return": {
              "description": "computed property which creates an alias with a\ndeprecation to the original value for property.",
              "type": "ComputedProperty"
            },
            "since": "1.7.0",
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 63,
            "since": "1.6.0",
            "description": "A computed property macro that returns true if the value of the dependent\nproperty is null, an empty string, empty array, or empty function.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { empty } from '@ember/object/computed';\n\nclass ToDoList {\n  constructor(todos) {\n    set(this, 'todos', todos);\n  }\n\n  @empty('todos') isDone;\n}\n\nlet todoList = new ToDoList(\n  ['Unit Test', 'Documentation', 'Release']\n);\n\ntodoList.isDone; // false\nset(todoList, 'todos', []);\ntodoList.isDone; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { empty } from '@ember/object/computed';\n\nlet ToDoList = EmberObject.extend({\n  isDone: empty('todos')\n});\n\nlet todoList = ToDoList.create({\n  todos: ['Unit Test', 'Documentation', 'Release']\n});\n\ntodoList.isDone; // false\nset(todoList, 'todos', []);\ntodoList.isDone; // true\n```\n",
            "itemtype": "method",
            "name": "empty",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which returns true if the value\nof the dependent property is null, an empty string, empty array, or empty\nfunction and false if the underlying value is not empty.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 462,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\nequal to the given value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { equal } from '@ember/object/computed';\n\nclass Hamster {\n  @equal('percentCarrotsEaten', 100) satisfied;\n}\n\nlet hamster = new Hamster();\n\nhamster.satisfied; // false\n\nset(hamster, 'percentCarrotsEaten', 100);\nhamster.satisfied; // true\n\nset(hamster, 'percentCarrotsEaten', 50);\nhamster.satisfied; // false\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { equal } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  satisfied: equal('percentCarrotsEaten', 100)\n});\n\nlet hamster = Hamster.create();\n\nhamster.satisfied; // false\n\nset(hamster, 'percentCarrotsEaten', 100);\nhamster.satisfied; // true\n\nset(hamster, 'percentCarrotsEaten', 50);\nhamster.satisfied; // false\n```\n",
            "name": "equal",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "String|Number|Object"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is equal to the given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/metal/lib/expand_properties.ts",
            "line": 9,
            "description": "Expands `pattern`, invoking `callback` for each expansion.\n\nThe only pattern supported is brace-expansion, anything else will be passed\nonce to `callback` directly.\n\nExample\n\n```js\nimport { expandProperties } from '@ember/object/computed';\n\nfunction echo(arg){ console.log(arg); }\n\nexpandProperties('foo.bar', echo);              //=> 'foo.bar'\nexpandProperties('{foo,bar}', echo);            //=> 'foo', 'bar'\nexpandProperties('foo.{bar,baz}', echo);        //=> 'foo.bar', 'foo.baz'\nexpandProperties('{foo,bar}.baz', echo);        //=> 'foo.baz', 'bar.baz'\nexpandProperties('foo.{bar,baz}.[]', echo)      //=> 'foo.bar.[]', 'foo.baz.[]'\nexpandProperties('{foo,bar}.{spam,eggs}', echo) //=> 'foo.spam', 'foo.eggs', 'bar.spam', 'bar.eggs'\nexpandProperties('{foo}.bar.{baz}')             //=> 'foo.bar.baz'\n```",
            "itemtype": "method",
            "name": "expandProperties",
            "static": 1,
            "access": "public",
            "tagname": "",
            "params": [
              {
                "name": "pattern",
                "description": "The property pattern to expand.",
                "type": "String"
              },
              {
                "name": "callback",
                "description": "The callback to invoke.  It is invoked once per\nexpansion, and is passed the expansion.",
                "type": "Function"
              }
            ],
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 540,
            "itemtype": "method",
            "description": "Filters the array by the callback.\n\nThe callback method you provide should have the following signature:\n- `item` is the current item in the iteration.\n- `index` is the integer index of the current item in the iteration.\n- `array` is the dependant array itself.\n\n```javascript\nfunction filterCallback(item, index, array);\n```\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { filter } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(chores) {\n    set(this, 'chores', chores);\n  }\n\n  @filter('chores', ['doneKey'], function(chore, index, array) {\n    return !chore[this.doneKey];\n  })\n  remainingChores;\n}\n\nlet hamster = new Hamster([\n  { name: 'cook', finished: true },\n  { name: 'clean', finished: true },\n  { name: 'write more unit tests', finished: false }\n]);\n\nhamster.remainingChores; // [{name: 'write more unit tests', finished: false}]\n```\n",
            "name": "filter",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "additionalDependentKeys",
                "description": "optional array of additional dependent keys",
                "type": "Array",
                "optional": true
              },
              {
                "name": "callback",
                "description": "",
                "type": "Function"
              }
            ],
            "return": {
              "description": "the filtered array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 694,
            "itemtype": "method",
            "description": "Filters the array by the property and value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { filterBy } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(chores) {\n    set(this, 'chores', chores);\n  }\n\n  @filterBy('chores', 'done', false) remainingChores;\n}\n\nlet hamster = new Hamster([\n  { name: 'cook', done: true },\n  { name: 'clean', done: true },\n  { name: 'write more unit tests', done: false }\n]);\n\nhamster.remainingChores; // [{ name: 'write more unit tests', done: false }]\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { filterBy } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  remainingChores: filterBy('chores', 'done', false)\n});\n\nlet hamster = Hamster.create({\n  chores: [\n    { name: 'cook', done: true },\n    { name: 'clean', done: true },\n    { name: 'write more unit tests', done: false }\n  ]\n});\n\nhamster.remainingChores; // [{ name: 'write more unit tests', done: false }]\n```\n",
            "name": "filterBy",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "propertyKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "*"
              }
            ],
            "return": {
              "description": "the filtered array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 528,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\ngreater than the provided value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { gt } from '@ember/object/computed';\n\nclass Hamster {\n  @gt('numBananas', 10) hasTooManyBananas;\n}\n\nlet hamster = new Hamster();\n\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 11);\nhamster.hasTooManyBananas; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { gt } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  hasTooManyBananas: gt('numBananas', 10)\n});\n\nlet hamster = Hamster.create();\n\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 11);\nhamster.hasTooManyBananas; // true\n```\n",
            "name": "gt",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "Number"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is greater than given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 594,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\ngreater than or equal to the provided value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { gte } from '@ember/object/computed';\n\nclass Hamster {\n  @gte('numBananas', 10) hasTooManyBananas;\n}\n\nlet hamster = new Hamster();\n\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 10);\nhamster.hasTooManyBananas; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { gte } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  hasTooManyBananas: gte('numBananas', 10)\n});\n\nlet hamster = Hamster.create();\n\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.hasTooManyBananas; // false\n\nset(hamster, 'numBananas', 10);\nhamster.hasTooManyBananas; // true\n```\n",
            "name": "gte",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "Number"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is greater or equal then given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 1010,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the elements\ntwo or more dependent arrays have in common.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { intersect } from '@ember/object/computed';\n\nclass FriendGroups {\n  constructor(adaFriends, charlesFriends) {\n    set(this, 'adaFriends', adaFriends);\n    set(this, 'charlesFriends', charlesFriends);\n  }\n\n  @intersect('adaFriends', 'charlesFriends') friendsInCommon;\n}\n\nlet groups = new FriendGroups(\n  ['Charles Babbage', 'John Hobhouse', 'William King', 'Mary Somerville'],\n  ['William King', 'Mary Somerville', 'Ada Lovelace', 'George Peacock']\n);\n\ngroups.friendsInCommon; // ['William King', 'Mary Somerville']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { intersect } from '@ember/object/computed';\n\nlet FriendGroups = EmberObject.extend({\n  friendsInCommon: intersect('adaFriends', 'charlesFriends')\n});\n\nlet groups = FriendGroups.create({\n  adaFriends: ['Charles Babbage', 'John Hobhouse', 'William King', 'Mary Somerville'],\n  charlesFriends: ['William King', 'Mary Somerville', 'Ada Lovelace', 'George Peacock']\n});\n\ngroups.friendsInCommon; // ['William King', 'Mary Somerville']\n```\n",
            "name": "intersect",
            "static": 1,
            "params": [
              {
                "name": "propertyKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computes a new array with all the duplicated\nelements from the dependent arrays",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 660,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\nless than the provided value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { lt } from '@ember/object/computed';\n\nclass Hamster {\n  @lt('numBananas', 3) needsMoreBananas;\n}\n\nlet hamster = new Hamster();\n\nhamster.needsMoreBananas; // true\n\nset(hamster, 'numBananas', 3);\nhamster.needsMoreBananas; // false\n\nset(hamster, 'numBananas', 2);\nhamster.needsMoreBananas; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { lt } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  needsMoreBananas: lt('numBananas', 3)\n});\n\nlet hamster = Hamster.create();\n\nhamster.needsMoreBananas; // true\n\nset(hamster, 'numBananas', 3);\nhamster.needsMoreBananas; // false\n\nset(hamster, 'numBananas', 2);\nhamster.needsMoreBananas; // true\n```\n",
            "name": "lt",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "Number"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is less then given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 726,
            "itemtype": "method",
            "description": "A computed property that returns true if the provided dependent property is\nless than or equal to the provided value.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { lte } from '@ember/object/computed';\n\nclass Hamster {\n  @lte('numBananas', 3) needsMoreBananas;\n}\n\nlet hamster = new Hamster();\n\nhamster.needsMoreBananas; // true\n\nset(hamster, 'numBananas', 5);\nhamster.needsMoreBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.needsMoreBananas; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { lte } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  needsMoreBananas: lte('numBananas', 3)\n});\n\nlet hamster = Hamster.create();\n\nhamster.needsMoreBananas; // true\n\nset(hamster, 'numBananas', 5);\nhamster.needsMoreBananas; // false\n\nset(hamster, 'numBananas', 3);\nhamster.needsMoreBananas; // true\n```\n",
            "name": "lte",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "value",
                "description": "",
                "type": "Number"
              }
            ],
            "return": {
              "description": "computed property which returns true if the\noriginal value for property is less or equal than given value.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 318,
            "itemtype": "method",
            "description": "Returns an array mapped via the callback\n\nThe callback method you provide should have the following signature:\n- `item` is the current item in the iteration.\n- `index` is the integer index of the current item in the iteration.\n\n```javascript\nfunction mapCallback(item, index);\n```\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { map } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(chores) {\n    set(this, 'chores', chores);\n  }\n\n  @map('chores', ['shouldUpperCase'], function(chore, index) {\n    if (this.shouldUpperCase) {\n      return `${chore.toUpperCase()}!`;\n    } else {\n      return `${chore}!`;\n    }\n  })\n  excitingChores;\n}\n\nlet hamster = new Hamster(['clean', 'write more unit tests']);\n\nhamster.excitingChores; // ['clean!', 'write more unit tests!']\n\nset(hamster, 'shouldUpperCase', true);\nhamster.excitingChores; // ['CLEAN!', 'WRITE MORE UNIT TESTS!']\n```\n",
            "name": "map",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "additionalDependentKeys",
                "description": "optional array of additional\ndependent keys",
                "type": "Array",
                "optional": true
              },
              {
                "name": "callback",
                "description": "",
                "type": "Function"
              }
            ],
            "return": {
              "description": "an array mapped via the callback",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 438,
            "itemtype": "method",
            "description": "Returns an array mapped to the specified key.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { mapBy } from '@ember/object/computed';\n\nclass Person {\n  children = [];\n  @mapBy('children', 'age') childAges;\n}\n\nlet lordByron = new Person();\n\nlordByron.childAges; // []\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.childAges; // [7]\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.childAges; // [7, 5, 8]\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { mapBy } from '@ember/object/computed';\n\nlet Person = EmberObject.extend({\n  childAges: mapBy('children', 'age')\n});\n\nlet lordByron = Person.create({ children: [] });\n\nlordByron.childAges; // []\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.childAges; // [7]\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.childAges; // [7, 5, 8]\n```\n",
            "name": "mapBy",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "propertyKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "an array mapped to the specified key",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 394,
            "itemtype": "method",
            "description": "A computed property which matches the original value for the dependent\nproperty against a given RegExp, returning `true` if the value matches the\nRegExp and `false` if it does not.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { match } from '@ember/object/computed';\n\nclass User {\n  @match('email', /^.+@.+\\..+$/) hasValidEmail;\n}\n\nlet user = new User();\n\nuser.hasValidEmail; // false\n\nset(user, 'email', '');\nuser.hasValidEmail; // false\n\nset(user, 'email', 'ember_hamster@example.com');\nuser.hasValidEmail; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { match } from '@ember/object/computed';\n\nlet User = EmberObject.extend({\n  hasValidEmail: match('email', /^.+@.+\\..+$/)\n});\n\nlet user = User.create();\n\nuser.hasValidEmail; // false\n\nset(user, 'email', '');\nuser.hasValidEmail; // false\n\nset(user, 'email', 'ember_hamster@example.com');\nuser.hasValidEmail; // true\n```\n",
            "name": "match",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "regexp",
                "description": "",
                "type": "RegExp"
              }
            ],
            "return": {
              "description": "computed property which match the original value\nfor property against a given RegExp",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 119,
            "itemtype": "method",
            "description": "A computed property that calculates the maximum value in the dependent array.\nThis will return `-Infinity` when the dependent array is empty.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { mapBy, max } from '@ember/object/computed';\n\nclass Person {\n  children = [];\n  @mapBy('children', 'age') childAges;\n  @max('childAges') maxChildAge;\n}\n\nlet lordByron = new Person();\n\nlordByron.maxChildAge; // -Infinity\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.maxChildAge; // 7\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.maxChildAge; // 8\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { mapBy, max } from '@ember/object/computed';\n\nlet Person = EmberObject.extend({\n  childAges: mapBy('children', 'age'),\n  maxChildAge: max('childAges')\n});\n\nlet lordByron = Person.create({ children: [] });\n\nlordByron.maxChildAge; // -Infinity\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.maxChildAge; // 7\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.maxChildAge; // 8\n```\n\nIf the types of the arguments are not numbers, they will be converted to\nnumbers and the type of the return value will always be `Number`. For example,\nthe max of a list of Date objects will be the highest timestamp as a `Number`.\nThis behavior is consistent with `Math.max`.\n",
            "name": "max",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes the largest value in the dependentKey's\narray",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 219,
            "itemtype": "method",
            "description": "A computed property that calculates the minimum value in the dependent array.\nThis will return `Infinity` when the dependent array is empty.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { mapBy, min } from '@ember/object/computed';\n\nclass Person {\n  children = [];\n  @mapBy('children', 'age') childAges;\n  @min('childAges') minChildAge;\n}\n\nlet lordByron = Person.create({ children: [] });\n\nlordByron.minChildAge; // Infinity\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.minChildAge; // 7\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.minChildAge; // 5\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { mapBy, min } from '@ember/object/computed';\n\nlet Person = EmberObject.extend({\n  childAges: mapBy('children', 'age'),\n  minChildAge: min('childAges')\n});\n\nlet lordByron = Person.create({ children: [] });\n\nlordByron.minChildAge; // Infinity\n\nset(lordByron, 'children', [\n  {\n    name: 'Augusta Ada Byron',\n    age: 7\n  }\n]);\nlordByron.minChildAge; // 7\n\nset(lordByron, 'children', [\n  ...lordByron.children,\n  {\n    name: 'Allegra Byron',\n    age: 5\n  }, {\n    name: 'Elizabeth Medora Leigh',\n    age: 8\n  }\n]);\nlordByron.minChildAge; // 5\n```\n\nIf the types of the arguments are not numbers, they will be converted to\nnumbers and the type of the return value will always be `Number`. For example,\nthe min of a list of Date objects will be the lowest timestamp as a `Number`.\nThis behavior is consistent with `Math.min`.\n",
            "name": "min",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes the smallest value in the dependentKey's array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 196,
            "itemtype": "method",
            "description": "A computed property that returns true if the value of the dependent property\nis null or undefined. This avoids errors from JSLint complaining about use of\n==, which can be technically confusing.\n\n```javascript\nimport { set } from '@ember/object';\nimport { none } from '@ember/object/computed';\n\nclass Hamster {\n  @none('food') isHungry;\n}\n\nlet hamster = new Hamster();\n\nhamster.isHungry; // true\n\nset(hamster, 'food', 'Banana');\nhamster.isHungry; // false\n\nset(hamster, 'food', null);\nhamster.isHungry; // true\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { none } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  isHungry: none('food')\n});\n\nlet hamster = Hamster.create();\n\nhamster.isHungry; // true\n\nset(hamster, 'food', 'Banana');\nhamster.isHungry; // false\n\nset(hamster, 'food', null);\nhamster.isHungry; // true\n```\n",
            "name": "none",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which returns true if original\nvalue for property is null or undefined.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 260,
            "itemtype": "method",
            "description": "A computed property that returns the inverse boolean value of the original\nvalue for the dependent property.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { not } from '@ember/object/computed';\n\nclass User {\n  loggedIn = false;\n  @not('loggedIn') isAnonymous;\n}\n\nlet user = new User();\n\nuser.isAnonymous; // true\nset(user, 'loggedIn', true);\nuser.isAnonymous; // false\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { not } from '@ember/object/computed';\n\nlet User = EmberObject.extend({\n  loggedIn: false,\n\n  isAnonymous: not('loggedIn')\n});\n\nlet user = User.create();\n\nuser.isAnonymous; // true\nset(user, 'loggedIn', true);\nuser.isAnonymous; // false\n```\n",
            "name": "not",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which returns inverse of the\noriginal value for property",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 131,
            "itemtype": "method",
            "description": "A computed property that returns true if the value of the dependent property\nis NOT null, an empty string, empty array, or empty function.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { notEmpty } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(backpack) {\n    set(this, 'backpack', backpack);\n  }\n\n  @notEmpty('backpack') hasStuff\n}\n\nlet hamster = new Hamster(\n  ['Food', 'Sleeping Bag', 'Tent']\n);\n\nhamster.hasStuff; // true\nset(hamster, 'backpack', []);\nhamster.hasStuff; // false\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { notEmpty } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  hasStuff: notEmpty('backpack')\n});\n\nlet hamster = Hamster.create({\n  backpack: ['Food', 'Sleeping Bag', 'Tent']\n});\n\nhamster.hasStuff; // true\nset(hamster, 'backpack', []);\nhamster.hasStuff; // false\n```\n",
            "name": "notEmpty",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which returns true if original\nvalue for property is not empty.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 990,
            "itemtype": "method",
            "description": "Where `computed.alias` aliases `get` and `set`, and allows for bidirectional\ndata flow, `computed.oneWay` only provides an aliased `get`. The `set` will\nnot mutate the upstream property, rather causes the current property to become\nthe value set. This causes the downstream property to permanently diverge from\nthe upstream property.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { oneWay }from '@ember/object/computed';\n\nclass User {\n  constructor(firstName, lastName) {\n    set(this, 'firstName', firstName);\n    set(this, 'lastName', lastName);\n  }\n\n  @oneWay('firstName') nickName;\n}\n\nlet teddy = new User('Teddy', 'Zeenny');\n\nteddy.nickName; // 'Teddy'\n\nset(teddy, 'nickName', 'TeddyBear');\nteddy.firstName; // 'Teddy'\nteddy.nickName; // 'TeddyBear'\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { oneWay } from '@ember/object/computed';\n\nlet User = EmberObject.extend({\n  firstName: null,\n  lastName: null,\n\n  nickName: oneWay('firstName')\n});\n\nlet teddy = User.create({\n  firstName: 'Teddy',\n  lastName: 'Zeenny'\n});\n\nteddy.nickName; // 'Teddy'\n\nset(teddy, 'nickName', 'TeddyBear'); // 'TeddyBear'\nteddy.firstName; // 'Teddy'\nteddy.nickName; // 'TeddyBear'\n```\n",
            "name": "oneWay",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which creates a one way computed\nproperty to the original value for property.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 866,
            "itemtype": "method",
            "description": "A computed property which performs a logical `or` on the original values for\nthe provided dependent properties.\n\nYou may pass in more than two properties and even use property brace\nexpansion.  The computed property will return the first truthy value or last\nfalsy value just like JavaScript's `||` operator.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { or } from '@ember/object/computed';\n\nclass Hamster {\n  @or('hasSunscreen', 'hasUmbrella') readyForBeach;\n}\n\nlet tomster = new Hamster();\n\ntomster.readyForRain; // undefined\n\nset(tomster, 'hasUmbrella', true);\ntomster.readyForRain; // true\n\nset(tomster, 'hasJacket', 'Yes');\ntomster.readyForRain; // 'Yes'\n\nset(tomster, 'hasSunscreen', 'Check');\ntomster.readyForBeach; // 'Check'\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { or } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  readyForRain: or('hasJacket', 'hasUmbrella'),\n  readyForBeach: or('hasSunscreen', 'hasUmbrella')\n});\n\nlet tomster = Hamster.create();\n\ntomster.readyForRain; // undefined\n\nset(tomster, 'hasUmbrella', true);\ntomster.readyForRain; // true\n\nset(tomster, 'hasJacket', 'Yes');\ntomster.readyForRain; // 'Yes'\n\nset(tomster, 'hasSunscreen', 'Check');\ntomster.readyForBeach; // 'Check'\n```\n",
            "name": "or",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computed property which performs a logical `or` on\nthe values of all the original values for properties.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 1076,
            "itemtype": "method",
            "description": "Where `computed.oneWay` provides oneWay bindings, `computed.readOnly` provides\na readOnly one way binding. Very often when using `computed.oneWay` one does\nnot also want changes to propagate back up, as they will replace the value.\n\nThis prevents the reverse flow, and also throws an exception when it occurs.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { readOnly } from '@ember/object/computed';\n\nclass User {\n  constructor(firstName, lastName) {\n    set(this, 'firstName', firstName);\n    set(this, 'lastName', lastName);\n  }\n\n  @readOnly('firstName') nickName;\n});\n\nlet teddy = new User('Teddy', 'Zeenny');\n\nteddy.nickName; // 'Teddy'\n\nset(teddy, 'nickName', 'TeddyBear'); // throws Exception\n// throw new EmberError('Cannot Set: nickName on: <User:ember27288>' );`\n\nteddy.firstName; // 'Teddy'\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject, { set } from '@ember/object';\nimport { readOnly } from '@ember/object/computed';\n\nlet User = EmberObject.extend({\n  firstName: null,\n  lastName: null,\n\n  nickName: readOnly('firstName')\n});\n\nlet teddy = User.create({\n  firstName: 'Teddy',\n  lastName:  'Zeenny'\n});\n\nteddy.nickName; // 'Teddy'\n\nset(teddy, 'nickName', 'TeddyBear'); // throws Exception\n// throw new EmberError('Cannot Set: nickName on: <User:ember27288>' );`\n\nteddy.firstName; // 'Teddy'\n```\n",
            "name": "readOnly",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which creates a one way computed\nproperty to the original value for property.",
              "type": "ComputedProperty"
            },
            "since": "1.5.0",
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/computed_macros.js",
            "line": 1063,
            "description": "This is a more semantically meaningful alias of `computed.oneWay`, whose name\nis somewhat ambiguous as to which direction the data flows.",
            "itemtype": "method",
            "name": "reads",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computed property which creates a one way computed\n  property to the original value for property.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 1102,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the properties from the\nfirst dependent array that are not in the second dependent array.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { setDiff } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(likes, fruits) {\n    set(this, 'likes', likes);\n    set(this, 'fruits', fruits);\n  }\n\n  @setDiff('likes', 'fruits') wants;\n}\n\nlet hamster = new Hamster(\n  [\n    'banana',\n    'grape',\n    'kale'\n  ],\n  [\n    'grape',\n    'kale',\n  ]\n);\n\nhamster.wants; // ['banana']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { setDiff } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  wants: setDiff('likes', 'fruits')\n});\n\nlet hamster = Hamster.create({\n  likes: [\n    'banana',\n    'grape',\n    'kale'\n  ],\n  fruits: [\n    'grape',\n    'kale',\n  ]\n});\n\nhamster.wants; // ['banana']\n```\n",
            "name": "setDiff",
            "static": 1,
            "params": [
              {
                "name": "setAProperty",
                "description": "",
                "type": "String"
              },
              {
                "name": "setBProperty",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes a new array with all the items from the\nfirst dependent array that are not in the second dependent array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 1267,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the properties from the\nfirst dependent array sorted based on a property or sort function. The sort\nmacro can be used in two different ways:\n\n1. By providing a sort callback function\n2. By providing an array of keys to sort the array\n\nIn the first form, the callback method you provide should have the following\nsignature:\n\n```javascript\nfunction sortCallback(itemA, itemB);\n```\n\n- `itemA` the first item to compare.\n- `itemB` the second item to compare.\n\nThis function should return negative number (e.g. `-1`) when `itemA` should\ncome before `itemB`. It should return positive number (e.g. `1`) when `itemA`\nshould come after `itemB`. If the `itemA` and `itemB` are equal this function\nshould return `0`.\n\nTherefore, if this function is comparing some numeric values, simple `itemA -\nitemB` or `itemA.get( 'foo' ) - itemB.get( 'foo' )` can be used instead of\nseries of `if`.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { sort } from '@ember/object/computed';\n\nclass ToDoList {\n  constructor(todos) {\n    set(this, 'todos', todos);\n  }\n\n  // using a custom sort function\n  @sort('todos', 'todosSortingDesc') sortedTodosDesc;\n}\n\nlet todoList = new ToDoList([\n  { name: 'Unit Test', priority: 2 },\n  { name: 'Documentation', priority: 3 },\n  { name: 'Release', priority: 1 }\n]);\n\ntodoList.sortedTodos; // [{ name:'Documentation', priority:3 }, { name:'Release', priority:1 }, { name:'Unit Test', priority:2 }]\ntodoList.sortedTodosDesc; // [{ name:'Unit Test', priority:2 }, { name:'Release', priority:1 }, { name:'Documentation', priority:3 }]\n```\n",
            "name": "sort",
            "static": 1,
            "params": [
              {
                "name": "itemsKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "additionalDependentKeys",
                "description": "optional array of additional\ndependent keys",
                "type": "Array",
                "optional": true
              },
              {
                "name": "sortDefinition",
                "description": "a dependent key to an array of sort\nproperties (add `:desc` to the arrays sort properties to sort descending) or a\nfunction to use when sorting",
                "type": "String or Function"
              }
            ],
            "return": {
              "description": "computes a new sorted array based on the sort\nproperty array or callback function",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 65,
            "itemtype": "method",
            "description": "A computed property that returns the sum of the values in the dependent array.\n\nExample:\n\n```javascript\nimport { sum } from '@ember/object/computed';\n\nclass Invoice {\n  lineItems = [1.00, 2.50, 9.99];\n  @sum('lineItems') total;\n}\n\nlet invoice = new Invoice();\n\ninvoice.total; // 13.49\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { sum } from '@ember/object/computed';\n\nlet Invoice = EmberObject.extend({\n  lineItems: [1.00, 2.50, 9.99],\n\n  total: sum('lineItems')\n})\n\nlet invoice = Invoice.create();\n\ninvoice.total; // 13.49\n```\n",
            "name": "sum",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes the sum of all values in the\ndependentKey's array",
              "type": "ComputedProperty"
            },
            "since": "1.4.0",
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 935,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the unique elements\nfrom one or more dependent arrays.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { union } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(fruits, vegetables) {\n    set(this, 'fruits', fruits);\n    set(this, 'vegetables', vegetables);\n  }\n\n  @union('fruits', 'vegetables') ediblePlants;\n});\n\nlet hamster = new, Hamster(\n  [\n    'banana',\n    'grape',\n    'kale',\n    'banana',\n    'tomato'\n  ],\n  [\n    'tomato',\n    'carrot',\n    'lettuce'\n  ]\n);\n\nhamster.uniqueFruits; // ['banana', 'grape', 'kale', 'tomato', 'carrot', 'lettuce']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { union } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  uniqueFruits: union('fruits', 'vegetables')\n});\n\nlet hamster = Hamster.create({\n  fruits: [\n    'banana',\n    'grape',\n    'kale',\n    'banana',\n    'tomato'\n  ],\n  vegetables: [\n    'tomato',\n    'carrot',\n    'lettuce'\n  ]\n});\n\nhamster.uniqueFruits; // ['banana', 'grape', 'kale', 'tomato', 'carrot', 'lettuce']\n```\n",
            "name": "union",
            "static": 1,
            "params": [
              {
                "name": "propertyKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computes a new array with all the unique elements\nfrom one or more dependent arrays.",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 771,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the unique elements\nfrom one or more dependent arrays.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { uniq } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(fruits) {\n    set(this, 'fruits', fruits);\n  }\n\n  @uniq('fruits') uniqueFruits;\n}\n\nlet hamster = new Hamster([\n  'banana',\n  'grape',\n  'kale',\n  'banana'\n]);\n\nhamster.uniqueFruits; // ['banana', 'grape', 'kale']\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { uniq } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  uniqueFruits: uniq('fruits')\n});\n\nlet hamster = Hamster.create({\n  fruits: [\n    'banana',\n    'grape',\n    'kale',\n    'banana'\n  ]\n});\n\nhamster.uniqueFruits; // ['banana', 'grape', 'kale']\n```\n",
            "name": "uniq",
            "static": 1,
            "params": [
              {
                "name": "propertyKey",
                "description": "",
                "type": "String",
                "multiple": true
              }
            ],
            "return": {
              "description": "computes a new array with all the\nunique elements from the dependent array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/object/lib/computed/reduce_computed_macros.js",
            "line": 859,
            "itemtype": "method",
            "description": "A computed property which returns a new array with all the unique elements\nfrom an array, with uniqueness determined by specific key.\n\nExample:\n\n```javascript\nimport { set } from '@ember/object';\nimport { uniqBy } from '@ember/object/computed';\n\nclass Hamster {\n  constructor(fruits) {\n    set(this, 'fruits', fruits);\n  }\n\n  @uniqBy('fruits', 'id') uniqueFruits;\n}\n\nlet hamster = new Hamster([\n  { id: 1, 'banana' },\n  { id: 2, 'grape' },\n  { id: 3, 'peach' },\n  { id: 1, 'banana' }\n]);\n\nhamster.uniqueFruits; // [ { id: 1, 'banana' }, { id: 2, 'grape' }, { id: 3, 'peach' }]\n```\n\nClassic Class Example:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { uniqBy } from '@ember/object/computed';\n\nlet Hamster = EmberObject.extend({\n  uniqueFruits: uniqBy('fruits', 'id')\n});\n\nlet hamster = Hamster.create({\n  fruits: [\n    { id: 1, 'banana' },\n    { id: 2, 'grape' },\n    { id: 3, 'peach' },\n    { id: 1, 'banana' }\n  ]\n});\n\nhamster.uniqueFruits; // [ { id: 1, 'banana' }, { id: 2, 'grape' }, { id: 3, 'peach' }]\n```\n",
            "name": "uniqBy",
            "static": 1,
            "params": [
              {
                "name": "dependentKey",
                "description": "",
                "type": "String"
              },
              {
                "name": "propertyKey",
                "description": "",
                "type": "String"
              }
            ],
            "return": {
              "description": "computes a new array with all the\nunique elements from the dependent array",
              "type": "ComputedProperty"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/computed",
            "module": "@ember/object"
          }
        ],
        "@ember/object/internals": [
          {
            "file": "packages/@ember/-internals/metal/lib/computed_cache.ts",
            "line": 7,
            "description": "Returns the cached value for a property, if one exists.\nThis can be useful for peeking at the value of a computed\nproperty that is generated lazily, without accidentally causing\nit to be created.",
            "itemtype": "method",
            "name": "cacheFor",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "the object whose property you want to check",
                "type": "Object"
              },
              {
                "name": "key",
                "description": "the name of the property whose cached value you want\n  to return",
                "type": "String"
              }
            ],
            "return": {
              "description": "the cached value",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/internals",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/runtime/lib/copy.js",
            "line": 79,
            "description": "Creates a shallow copy of the passed object. A deep copy of the object is\nreturned if the optional `deep` argument is `true`.\n\nIf the passed object implements the `Copyable` interface, then this\nfunction will delegate to the object's `copy()` method and return the\nresult. See `Copyable` for further details.\n\nFor primitive values (which are immutable in JavaScript), the passed object\nis simply returned.",
            "itemtype": "method",
            "name": "copy",
            "deprecated": true,
            "deprecationMessage": "Use 'ember-copy' addon instead",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "The object to clone",
                "type": "Object"
              },
              {
                "name": "deep",
                "description": "If true, a deep copy of the object is made.",
                "type": "Boolean",
                "optional": true,
                "optdefault": "false"
              }
            ],
            "return": {
              "description": "The copied object",
              "type": "Object"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/internals",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/utils/lib/guid.ts",
            "line": 58,
            "description": "Generates a new guid, optionally saving the guid to the object that you\npass in. You will rarely need to use this method. Instead you should\ncall `guidFor(obj)`, which return an existing guid if available.",
            "access": "private",
            "tagname": "",
            "itemtype": "method",
            "name": "generateGuid",
            "static": 1,
            "params": [
              {
                "name": "obj",
                "description": "Object the guid will be used for. If passed in, the guid will\n  be saved on the object and reused whenever you pass the same object\n  again.\n\n  If no object is passed, just generate a new guid.",
                "type": "Object",
                "optional": true
              },
              {
                "name": "prefix",
                "description": "Prefix to place in front of the guid. Useful when you want to\n  separate the guid into separate namespaces.",
                "type": "String",
                "optional": true
              }
            ],
            "return": {
              "description": "the guid",
              "type": "String"
            },
            "class": "@ember/object/internals",
            "module": "@ember/object"
          },
          {
            "file": "packages/@ember/-internals/utils/lib/guid.ts",
            "line": 86,
            "description": "Returns a unique id for the object. If the object does not yet have a guid,\none will be assigned to it. You can call this on any object,\n`EmberObject`-based or not.\n\nYou can also use this method on DOM Element objects.",
            "access": "public",
            "tagname": "",
            "static": 1,
            "itemtype": "method",
            "name": "guidFor",
            "params": [
              {
                "name": "obj",
                "description": "any object, string, number, Element, or primitive",
                "type": "Object"
              }
            ],
            "return": {
              "description": "the unique guid for this instance.",
              "type": "String"
            },
            "class": "@ember/object/internals",
            "module": "@ember/object"
          }
        ],
        "@ember/object/mixin": [
          {
            "file": "packages/@ember/-internals/metal/lib/mixin.ts",
            "line": 610,
            "itemtype": "method",
            "name": "create",
            "static": 1,
            "params": [
              {
                "name": "arguments",
                "description": "",
                "multiple": true
              }
            ],
            "access": "public",
            "tagname": "",
            "class": "@ember/object/mixin",
            "module": "@ember/object"
          }
        ],
        "@ember/debug": [
          {
            "file": "packages/@ember/-internals/metal/lib/computed.ts",
            "line": 882,
            "description": "Allows checking if a given property on an object is a computed property. For the most part,\nthis doesn't matter (you would normally just access the property directly and use its value),\nbut for some tooling specific scenarios (e.g. the ember-inspector) it is important to\ndifferentiate if a property is a computed property or a \"normal\" property.\n\nThis will work on either a class's prototype or an instance itself.",
            "static": 1,
            "itemtype": "method",
            "name": "isComputed",
            "access": "private",
            "tagname": "",
            "class": "@ember/debug",
            "module": "@ember/object"
          }
        ],
        "@ember/object/evented": [
          {
            "file": "packages/@ember/-internals/metal/lib/events.ts",
            "line": 177,
            "description": "Define a property as a function that should be executed when\na specified event or events are triggered.\n\n``` javascript\nimport EmberObject from '@ember/object';\nimport { on } from '@ember/object/evented';\nimport { sendEvent } from '@ember/object/events';\n\nlet Job = EmberObject.extend({\n  logCompleted: on('completed', function() {\n    console.log('Job completed!');\n  })\n});\n\nlet job = Job.create();\n\nsendEvent(job, 'completed'); // Logs 'Job completed!'\n ```",
            "itemtype": "method",
            "name": "on",
            "static": 1,
            "params": [
              {
                "name": "eventNames",
                "description": "",
                "type": "String",
                "multiple": true
              },
              {
                "name": "func",
                "description": "",
                "type": "Function"
              }
            ],
            "return": {
              "description": "the listener function, passed as last argument to on(...)",
              "type": "Function"
            },
            "access": "public",
            "tagname": "",
            "class": "@ember/object/evented",
            "module": "@ember/object"
          }
        ]
      },
      "version": "3.12.1"
    },
    "relationships": {
      "classes": {
        "data": []
      },
      "project-version": {
        "data": {
          "id": "ember-3.12.1",
          "type": "project-version"
        }
      }
    }
  }
}