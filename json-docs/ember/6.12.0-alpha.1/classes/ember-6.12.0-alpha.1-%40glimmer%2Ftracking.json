{
  "data": {
    "id": "ember-6.12.0-alpha.1-@glimmer/tracking",
    "type": "class",
    "attributes": {
      "name": "@glimmer/tracking",
      "shortname": "@glimmer/tracking",
      "classitems": [],
      "plugins": [],
      "extensions": [],
      "plugin_for": [],
      "extension_for": [],
      "module": "@glimmer/tracking",
      "namespace": "",
      "methods": [
        {
          "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
          "line": 22,
          "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\n\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
          "itemtype": "method",
          "name": "tracked",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        },
        {
          "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
          "line": 158,
          "description": "Gives the getter a caching behavior. The return value of the getter\nwill be cached until any of the properties it is entangled with\nare invalidated. This is useful when a getter is expensive and\nused very often.\n\nFor instance, in this `GuestList` class, we have the `sortedGuests`\ngetter that sorts the guests alphabetically:\n\n```javascript\n  import { tracked } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nEvery time `sortedGuests` is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list\nis small, like the one in the example, this is not a problem. However, if\nthe guest list were to grow very large, it would mean that we would be doing\na large amount of work each time we accessed `sortedGuests`. With `@cached`,\nwe can cache the value instead:\n\n```javascript\n  import { tracked, cached } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    @cached\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nNow the `sortedGuests` getter will be cached based on autotracking.\nIt will only rerun and create a new sorted array when the guests tracked\nproperty is updated.\n\n\n### Tradeoffs\n\nOveruse is discouraged.\n\nIn general, you should avoid using `@cached` unless you have confirmed that\nthe getter you are decorating is computationally expensive, since `@cached`\nadds a small amount of overhead to the getter.\nWhile the individual costs are small, a systematic use of the `@cached`\ndecorator can add up to a large impact overall in your app.\nMany getters and tracked properties are only accessed once during rendering,\nand then never rerendered, so adding `@cached` when unnecessary can\nnegatively impact performance.\n\nAlso, `@cached` may rerun even if the values themselves have not changed,\nsince tracked properties will always invalidate.\nFor example updating an integer value from `5` to an other `5` will trigger\na rerun of the cached properties building from this integer.\n\nAvoiding a cache invalidation in this case is not something that can\nbe achieved on the `@cached` decorator itself, but rather when updating\nthe underlying tracked values, by applying some diff checking mechanisms:\n\n```javascript\nif (nextValue !== this.trackedProp) {\n  this.trackedProp = nextValue;\n}\n```\n\nHere equal values won't update the property, therefore not triggering\nthe subsequent cache invalidations of the `@cached` properties who were\nusing this `trackedProp`.\n\nRemember that setting tracked data should only be done during initialization,\nor as the result of a user action. Setting tracked data during render\n(such as in a getter), is not supported.",
          "itemtype": "method",
          "name": "cached",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        },
        {
          "file": "packages/@ember/-internals/metal/lib/cached.ts",
          "line": 7,
          "decorator": "Gives the getter a caching behavior. The return value of the getter\n will be cached until any of the properties it is entangled with\n are invalidated. This is useful when a getter is expensive and\n used very often.\n\n For instance, in this `GuestList` class, we have the `sortedGuests`\n getter that sorts the guests alphabetically:\n\n ```javascript\n   import { tracked } from '---AT-PLACEHOLDER---glimmer/tracking';\n\n   class GuestList {\n     ---AT-PLACEHOLDER---tracked guests = ['Zoey', 'Tomster'];\n\n     get sortedGuests() {\n       return this.guests.slice().sort()\n     }\n   }\n ```\n\n Every time `sortedGuests` is accessed, a new array will be created and sorted,\n because JavaScript getters do not cache by default. When the guest list\n is small, like the one in the example, this is not a problem. However, if\n the guest list were to grow very large, it would mean that we would be doing\n a large amount of work each time we accessed `sortedGuests`. With `@cached`,\n we can cache the value instead:\n\n ```javascript\n   import { tracked, cached } from '---AT-PLACEHOLDER---glimmer/tracking';\n\n   class GuestList {\n     ---AT-PLACEHOLDER---tracked guests = ['Zoey', 'Tomster'];\n\n     ---AT-PLACEHOLDER---cached\n     get sortedGuests() {\n       return this.guests.slice().sort()\n     }\n   }\n ```\n\n Now the `sortedGuests` getter will be cached based on autotracking.\n It will only rerun and create a new sorted array when the guests tracked\n property is updated.\n\n\n ### Tradeoffs\n\n Overuse is discouraged.\n\n In general, you should avoid using `@cached` unless you have confirmed that\n the getter you are decorating is computationally expensive, since `@cached`\n adds a small amount of overhead to the getter.\n While the individual costs are small, a systematic use of the `@cached`\n decorator can add up to a large impact overall in your app.\n Many getters and tracked properties are only accessed once during rendering,\n and then never rerendered, so adding `@cached` when unnecessary can\n negatively impact performance.\n\n Also, `@cached` may rerun even if the values themselves have not changed,\n since tracked properties will always invalidate.\n For example updating an integer value from `5` to an other `5` will trigger\n a rerun of the cached properties building from this integer.\n\n Avoiding a cache invalidation in this case is not something that can\n be achieved on the `@cached` decorator itself, but rather when updating\n the underlying tracked values, by applying some diff checking mechanisms:\n\n ```javascript\n if (nextValue !== this.trackedProp) {\n   this.trackedProp = nextValue;\n }\n ```\n\n Here equal values won't update the property, therefore not triggering\n the subsequent cache invalidations of the `@cached` properties who were\n using this `trackedProp`.\n\n Remember that setting tracked data should only be done during initialization, \n or as the result of a user action. Setting tracked data during render\n (such as in a getter), is not supported.",
          "itemtype": "method",
          "name": "cached",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking/primitives/cache"
        },
        {
          "file": "packages/@glimmer/runtime/lib/component/template-only.ts",
          "line": 59,
          "description": "This utility function is used to declare a given component has no backing class. When the rendering engine detects this it\nis able to perform a number of optimizations. Templates that are associated with `templateOnly()` will be rendered _as is_\nwithout adding a wrapping `<div>` (or any of the other element customization behaviors of [@ember/component](/ember/release/classes/Component)).\nSpecifically, this means that the template will be rendered as \"outer HTML\".\n\nIn general, this method will be used by build time tooling and would not be directly written in an application. However,\nat times it may be useful to use directly to leverage the \"outer HTML\" semantics mentioned above. For example, if an addon would like\nto use these semantics for its templates but cannot be certain it will only be consumed by applications that have enabled the\n`template-only-glimmer-components` optional feature.",
          "example": [
            "\n\n```js\nimport { templateOnlyComponent } from '@glimmer/runtime';\n\nexport default templateOnlyComponent();\n```"
          ],
          "access": "public",
          "tagname": "",
          "itemtype": "method",
          "name": "templateOnly",
          "params": [
            {
              "name": "moduleName",
              "description": "the module name that the template only component represents, this will be used for debugging purposes",
              "type": "String"
            }
          ],
          "category": [
            "EMBER_GLIMMER_SET_COMPONENT_TEMPLATE"
          ],
          "class": "@glimmer/tracking",
          "module": "@glimmer/component"
        },
        {
          "file": "packages/@glimmer/runtime/lib/helpers/array.ts",
          "line": 8,
          "description": "Use the `{{array}}` helper to create an array to pass as an option to your\ncomponents.\n\n```handlebars\n<MyComponent @people={{array\n  'Tom Dale'\n  'Yehuda Katz'\n  this.myOtherPerson}}\n/>\n```\n or\n```handlebars\n{{my-component people=(array\n  'Tom Dale'\n  'Yehuda Katz'\n  this.myOtherPerson)\n}}\n```\n\nWould result in an object such as:\n\n```js\n['Tom Dale', 'Yehuda Katz', this.get('myOtherPerson')]\n```\n\nWhere the 3rd item in the array is bound to updates of the `myOtherPerson` property.",
          "itemtype": "method",
          "name": "array",
          "params": [
            {
              "name": "options",
              "description": "",
              "type": "Array"
            }
          ],
          "return": {
            "description": "Array",
            "type": "Array"
          },
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/component"
        },
        {
          "file": "packages/@glimmer/runtime/lib/helpers/concat.ts",
          "line": 18,
          "description": "Concatenates the given arguments into a string.\n\nExample:\n\n```handlebars\n{{some-component name=(concat firstName \" \" lastName)}}\n\n{{! would pass name=\"<first name value> <last name value>\" to the component}}\n```\n\nor for angle bracket invocation, you actually don't need concat at all.\n\n```handlebars\n<SomeComponent @name=\"{{firstName}} {{lastName}}\" />\n```",
          "access": "public",
          "tagname": "",
          "itemtype": "method",
          "name": "concat",
          "class": "@glimmer/tracking",
          "module": "@glimmer/component"
        },
        {
          "file": "packages/@glimmer/runtime/lib/helpers/fn.ts",
          "line": 13,
          "description": "The `fn` helper allows you to ensure a function that you are passing off\nto another component, helper, or modifier has access to arguments that are\navailable in the template.\n\nFor example, if you have an `each` helper looping over a number of items, you\nmay need to pass a function that expects to receive the item as an argument\nto a component invoked within the loop. Here's how you could use the `fn`\nhelper to pass both the function and its arguments together:\n\n  ```handlebars {data-filename=app/templates/components/items-listing.hbs}\n{{#each @items as |item|}}\n  <DisplayItem @item=item @select={{fn this.handleSelected item}} />\n{{/each}}\n```\n\n```js {data-filename=app/components/items-list.js}\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class ItemsList extends Component {\n  handleSelected = (item) => {\n    // ...snip...\n  }\n}\n```\n\nIn this case the `display-item` component will receive a normal function\nthat it can invoke. When it invokes the function, the `handleSelected`\nfunction will receive the `item` and any arguments passed, thanks to the\n`fn` helper.\n\nLet's take look at what that means in a couple circumstances:\n\n- When invoked as `this.args.select()` the `handleSelected` function will\n  receive the `item` from the loop as its first and only argument.\n- When invoked as `this.args.select('foo')` the `handleSelected` function\n  will receive the `item` from the loop as its first argument and the\n  string `'foo'` as its second argument.\n\nIn the example above, we used an arrow function to ensure that\n`handleSelected` is properly bound to the `items-list`, but let's explore what\nhappens if we left out the arrow function:\n\n```js {data-filename=app/components/items-list.js}\nimport Component from '@glimmer/component';\n\nexport default class ItemsList extends Component {\n  handleSelected(item) {\n    // ...snip...\n  }\n}\n```\n\nIn this example, when `handleSelected` is invoked inside the `display-item`\ncomponent, it will **not** have access to the component instance. In other\nwords, it will have no `this` context, so please make sure your functions\nare bound (via an arrow function or other means) before passing into `fn`!\n\nSee also [partial application](https://en.wikipedia.org/wiki/Partial_application).",
          "itemtype": "method",
          "name": "fn",
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/component"
        },
        {
          "file": "packages/@glimmer/runtime/lib/helpers/get.ts",
          "line": 8,
          "description": "Dynamically look up a property on an object. The second argument to `{{get}}`\nshould have a string value, although it can be bound.\n\nFor example, these two usages are equivalent:\n\n```js {data-filename=app/components/developer-detail.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nexport default class extends Component {\n  @tracked developer = {\n    name: \"Sandi Metz\",\n    language: \"Ruby\"\n  }\n}\n```\n\n```handlebars\n{{this.developer.name}}\n{{get this.developer \"name\"}}\n```\n\nIf there were several facts about a person, the `{{get}}` helper can dynamically\npick one:\n\n```handlebars {data-filename=app/templates/application.hbs}\n<DeveloperDetail @factName=\"language\" />\n```\n\n```handlebars\n{{get this.developer @factName}}\n```\n\nFor a more complex example, this template would allow the user to switch\nbetween showing the user's height and weight with a click:\n\n```js {data-filename=app/components/developer-detail.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nexport default class extends Component {\n  @tracked developer = {\n    name: \"Sandi Metz\",\n    language: \"Ruby\"\n  }\n\n  @tracked currentFact = 'name'\n\n  showFact = (fact) => {\n    this.currentFact = fact;\n  }\n}\n```\n\n```js {data-filename=app/components/developer-detail.js}\n{{get this.developer this.currentFact}}\n\n<button {{on 'click' (fn this.showFact \"name\")}}>Show name</button>\n<button {{on 'click' (fn this.showFact \"language\")}}>Show language</button>\n```\n\nThe `{{get}}` helper can also respect mutable values itself. For example:\n\n```js {data-filename=app/components/developer-detail.js}\n<Input @value={{mut (get this.person this.currentFact)}} />\n\n<button {{on 'click' (fn this.showFact \"name\")}}>Show name</button>\n<button {{on 'click' (fn this.showFact \"language\")}}>Show language</button>\n```\n\nWould allow the user to swap what fact is being displayed, and also edit\nthat fact via a two-way mutable binding.",
          "access": "public",
          "tagname": "",
          "itemtype": "method",
          "name": "get",
          "class": "@glimmer/tracking",
          "module": "@glimmer/component"
        },
        {
          "file": "packages/@glimmer/runtime/lib/helpers/hash.ts",
          "line": 8,
          "description": "Use the `{{hash}}` helper to create a hash to pass as an option to your\ncomponents. This is specially useful for contextual components where you can\njust yield a hash:\n\n```handlebars\n{{yield (hash\n   name='Sarah'\n   title=office\n)}}\n```\n\nWould result in an object such as:\n\n```js\n{ name: 'Sarah', title: this.get('office') }\n```\n\nWhere the `title` is bound to updates of the `office` property.\n\nNote that the hash is an empty object with no prototype chain, therefore\ncommon methods like `toString` are not available in the resulting hash.\nIf you need to use such a method, you can use the `call` or `apply`\napproach:\n\n```js\nfunction toString(obj) {\n  return Object.prototype.toString.apply(obj);\n}\n```",
          "itemtype": "method",
          "name": "hash",
          "params": [
            {
              "name": "options",
              "description": "",
              "type": "Object"
            }
          ],
          "return": {
            "description": "Hash",
            "type": "Object"
          },
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/component"
        },
        {
          "file": "packages/@glimmer/runtime/lib/modifiers/on.ts",
          "line": 228,
          "description": "The `{{on}}` modifier lets you easily add event listeners (it uses\n[EventTarget.addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)\ninternally).\n\nFor example, if you'd like to run a function on your component when a `<button>`\nin the components template is clicked you might do something like:\n\n```handlebars {data-filename=app/components/like-post.hbs}\n<button {{on 'click' this.saveLike}}>Like this post!</button>\n```\n\n```js {data-filename=app/components/like-post.js}\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class LikePostComponent extends Component {\n  saveLike = () => {\n    // someone likes your post!\n    // better send a request off to your server...\n  }\n}\n```\n\n### Arguments\n\n`{{on}}` accepts two positional arguments, and a few named arguments.\n\nThe positional arguments are:\n\n- `event` -- the name to use when calling `addEventListener`\n- `callback` -- the function to be passed to `addEventListener`\n\nThe named arguments are:\n\n- capture -- a `true` value indicates that events of this type will be dispatched\n  to the registered listener before being dispatched to any EventTarget beneath it\n  in the DOM tree.\n- once -- indicates that the listener should be invoked at most once after being\n  added. If true, the listener would be automatically removed when invoked.\n- passive -- if `true`, indicates that the function specified by listener will never\n  call preventDefault(). If a passive listener does call preventDefault(), the user\n  agent will do nothing other than generate a console warning. See\n  [Improving scrolling performance with passive listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)\n  to learn more.\n\nThe callback function passed to `{{on}}` will receive any arguments that are passed\nto the event handler. Most commonly this would be the `event` itself.\n\nIf you would like to pass additional arguments to the function you should use\nthe `{{fn}}` helper.\n\nFor example, in our example case above if you'd like to pass in the post that\nwas being liked when the button is clicked you could do something like:\n\n```handlebars {data-filename=app/components/like-post.hbs}\n<button {{on 'click' (fn this.saveLike @post)}}>Like this post!</button>\n```\n\nIn this case, the `saveLike` function will receive two arguments: the click event\nand the value of `@post`.\n\n### Function Context\n\nIn the example above, we used an arrow function to ensure that `likePost` is\nproperly bound to the `items-list`, but let's explore what happens if we\nleft out the arrow function:\n\n```js {data-filename=app/components/like-post.js}\nimport Component from '@glimmer/component';\n\nexport default class LikePostComponent extends Component {\n  saveLike() {\n    // ...snip...\n  }\n}\n```\n\nIn this example, when the button is clicked `saveLike` will be invoked,\nit will **not** have access to the component instance. In other\nwords, it will have no `this` context, so please make sure your functions\nare bound (via an arrow function or other means) before passing into `on`!",
          "itemtype": "method",
          "name": "on",
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/component"
        },
        {
          "file": "packages/@glimmer/tracking/index.ts",
          "line": 16,
          "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
          "itemtype": "method",
          "name": "tracked",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        },
        {
          "file": "packages/@glimmer/tracking/index.ts",
          "line": 150,
          "description": "The `@cached` decorator can be used on getters in order to cache the return\nvalue of the getter. This is useful when a getter is expensive and used very\noften. For instance, in this guest list class, we have the `sortedGuests`\ngetter that sorts the guests alphabetically:\n\n```js\nimport { tracked } from '@glimmer/tracking';\n\nclass GuestList {\n  @tracked guests = ['Zoey', 'Tomster'];\n\n  get sortedGuests() {\n    return this.guests.slice().sort()\n  }\n}\n```\n\nEvery time `sortedGuests` is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list is\nsmall, like the one in the example, this is not a problem. However, if the guest\nlist were to grow very large, it would mean that we would be doing a large\namount of work each time we accessed `sortedGetters`. With `@cached`, we can\ncache the value instead:\n\n```js\nimport { tracked, cached } from '@glimmer/tracking';\n\nclass GuestList {\n  @tracked guests = ['Zoey', 'Tomster'];\n\n  @cached\n  get sortedGuests() {\n    return this.guests.slice().sort()\n  }\n}\n```\n\nNow the `sortedGuests` getter will be cached based on _autotracking_. It will\nonly rerun and create a new sorted array when the `guests` tracked property is\nupdated.\n\nIn general, you should avoid using `@cached` unless you have confirmed that the\ngetter you are decorating is computationally expensive. `@cached` adds a small\namount of overhead to the getter, making it more expensive. While this overhead\nis small, if `@cached` is overused it can add up to a large impact overall in\nyour app. Many getters and tracked properties are only accessed once, rendered,\nand then never rerendered, so adding `@cached` when it is unnecessary can\nnegatively impact performance.",
          "itemtype": "method",
          "name": "cached",
          "static": 1,
          "access": "public",
          "tagname": "",
          "class": "@glimmer/tracking",
          "module": "@glimmer/tracking"
        }
      ],
      "events": [],
      "properties": []
    },
    "relationships": {
      "parent-class": {
        "data": null
      },
      "descendants": {
        "data": []
      },
      "module": {
        "data": {
          "id": "ember-6.12.0-alpha.1-@glimmer/tracking",
          "type": "module"
        }
      },
      "project-version": {
        "data": {
          "id": "ember-6.12.0-alpha.1",
          "type": "project-version"
        }
      }
    }
  }
}