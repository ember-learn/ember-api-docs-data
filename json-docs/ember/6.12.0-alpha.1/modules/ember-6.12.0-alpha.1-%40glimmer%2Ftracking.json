{
  "data": {
    "id": "ember-6.12.0-alpha.1-@glimmer/tracking",
    "type": "module",
    "attributes": {
      "name": "@glimmer/tracking",
      "submodules": {},
      "elements": {},
      "fors": {
        "@glimmer/tracking": 1
      },
      "namespaces": {},
      "tag": "module",
      "file": "packages/@glimmer/tracking/index.ts",
      "line": 3,
      "description": "In order to tell Ember a value might change, we need to mark it as trackable.\nTrackable values are values that:\n\n- Can change over their componentâ€™s lifetime and\n- Should cause Ember to rerender if and when they change\n\nWe can do this by marking the field with the `@tracked` decorator.",
      "access": "public",
      "tagname": "",
      "parent": null,
      "publicclasses": [],
      "privateclasses": [],
      "staticfunctions": {
        "@glimmer/tracking": [
          {
            "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
            "line": 158,
            "description": "Gives the getter a caching behavior. The return value of the getter\nwill be cached until any of the properties it is entangled with\nare invalidated. This is useful when a getter is expensive and\nused very often.\n\nFor instance, in this `GuestList` class, we have the `sortedGuests`\ngetter that sorts the guests alphabetically:\n\n```javascript\n  import { tracked } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nEvery time `sortedGuests` is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list\nis small, like the one in the example, this is not a problem. However, if\nthe guest list were to grow very large, it would mean that we would be doing\na large amount of work each time we accessed `sortedGuests`. With `@cached`,\nwe can cache the value instead:\n\n```javascript\n  import { tracked, cached } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    @cached\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nNow the `sortedGuests` getter will be cached based on autotracking.\nIt will only rerun and create a new sorted array when the guests tracked\nproperty is updated.\n\n\n### Tradeoffs\n\nOveruse is discouraged.\n\nIn general, you should avoid using `@cached` unless you have confirmed that\nthe getter you are decorating is computationally expensive, since `@cached`\nadds a small amount of overhead to the getter.\nWhile the individual costs are small, a systematic use of the `@cached`\ndecorator can add up to a large impact overall in your app.\nMany getters and tracked properties are only accessed once during rendering,\nand then never rerendered, so adding `@cached` when unnecessary can\nnegatively impact performance.\n\nAlso, `@cached` may rerun even if the values themselves have not changed,\nsince tracked properties will always invalidate.\nFor example updating an integer value from `5` to an other `5` will trigger\na rerun of the cached properties building from this integer.\n\nAvoiding a cache invalidation in this case is not something that can\nbe achieved on the `@cached` decorator itself, but rather when updating\nthe underlying tracked values, by applying some diff checking mechanisms:\n\n```javascript\nif (nextValue !== this.trackedProp) {\n  this.trackedProp = nextValue;\n}\n```\n\nHere equal values won't update the property, therefore not triggering\nthe subsequent cache invalidations of the `@cached` properties who were\nusing this `trackedProp`.\n\nRemember that setting tracked data should only be done during initialization,\nor as the result of a user action. Setting tracked data during render\n(such as in a getter), is not supported.",
            "itemtype": "method",
            "name": "cached",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          },
          {
            "file": "packages/@glimmer/tracking/index.ts",
            "line": 150,
            "description": "The `@cached` decorator can be used on getters in order to cache the return\nvalue of the getter. This is useful when a getter is expensive and used very\noften. For instance, in this guest list class, we have the `sortedGuests`\ngetter that sorts the guests alphabetically:\n\n```js\nimport { tracked } from '@glimmer/tracking';\n\nclass GuestList {\n  @tracked guests = ['Zoey', 'Tomster'];\n\n  get sortedGuests() {\n    return this.guests.slice().sort()\n  }\n}\n```\n\nEvery time `sortedGuests` is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list is\nsmall, like the one in the example, this is not a problem. However, if the guest\nlist were to grow very large, it would mean that we would be doing a large\namount of work each time we accessed `sortedGetters`. With `@cached`, we can\ncache the value instead:\n\n```js\nimport { tracked, cached } from '@glimmer/tracking';\n\nclass GuestList {\n  @tracked guests = ['Zoey', 'Tomster'];\n\n  @cached\n  get sortedGuests() {\n    return this.guests.slice().sort()\n  }\n}\n```\n\nNow the `sortedGuests` getter will be cached based on _autotracking_. It will\nonly rerun and create a new sorted array when the `guests` tracked property is\nupdated.\n\nIn general, you should avoid using `@cached` unless you have confirmed that the\ngetter you are decorating is computationally expensive. `@cached` adds a small\namount of overhead to the getter, making it more expensive. While this overhead\nis small, if `@cached` is overused it can add up to a large impact overall in\nyour app. Many getters and tracked properties are only accessed once, rendered,\nand then never rerendered, so adding `@cached` when it is unnecessary can\nnegatively impact performance.",
            "itemtype": "method",
            "name": "cached",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          },
          {
            "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
            "line": 22,
            "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\n\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
            "itemtype": "method",
            "name": "tracked",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          },
          {
            "file": "packages/@glimmer/tracking/index.ts",
            "line": 16,
            "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
            "itemtype": "method",
            "name": "tracked",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          }
        ]
      },
      "allstaticfunctions": {
        "@glimmer/tracking": [
          {
            "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
            "line": 158,
            "description": "Gives the getter a caching behavior. The return value of the getter\nwill be cached until any of the properties it is entangled with\nare invalidated. This is useful when a getter is expensive and\nused very often.\n\nFor instance, in this `GuestList` class, we have the `sortedGuests`\ngetter that sorts the guests alphabetically:\n\n```javascript\n  import { tracked } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nEvery time `sortedGuests` is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list\nis small, like the one in the example, this is not a problem. However, if\nthe guest list were to grow very large, it would mean that we would be doing\na large amount of work each time we accessed `sortedGuests`. With `@cached`,\nwe can cache the value instead:\n\n```javascript\n  import { tracked, cached } from '@glimmer/tracking';\n\n  class GuestList {\n    @tracked guests = ['Zoey', 'Tomster'];\n\n    @cached\n    get sortedGuests() {\n      return this.guests.slice().sort()\n    }\n  }\n```\n\nNow the `sortedGuests` getter will be cached based on autotracking.\nIt will only rerun and create a new sorted array when the guests tracked\nproperty is updated.\n\n\n### Tradeoffs\n\nOveruse is discouraged.\n\nIn general, you should avoid using `@cached` unless you have confirmed that\nthe getter you are decorating is computationally expensive, since `@cached`\nadds a small amount of overhead to the getter.\nWhile the individual costs are small, a systematic use of the `@cached`\ndecorator can add up to a large impact overall in your app.\nMany getters and tracked properties are only accessed once during rendering,\nand then never rerendered, so adding `@cached` when unnecessary can\nnegatively impact performance.\n\nAlso, `@cached` may rerun even if the values themselves have not changed,\nsince tracked properties will always invalidate.\nFor example updating an integer value from `5` to an other `5` will trigger\na rerun of the cached properties building from this integer.\n\nAvoiding a cache invalidation in this case is not something that can\nbe achieved on the `@cached` decorator itself, but rather when updating\nthe underlying tracked values, by applying some diff checking mechanisms:\n\n```javascript\nif (nextValue !== this.trackedProp) {\n  this.trackedProp = nextValue;\n}\n```\n\nHere equal values won't update the property, therefore not triggering\nthe subsequent cache invalidations of the `@cached` properties who were\nusing this `trackedProp`.\n\nRemember that setting tracked data should only be done during initialization,\nor as the result of a user action. Setting tracked data during render\n(such as in a getter), is not supported.",
            "itemtype": "method",
            "name": "cached",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          },
          {
            "file": "packages/@glimmer/tracking/index.ts",
            "line": 150,
            "description": "The `@cached` decorator can be used on getters in order to cache the return\nvalue of the getter. This is useful when a getter is expensive and used very\noften. For instance, in this guest list class, we have the `sortedGuests`\ngetter that sorts the guests alphabetically:\n\n```js\nimport { tracked } from '@glimmer/tracking';\n\nclass GuestList {\n  @tracked guests = ['Zoey', 'Tomster'];\n\n  get sortedGuests() {\n    return this.guests.slice().sort()\n  }\n}\n```\n\nEvery time `sortedGuests` is accessed, a new array will be created and sorted,\nbecause JavaScript getters do not cache by default. When the guest list is\nsmall, like the one in the example, this is not a problem. However, if the guest\nlist were to grow very large, it would mean that we would be doing a large\namount of work each time we accessed `sortedGetters`. With `@cached`, we can\ncache the value instead:\n\n```js\nimport { tracked, cached } from '@glimmer/tracking';\n\nclass GuestList {\n  @tracked guests = ['Zoey', 'Tomster'];\n\n  @cached\n  get sortedGuests() {\n    return this.guests.slice().sort()\n  }\n}\n```\n\nNow the `sortedGuests` getter will be cached based on _autotracking_. It will\nonly rerun and create a new sorted array when the `guests` tracked property is\nupdated.\n\nIn general, you should avoid using `@cached` unless you have confirmed that the\ngetter you are decorating is computationally expensive. `@cached` adds a small\namount of overhead to the getter, making it more expensive. While this overhead\nis small, if `@cached` is overused it can add up to a large impact overall in\nyour app. Many getters and tracked properties are only accessed once, rendered,\nand then never rerendered, so adding `@cached` when it is unnecessary can\nnegatively impact performance.",
            "itemtype": "method",
            "name": "cached",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          },
          {
            "file": "packages/@ember/-internals/glimmer/lib/glimmer-tracking-docs.ts",
            "line": 22,
            "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\n\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
            "itemtype": "method",
            "name": "tracked",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          },
          {
            "file": "packages/@glimmer/tracking/index.ts",
            "line": 16,
            "description": "Marks a property as tracked. By default, values that are rendered in Ember app\ntemplates are _static_, meaning that updates to them won't cause the\napplication to rerender. Marking a property as tracked means that when that\nproperty changes, any templates that used that property, directly or\nindirectly, will rerender. For instance, consider this component:\n\n```handlebars\n<div>Count: {{this.count}}</div>\n<div>Times Ten: {{this.timesTen}}</div>\n<div>\n  <button {{on \"click\" this.plusOne}}>\n    Plus One\n  </button>\n</div>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get timesTen() {\n    return this.count * 10;\n  }\n\n  @action\n  plusOne() {\n    this.count += 1;\n  }\n}\n```\n\nBoth the `{{this.count}}` and the `{{this.timesTen}}` properties in the\ntemplate will update whenever the button is clicked. Any tracked properties\nthat are used in any way to calculate a value that is used in the template\nwill cause a rerender when updated - this includes through method calls and\nother means:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nclass Entry {\n  @tracked name;\n  @tracked phoneNumber;\n\n  constructor(name, phoneNumber) {\n    this.name = name;\n    this.phoneNumber = phoneNumber;\n  }\n}\n\nexport default class PhoneBookComponent extends Component {\n  entries = [\n    new Entry('Pizza Palace', 5551234),\n    new Entry('1st Street Cleaners', 5554321),\n    new Entry('Plants R Us', 5552468),\n  ];\n\n  // Any usage of this property will update whenever any of the names in the\n  // entries arrays are updated\n  get names() {\n    return this.entries.map(e => e.name);\n  }\n\n  // Any usage of this property will update whenever any of the numbers in the\n  // entries arrays are updated\n  get numbers() {\n    return this.getFormattedNumbers();\n  }\n\n  getFormattedNumbers() {\n    return this.entries\n      .map(e => e.phoneNumber)\n      .map(number => {\n        let numberString = '' + number;\n\n        return numberString.slice(0, 3) + '-' + numberString.slice(3);\n      });\n  }\n}\n```\n\nIt's important to note that setting tracked properties will always trigger an\nupdate, even if the property is set to the same value as it was before.\n\n```js\nlet entry = new Entry('Pizza Palace', 5551234);\n// if entry was used when rendering, this would cause a rerender, even though\n// the name is being set to the same value as it was before\nentry.name = entry.name;\n```\n\n`tracked` can also be used with the classic Ember object model in a similar\nmanner to classic computed properties:\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked(),\n  phoneNumber: tracked()\n});\n```\n\nOften this is unnecessary, but to ensure robust auto-tracking behavior it is\nadvisable to mark tracked state appropriately wherever possible.\nThis form of `tracked` also accepts an optional configuration object\ncontaining either an initial `value` or an `initializer` function (but not\nboth).\n\n```javascript\nimport EmberObject from '@ember/object';\nimport { tracked } from '@glimmer/tracking';\n\nconst Entry = EmberObject.extend({\n  name: tracked({ value: 'Zoey' }),\n  favoriteSongs: tracked({\n    initializer: () => ['Raspberry Beret', 'Time After Time']\n  })\n});\n```",
            "itemtype": "method",
            "name": "tracked",
            "static": 1,
            "access": "public",
            "tagname": "",
            "class": "@glimmer/tracking",
            "module": "@glimmer/tracking"
          }
        ]
      },
      "version": "6.12.0-alpha.1"
    },
    "relationships": {
      "classes": {
        "data": []
      },
      "project-version": {
        "data": {
          "id": "ember-6.12.0-alpha.1",
          "type": "project-version"
        }
      }
    }
  }
}